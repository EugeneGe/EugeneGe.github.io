[{"permalink":"/blog/frontier/new/technology/","layout":"default","title":"科技","content":"# 科技\n\n{% include list.liquid all=true %}\n","dir":"/blog/frontier/new/technology/","name":"README.md","path":"blog/frontier/new/technology/README.md","url":"/blog/frontier/new/technology/"},{"permalink":"/blog/about/website/","layout":"default","title":"网站","content":"# 网站\n\n","dir":"/blog/about/website/","name":"README.md","path":"blog/about/website/README.md","url":"/blog/about/website/"},{"layout":"default","title":null,"content":"├─_includes #包含文件目录，存放可重用的 HTML 文件片段。\n│ │ list.liquid #\n│ │ README.md #\n│ │ #\n│ ├─common #\n│ │ │ google_adsense.liquid #\n│ │ │ google_gtag.liquid #\n│ │ │ links.liquid # link 样式及图标引入\n│ │ │ mathjax.liquid #\n│ │ │ mermaid.liquid #\n│ │ │ metadata.liquid # blog生成html的meta设置\n│ │ │ opengraph.liquid # blog生成html的meta设置\n│ │ │ schema.liquid # blog生成html的script application/ld+json 描述\n│ │ │ script.liquid # 搜索页面展示\n│ │ │ title.liquid #\n│ │ │ twitter_cards.liquid # blog生成html的meta设置\n│ │ │ #\n│ │ ├─assets #\n│ │ │ data.liquid #\n│ │ │ robots.liquid #\n│ │ │ sitemap.liquid # sitemap.xml生成设置\n│ │ │ sw.caches.js #\n│ │ │ #\n│ │ ├─core #\n│ │ │ list.liquid # 生成左侧文章目录\n│ │ │ _list.liquid #\n│ │ │ #\n│ │ └─rest #\n│ │ content.liquid # md生成html文章，自定义需要替换的标签\n│ │ defaults.liquid #\n│ │ description.liquid # 根据文章生成meta中的description设置\n│ │ i18n.liquid #\n│ │ nav.liquid # 上一页，下一页？\n│ │ site_pages.liquid #\n│ │ tabs.liquid #\n│ │ title.liquid #\n│ │ variables.liquid #\n│ │ workdir.liquid #\n│ │ #\n│ ├─extra #\n│ │ body.html #\n│ │ head.html #\n│ │ script.js #\n│ │ styles.scss #\n│ │ #\n│ ├─rest #\n│ │ defaults.liquid #\n│ │ script.liquid #\n│ │ styles.liquid #\n│ │ #\n│ ├─shortcodes #\n│ │ danger.liquid #\n│ │ mermaid.liquid #\n│ │ note.liquid #\n│ │ tip.liquid #\n│ │ warning.liquid #\n│ │ #\n│ └─templates #\n│ │ addons.liquid #\n│ │ breadcrumbs.liquid #\n│ │ content.liquid # 文章主体排版\n│ │ footer.liquid # 文章底部布局\n│ │ sidebar.liquid # 文章左侧布局\n│ │ toctree.liquid #\n│ │ _toctree.liquid #\n│ │ #\n│ └─content #\n│ content_footer.liquid #\n│ content_header.liquid #\n│ #\n├─_layouts # 布局目录，定义网站的结构、排版等。\n│ │ default.liquid #\n│ │ #\n│ └─tasks #\n│ compress.liquid #\n│ shortcodes.liquid #\n│ #\n├─_sass # Sass 文件目录，存放 Sass 样式文件。\n│ │ theme.scss #\n│ │ _direction.scss #\n│ │ _font-face.scss #\n│ │ _layout.scss #\n│ │ _rest.scss #\n│ │ _root.scss #\n│ │ _variables.scss #\n│ │ #\n│ ├─core #\n│ │ addons.scss #\n│ │ container.scss #\n│ │ content.scss #\n│ │ header.scss #\n│ │ markdown.scss #\n│ │ sidebar.scss #\n│ │ title.scss #\n│ │ toasts.scss #\n│ │ #\n│ └─lib #\n│ ├─@primer #\n│ │ └─css #\n│ │ ├─base #\n│ │ │ base.scss #\n│ │ │ index.scss #\n│ │ │ kbd.scss #\n│ │ │ normalize.scss #\n│ │ │ README.md #\n│ │ │ typography-base.scss #\n│ │ │ #\n│ │ ├─breadcrumb #\n│ │ │ breadcrumb.scss #\n│ │ │ index.scss #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─buttons #\n│ │ │ button-group.scss #\n│ │ │ button.scss #\n│ │ │ index.scss #\n│ │ │ misc.scss #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─forms #\n│ │ │ form-control.scss #\n│ │ │ form-group.scss #\n│ │ │ form-select.scss #\n│ │ │ form-validation.scss #\n│ │ │ index.scss #\n│ │ │ input-group.scss #\n│ │ │ radio-group.scss #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─loaders #\n│ │ │ index.scss #\n│ │ │ loaders.scss #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─markdown #\n│ │ │ blob-csv.scss #\n│ │ │ code.scss #\n│ │ │ headings.scss #\n│ │ │ images.scss #\n│ │ │ index.scss #\n│ │ │ lists.scss #\n│ │ │ markdown-body.scss #\n│ │ │ README.md #\n│ │ │ tables.scss #\n│ │ │ #\n│ │ ├─support #\n│ │ │ │ index.scss #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ ├─mixins #\n│ │ │ │ buttons.scss #\n│ │ │ │ layout.scss #\n│ │ │ │ misc.scss #\n│ │ │ │ typography.scss #\n│ │ │ │ #\n│ │ │ └─variables #\n│ │ │ color-system.scss #\n│ │ │ colors.scss #\n│ │ │ layout.scss #\n│ │ │ misc.scss #\n│ │ │ typography.scss #\n│ │ │ #\n│ │ └─utilities #\n│ │ animations.scss #\n│ │ borders.scss #\n│ │ box-shadow.scss #\n│ │ colors.scss #\n│ │ details.scss #\n│ │ flexbox.scss #\n│ │ index.scss #\n│ │ layout.scss #\n│ │ margin.scss #\n│ │ padding.scss #\n│ │ README.md #\n│ │ typography.scss #\n│ │ visibility-display.scss #\n│ │ #\n│ ├─font-awesome #\n│ │ _icons.scss #\n│ │ _variables.scss #\n│ │ #\n│ ├─material-design-lite #\n│ │ _color-definitions.scss #\n│ │ _functions.scss #\n│ │ _mixins.scss #\n│ │ _variables.scss #\n│ │ #\n│ └─rouge #\n│ github.scss #\n│ #\n│ .gitignore #\n│ .prettierignore #\n│ CNAME #\n│ Gemfile #\n│ Gemfile.lock #\n│ index.html # 首页文件。\n│ jekyll-rtd-theme.gemspec #\n│ LICENSE #\n│ Makefile #\n│ package.json #\n│ README.md #\n│ READMETREE.md #\n│ requirements.txt #\n│ update.sh #\n│ webpack.config.js #\n│ _config.yml # 配置文件，包括全局配置、插件配置等。\n│ #\n├─.bundle #\n│ config #\n│ #\n├─.vscode #\n│ settings.json #\n│ #\n├─blog # 文章目录，已发布的文章按照年月日命名，格式为 yyyy-mm-dd-title.md\n│ │ README.md #\n│ │ #\n│ ├─about #\n│ │ │ README.md #\n│ │ │ #\n│ │ └─website #\n│ │ 2023-04-23_1.md #\n│ │ README.md #\n│ │ #\n│ ├─development #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─html #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ ├─jottings #\n│ │ │ │ 2023-04-21_1.md #\n│ │ │ │ 2023-04-27_1.md #\n│ │ │ │ 2023-05-12_1.md #\n│ │ │ │ 2023-05-12_2.md #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ ├─seo #\n│ │ │ │ 2023-04-27_1.md #\n│ │ │ │ 2023-04-27_2.md #\n│ │ │ │ 2023-04-27_3.md #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ └─webdesign #\n│ │ │ 2023-04-24_1.md #\n│ │ │ 2023-04-24_2.md #\n│ │ │ 2023-05-12_1.md #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─interview #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ └─java #\n│ │ │ 2023-04-23_1.md #\n│ │ │ 2023-04-23_2.md #\n│ │ │ 2023-04-23_3.md #\n│ │ │ 2023-04-23_4.md #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─java #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ ├─basics #\n│ │ │ │ 2023-04-24_1.md #\n│ │ │ │ 2023-04-24_2.md #\n│ │ │ │ 2023-04-24_3.md #\n│ │ │ │ 2023-04-27_1.md #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ ├─jottings #\n│ │ │ │ 2023-04-23_1.md #\n│ │ │ │ 2023-04-27_1.md #\n│ │ │ │ 2023-04-27_2.md #\n│ │ │ │ 2023-05-12_1.md #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ └─tool #\n│ │ │ 2023-05-12_1.md #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─os #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ ├─linux #\n│ │ │ │ 2023-04-23_1.md #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ └─windows #\n│ │ │ 2023-04-27_1.md #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─python #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ ├─django #\n│ │ │ │ 2023-04-27_1.md #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ └─jottings #\n│ │ │ README.md #\n│ │ │ #\n│ │ └─tool #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─git #\n│ │ │ 2023-04-27_1.md #\n│ │ │ 2023-04-28_1.md #\n│ │ │ 2023-05-12_1.md #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─maven #\n│ │ │ 2023-04-27_1.md #\n│ │ │ README.md #\n│ │ │ #\n│ │ └─redis #\n│ │ 2023-04-30_1.md #\n│ │ 2023-04-30_2.md #\n│ │ README.md #\n│ │ #\n│ ├─frontier #\n│ │ │ README.md #\n│ │ │ #\n│ │ ├─new #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ ├─life #\n│ │ │ │ 2023-04-23_1.md #\n│ │ │ │ README.md #\n│ │ │ │ #\n│ │ │ └─technology #\n│ │ │ 2023-04-23_1.md #\n│ │ │ README.md #\n│ │ │ #\n│ │ └─recommend #\n│ │ 2023-04-23_1.md #\n│ │ 2023-04-27_1.md #\n│ │ README.md #\n│ │ #\n│ └─life #\n│ │ README.md #\n│ │ #\n│ ├─poetry #\n│ │ README.md #\n│ │ #\n│ └─travel #\n│ README.md #\n│ #\n├─blog_img #\n├─static # 静态文件目录，包括 CSS、JavaScript、图片等。\n│ ├─assets #\n│ │ │ 404.liquid #\n│ │ │ data.liquid #\n│ │ │ robots.liquid #\n│ │ │ search.liquid #\n│ │ │ sitemap.liquid #\n│ │ │ sw.caches.liquid #\n│ │ │ #\n│ │ ├─css #\n│ │ │ │ theme.min.css #\n│ │ │ │ theme.scss #\n│ │ │ │ #\n│ │ │ └─fonts #\n│ │ │ fontawesome-webfont.eot #\n│ │ │ fontawesome-webfont.svg #\n│ │ │ fontawesome-webfont.ttf #\n│ │ │ fontawesome-webfont.woff #\n│ │ │ fontawesome-webfont.woff2 #\n│ │ │ lato-bold-italic.woff #\n│ │ │ lato-bold-italic.woff2 #\n│ │ │ lato-bold.woff #\n│ │ │ lato-bold.woff2 #\n│ │ │ lato-normal-italic.woff #\n│ │ │ lato-normal-italic.woff2 #\n│ │ │ lato-normal.woff #\n│ │ │ lato-normal.woff2 #\n│ │ │ Roboto-Slab-Bold.woff #\n│ │ │ Roboto-Slab-Bold.woff2 #\n│ │ │ Roboto-Slab-Regular.woff #\n│ │ │ Roboto-Slab-Regular.woff2 #\n│ │ │ #\n│ │ ├─ico #\n│ │ │ apple-touch-icon-300x300.jpg #\n│ │ │ favicon-16x16.png #\n│ │ │ favicon-32x32.png #\n│ │ │ favicon-96x96.png #\n│ │ │ favicon.liquid #\n│ │ │ #\n│ │ └─js #\n│ │ jquery.min.js #\n│ │ mermaid.min.js #\n│ │ theme.js #\n│ │ theme.min.js #\n│ │ #\n│ └─home #\n│ ├─css #\n│ │ │ style.css #\n│ │ │ #\n│ │ └─img #\n│ │ github.png #\n│ │ scask.png #\n│ │ scbaidu.png #\n│ │ scbing.png #\n│ │ scdouyin.png #\n│ │ scduckduckgo.png #\n│ │ scgoogle.png #\n│ │ scso.png #\n│ │ scsogou.png #\n│ │ scwangpan.png #\n│ │ scwikipedia.png #\n│ │ scyahoo.png #\n│ │ scyandex.png #\n│ │ search.png #\n│ │ #\n│ ├─ico #\n│ │ favicon.ico #\n│ │ favicon.png #\n│ │ logo.png #\n│ │ #\n│ └─js #\n│ jquery.min.js #\n│ keyword.js #\n│ #\n├─.github #\n│ │ CODEOWNERS #\n│ │ CODE_OF_CONDUCT.md #\n│ │ CONTRIBUTING.md #\n│ │ dependabot.yml #\n│ │ FUNDING.yml #\n│ │ PULL_REQUEST_TEMPLATE.md #\n│ │ #\n│ ├─ISSUE_TEMPLATE #\n│ │ bug_report.md #\n│ │ #\n│ └─workflows #\n│ ci.yml #\n│ #\n└─_site # 生成的网站目录，Jekyll 会在本地生成网站，并将生成的网站文件保存在这个目录下。\n │ .gitkeep #\n │ 404.html #\n │ data.json #\n │ index.html #\n │ README.md #\n │ robots.txt #\n │ search.html #\n │ sitemap.xml #\n │ sw.caches.js #\n │ #\n ├─blog #\n │ │ index.html #\n │ │ #\n │ ├─about #\n │ │ │ index.html #\n │ │ │ #\n │ │ └─website #\n │ │ 2023-04-23_1.html #\n │ │ index.html #\n │ │ README.md #\n │ │ #\n │ ├─development #\n │ │ │ index.html #\n │ │ │ #\n │ │ ├─html #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ ├─jottings #\n │ │ │ │ 2023-04-21_1.html #\n │ │ │ │ 2023-04-27_1.html #\n │ │ │ │ 2023-05-12_1.html #\n │ │ │ │ 2023-05-12_2.html #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ ├─seo #\n │ │ │ │ 2023-04-27_1.html #\n │ │ │ │ 2023-04-27_2.html #\n │ │ │ │ 2023-04-27_3.html #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ └─webdesign #\n │ │ │ 2023-04-24_1.html #\n │ │ │ 2023-04-24_2.html #\n │ │ │ 2023-05-12_1.html #\n │ │ │ index.html #\n │ │ │ #\n │ │ ├─interview #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ └─java #\n │ │ │ 2023-04-23_1.html #\n │ │ │ 2023-04-23_2.html #\n │ │ │ 2023-04-23_3.html #\n │ │ │ 2023-04-23_4.html #\n │ │ │ index.html #\n │ │ │ #\n │ │ ├─java #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ ├─basics #\n │ │ │ │ 2023-04-24_1.html #\n │ │ │ │ 2023-04-24_2.html #\n │ │ │ │ 2023-04-24_3.html #\n │ │ │ │ 2023-04-27_1.html #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ ├─jottings #\n │ │ │ │ 2023-04-23_1.html #\n │ │ │ │ 2023-04-27_1.html #\n │ │ │ │ 2023-04-27_2.html #\n │ │ │ │ 2023-05-12_1.html #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ └─tool #\n │ │ │ 2023-05-12_1.html #\n │ │ │ index.html #\n │ │ │ #\n │ │ ├─os #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ ├─linux #\n │ │ │ │ 2023-04-23_1.html #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ └─windows #\n │ │ │ 2023-04-27_1.html #\n │ │ │ index.html #\n │ │ │ #\n │ │ ├─python #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ ├─django #\n │ │ │ │ 2023-04-27_1.html #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ └─jottings #\n │ │ │ index.html #\n │ │ │ #\n │ │ └─tool #\n │ │ │ index.html #\n │ │ │ #\n │ │ ├─git #\n │ │ │ 2023-04-27_1.html #\n │ │ │ 2023-04-28_1.html #\n │ │ │ 2023-05-12_1.html #\n │ │ │ index.html #\n │ │ │ #\n │ │ ├─maven #\n │ │ │ 2023-04-27_1.html #\n │ │ │ index.html #\n │ │ │ #\n │ │ └─redis #\n │ │ 2023-04-30_1.html #\n │ │ 2023-04-30_2.html #\n │ │ index.html #\n │ │ #\n │ ├─frontier #\n │ │ │ index.html #\n │ │ │ #\n │ │ ├─new #\n │ │ │ │ index.html #\n │ │ │ │ #\n │ │ │ ├─life #\n │ │ │ │ 2023-04-23_1.html #\n │ │ │ │ index.html #\n │ │ │ │ README.md #\n │ │ │ │ #\n │ │ │ └─technology #\n │ │ │ 2023-04-23_1.html #\n │ │ │ index.html #\n │ │ │ README.md #\n │ │ │ #\n │ │ └─recommend #\n │ │ 2023-04-23_1.html #\n │ │ 2023-04-27_1.html #\n │ │ index.html #\n │ │ #\n │ └─life #\n │ │ index.html #\n │ │ #\n │ ├─poetry #\n │ │ index.html #\n │ │ README.md #\n │ │ #\n │ └─travel #\n │ index.html #\n │ README.md #\n │ #\n └─static #\n ├─assets #\n │ ├─css #\n │ │ │ theme.css #\n │ │ │ theme.min.css #\n │ │ │ #\n │ │ └─fonts #\n │ │ fontawesome-webfont.eot #\n │ │ fontawesome-webfont.svg #\n │ │ fontawesome-webfont.ttf #\n │ │ fontawesome-webfont.woff #\n │ │ fontawesome-webfont.woff2 #\n │ │ lato-bold-italic.woff #\n │ │ lato-bold-italic.woff2 #\n │ │ lato-bold.woff #\n │ │ lato-bold.woff2 #\n │ │ lato-normal-italic.woff #\n │ │ lato-normal-italic.woff2 #\n │ │ lato-normal.woff #\n │ │ lato-normal.woff2 #\n │ │ Roboto-Slab-Bold.woff #\n │ │ Roboto-Slab-Bold.woff2 #\n │ │ Roboto-Slab-Regular.woff #\n │ │ Roboto-Slab-Regular.woff2 #\n │ │ #\n │ ├─ico #\n │ │ apple-touch-icon-300x300.jpg #\n │ │ favicon-16x16.png #\n │ │ favicon-32x32.png #\n │ │ favicon-96x96.png #\n │ │ #\n │ ├─images #\n │ │ favicon.svg #\n │ │ #\n │ └─js #\n │ jquery.min.js #\n │ mermaid.min.js #\n │ theme.js #\n │ theme.min.js #\n │ #\n └─home #\n ├─css #\n │ │ style.css #\n │ │ #\n │ └─img #\n │ github.png #\n │ scask.png #\n │ scbaidu.png #\n │ scbing.png #\n │ scdouyin.png #\n │ scduckduckgo.png #\n │ scgoogle.png #\n │ scso.png #\n │ scsogou.png #\n │ scwangpan.png #\n │ scwikipedia.png #\n │ scyahoo.png #\n │ scyandex.png #\n │ search.png #\n │ #\n ├─ico #\n │ favicon.ico #\n │ favicon.png #\n │ logo.png #\n │ #\n └─js #\n jquery.min.js #\n keyword.js #\n\t\t\t\t\t\t\t\t\t\t\t\t\t#\n\t\t\t\t\t\t\t\t\t\t\t\t\t#","dir":"/blog_temp/","name":"READMETREE.md","path":"blog_temp/READMETREE.md","url":"/blog_temp/READMETREE.html"},{"permalink":"/blog/life/travel/","layout":"default","title":"趣事小记","content":"# 趣事小记\n\nsource: `{{ page.path }}`\n","dir":"/blog/life/travel/","name":"README.md","path":"blog/life/travel/README.md","url":"/blog/life/travel/"},{"permalink":"/blog/frontier/new/life/","layout":"default","title":"生活","content":"# 生活\n\n{% include list.liquid all=true %}\n","dir":"/blog/frontier/new/life/","name":"README.md","path":"blog/frontier/new/life/README.md","url":"/blog/frontier/new/life/"},{"sort":1,"permalink":"/blog/religion/taoism/","layout":"default","title":"道教","content":"<h1 id=\"道教\">道教</h1>\n\n<p>source: <code class=\"language-plaintext highlighter-rouge\">blog/religion/taoism/README.md</code></p>\n","dir":"/blog/religion/taoism/","name":"README.md","path":"blog/religion/taoism/README.md","url":"/blog/religion/taoism/"},{"sort":1,"permalink":"/blog/ancientBooks/shiJing/","layout":"default","title":"诗经","content":"<h1 id=\"诗经\">诗经</h1>\n\n<p>source: <code class=\"language-plaintext highlighter-rouge\">blog/ancientBooks/shiJing/README.md</code></p>\n","dir":"/blog/ancientBooks/shiJing/","name":"README.md","path":"blog/ancientBooks/shiJing/README.md","url":"/blog/ancientBooks/shiJing/"},{"sort":1,"layout":"default","title":"html页面如何设置适配移动端","content":"<h1 id=\"html页面如何设置适配移动端\">html页面如何设置适配移动端</h1>\n\n<p>html页面适配移动端有哪些主流方式？最近做了一个静态网站，需要做一个简单的移动端适配，因为本人主要所后端，因此对前端方面知识比较欠缺。因此记录下开发过程，防止遗忘，也便于大家参考！以下是几种适配移动端的主流方式：</p>\n\n<h2 id=\"一-使用响应式布局适配移动端\">一. 使用响应式布局适配移动端</h2>\n<p>通过CSS媒体查询，根据不同屏幕尺寸设置不同的样式，使页面在不同的设备上呈现出最佳的视觉效果。</p>\n<h3 id=\"1-优缺点\">1. 优缺点：</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>优点：\n通过针对不同屏幕尺寸的样式设置，可以在各种设备上呈现出最佳的视觉效果。\n不需要对页面进行复杂的重构，只需要在CSS中添加媒体查询即可。\n缺点：\n需要编写大量的CSS代码，包括各种媒体查询和样式设置。\n在样式设置不合理的情况下，可能会导致页面在某些设备上呈现效果不佳。\n</code></pre>  </div></div>\n\n<h3 id=\"2-示例代码\">2. 示例代码：</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n\t&lt;title&gt;响应式布局示例&lt;/title&gt;\n\t&lt;meta charset=\"UTF-8\"&gt;\n\t&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n\t&lt;style&gt;\n\t\t/* 默认样式 */\n\t\th1 {\n\t\t\tfont-size: 28px;\n\t\t\tcolor: #333;\n\t\t\ttext-align: center;\n\t\t}\n\t\tp {\n\t\t\tfont-size: 16px;\n\t\t\tcolor: #666;\n\t\t\ttext-align: justify;\n\t\t\tmargin: 0 auto;\n\t\t\tmax-width: 1280px;\n\t\t}\n\t\t\n\t\t/* 媒体查询样式 */\n\t\t@media screen and (max-width: 1280px) {\n\t\t\th1 {\n\t\t\t\tfont-size: 24px;\n\t\t\t}\n\t\t\tp {\n\t\t\t\tfont-size: 14px;\n\t\t\t}\n\t\t}\n\t\t@media screen and (max-width: 560px) {\n\t\t\th1 {\n\t\t\t\tfont-size: 20px;\n\t\t\t}\n\t\t\tp {\n\t\t\t\tfont-size: 12px;\n\t\t\t}\n\t\t}\n\t&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\t&lt;header&gt;\n\t\t&lt;h1&gt;响应式布局示例&lt;/h1&gt;\n\t&lt;/header&gt;\n\t&lt;main&gt;\n\t\t&lt;p&gt;通过CSS媒体查询，根据不同屏幕尺寸设置不同的样式，使页面在不同的设备上呈现出最佳的视觉效果。&lt;/p&gt;\n\t&lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>  </div></div>\n<p>示例中，”&lt;meta&gt;” 标签中的 “viewport” 属性用于设置页面的视口大小，以便在不同的设备上以不同的比例显示页面。CSS 样式中，”max-width” 属性用于限制元素的最大宽度，以确保在较大屏幕上元素不会超出屏幕宽度。媒体查询的 “screen” 选择器用于指定应用于屏幕设备的样式。</p>\n\n<p>示例中，定义了两个媒体查询：一种在屏幕宽度小于或等于 1280px 时应用，另一种在屏幕宽度小于或等于 560px 时应用。这些媒体查询分别针对不同的屏幕尺寸设置标题和段落的字体大小。这样，在较小的屏幕上，文本将缩小，以适应屏幕大小，从而提供更好的展示效果。</p>\n\n<h2 id=\"二-使用视口viewport适配移动端\">二. 使用视口（Viewport）适配移动端</h2>\n<p>在HTML头部添加”meta”标签，设置视口的宽度、缩放比例等属性，让页面在移动设备上呈现出最佳的效果。</p>\n\n<h3 id=\"1-优缺点-1\">1. 优缺点：</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>优点：\n可以在移动设备上呈现出最佳的效果，避免了在移动设备上出现缩放或者溢出的问题。\n通过设置缩放比例，可以控制页面的大小，防止页面在移动设备上过大或过小。\n缺点：\n需要手动设置\"meta\"标签，对于大型的网站或者应用程序，需要进行大量的工作量。\n不同的设备可能需要不同的视口设置，需要针对每个设备进行适配。\n</code></pre>  </div></div>\n\n<h3 id=\"2-示例\">2. 示例:</h3>\n<p>以下是使用视口（Viewport）进行代码示例的例子：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Viewport Example&lt;/title&gt;\n    &lt;style&gt;\n      /* 设置不同屏幕尺寸下的样式 */\n      @media (max-width: 767px) {\n        body {\n          font-size: 16px;\n        }\n      }\n\n      @media (min-width: 768px) and (max-width: 991px) {\n        body {\n          font-size: 18px;\n        }\n      }\n\n      @media (min-width: 992px) {\n        body {\n          font-size: 20px;\n        }\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Viewport Example&lt;/h1&gt;\n    &lt;p&gt;This is an example of using viewport to make a responsive webpage.&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>  </div></div>\n<p>在该示例中，HTML头部中添加了一个”meta”标签，用于设置视口的宽度和缩放比例等属性。然后，使用CSS媒体查询根据不同屏幕尺寸设置不同的样式，使页面在不同的设备上呈现出最佳的视觉效果。通过这种方式，我们可以在移动设备上创建具有响应式布局的网页。</p>\n\n<h2 id=\"三-使用rem单位适配移动端\">三. 使用rem单位适配移动端</h2>\n<p>rem是相对于根元素的字体大小来计算的单位，可以根据屏幕大小动态调整字体大小和其他元素的尺寸，从而适配不同的屏幕尺寸。</p>\n\n<p>可以在CSS样式表中使用rem单位来设置字体大小和其他元素的尺寸。通常情况下，会将根元素的字体大小设置为基准值，然后使用rem单位来设置其他元素的尺寸。</p>\n<h3 id=\"1-优缺点-2\">1. 优缺点：</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>优点：\n可以根据屏幕大小动态调整字体大小和其他元素的尺寸，从而适配不同的屏幕尺寸。\n可以使页面元素在不同设备上呈现出类似的比例和样式。\n缺点：\n适用范围受限，主要用于字体和元素大小的调整，无法实现复杂布局。\n代码编写需要一定的技巧和经验。 ### 2. 例如：\n</code></pre>  </div></div>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/* 设置根元素的字体大小为16px */\nhtml {\n  font-size: 16px;\n}\n\n/* 使用rem单位来设置字体大小和其他元素的尺寸 */\nh1 {\n  font-size: 2rem; /* 相当于32px */\n  margin-bottom: 1.5rem; /* 相当于24px */\n}\n\np {\n  font-size: 1.125rem; /* 相当于18px */\n  line-height: 1.5rem; /* 相当于24px */\n}\n\n@media screen and (max-width: 768px) {\n  /* 在小屏幕上调整根元素的字体大小 */\n  html {\n    font-size: 14px;\n  }\n\n  /* 使用rem单位来设置字体大小和其他元素的尺寸 */\n  h1 {\n    font-size: 1.75rem; /* 相当于24.5px */\n    margin-bottom: 1rem; /* 相当于14px */\n  }\n\n  p {\n    font-size: 1rem; /* 相当于14px */\n    line-height: 1.5rem; /* 相当于21px */\n  }\n}\n\n</code></pre>  </div></div>\n<p>在这个示例中，首先将根元素的字体大小设置为16px，然后使用rem单位来设置标题、段落等元素的字体大小和间距。在”@media”查询中，根据屏幕宽度的不同，动态调整根元素的字体大小，从而适配不同的屏幕尺寸。</p>\n\n<h2 id=\"四-使用flexbox布局适配移动端\">四. 使用Flexbox布局适配移动端</h2>\n<p>使用Flexbox可以轻松实现自适应布局，使页面元素根据设备屏幕大小自动调整位置和大小。</p>\n\n<h3 id=\"1-优缺点-3\">1. 优缺点：</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>优点：\n可以轻松实现自适应布局，使页面元素根据设备屏幕大小自动调整位置和大小。\n可以很好地适应不同的屏幕尺寸，且对于复杂布局也有很好的支持。\n缺点：\n兼容性问题，旧版浏览器可能无法支持Flexbox布局。\n对于不熟悉Flexbox的开发人员，可能需要学习一些新的CSS属性和概念。 ### 2.示例：\n</code></pre>  </div></div>\n\n<p>以下是一个使用Flexbox布局的代码示例，其中通过 “display: flex” 将 “&lt;div&gt;” 元素设置为Flex容器，使用 “flex-direction” 指定Flex容器中元素的排列方向，使用 “flex-wrap” 指定Flex容器中元素是否换行，使用 “justify-content” 和 “align-items” 分别指定Flex容器中元素在主轴和侧轴上的对齐方式。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;Flexbox Layout Example&lt;/title&gt;\n  &lt;style&gt;\n    /* 将div设置为Flex容器 */\n    div {\n      display: flex;\n      flex-direction: row; /* 水平排列 */\n      flex-wrap: wrap; /* 换行 */\n      justify-content: space-around; /* 主轴居中对齐 */\n      align-items: center; /* 侧轴居中对齐 */\n    }\n    \n    /* Flex容器中的元素 */\n    div &gt; div {\n      width: 200px;\n      height: 200px;\n      background-color: #ccc;\n      margin: 10px;\n    }\n    \n    /* 在移动设备上将元素宽度调整为100% */\n    @media screen and (max-width: 480px) {\n      div &gt; div {\n        width: 100%;\n      }\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;div&gt;元素1&lt;/div&gt;\n    &lt;div&gt;元素2&lt;/div&gt;\n    &lt;div&gt;元素3&lt;/div&gt;\n    &lt;div&gt;元素4&lt;/div&gt;\n    &lt;div&gt;元素5&lt;/div&gt;\n    &lt;div&gt;元素6&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>  </div></div>\n<h2 id=\"五-使用flexbox布局适配移动端\">五. 使用Flexbox布局适配移动端</h2>\n<p>CSS Grid是一种强大的布局方式，可以更加灵活地控制页面元素的位置和大小，也能够适应不同的屏幕尺寸。</p>\n<h3 id=\"1-优缺点-4\">1. 优缺点：</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>优点：\n可以更加灵活地控制页面元素的位置和大小，也能够适应不同的屏幕尺寸。\n对于复杂布局的支持更加全面，可以实现更加自由的布局。\n缺点：\n兼容性问题，旧版浏览器可能无法支持CSS Grid布局。\n对于不熟悉CSS Grid的开发人员，可能需要学习一些新的CSS属性和概念。 ### 2. 示例： 以下是一个使用CSS Grid布局的代码示例：\n</code></pre>  </div></div>\n\n<p>HTML部分：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;div class=\"grid-container\"&gt;\n  &lt;div class=\"grid-item\"&gt;1&lt;/div&gt;\n  &lt;div class=\"grid-item\"&gt;2&lt;/div&gt;\n  &lt;div class=\"grid-item\"&gt;3&lt;/div&gt;\n  &lt;div class=\"grid-item\"&gt;4&lt;/div&gt;\n  &lt;div class=\"grid-item\"&gt;5&lt;/div&gt;\n  &lt;div class=\"grid-item\"&gt;6&lt;/div&gt;\n&lt;/div&gt;\n\n</code></pre>  </div></div>\n<p>CSS部分：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>.grid-container {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  grid-gap: 20px;\n}\n.grid-item {\n  background-color: #f1f1f1;\n  padding: 20px;\n  text-align: center;\n}\n\n</code></pre>  </div></div>\n<p>这个例子中，创建了一个包含6个元素的网格容器，使用了 “display: grid” 来开启网格布局，并通过 “grid-template-columns” 属性来设置列的数量和大小。</p>\n\n<p>在这里，使用了 “repeat(auto-fit, minmax(200px, 1fr))” 来创建自适应的列，这意味着每列的最小宽度为200像素，最大宽度为1份剩余空间，使得网格可以在不同屏幕尺寸下自适应地调整。 “grid-gap” 属性用于设置行列之间的间距。最后，我们为每个网格项设置了一些基本样式，包括背景色和内边距。</p>\n\n<p>以上是不同移动端适配方式的优缺点，各位可以根据具体业务需求，进行方式选择！<strong>推荐使用视口（Viewport）适配移动端</strong></p>\n","dir":"/blog/development/html/jottings/","name":"2023-04-21_1.md","path":"blog/development/html/jottings/2023-04-21_1.md","url":"/blog/development/html/jottings/2023-04-21_1.html"},{"sort":1,"permalink":"/blog/frontier/recommend/","layout":"default","title":"推荐","content":"<h1 id=\"推荐\">推荐</h1>\n\n<ul>\n <li><a href=\"/blog/frontier/recommend/2023-04-23_1.html\">Just My Socks 介绍，Just My Socks 是什么？</a></li>\n <li><a href=\"/blog/frontier/recommend/2023-04-27_1.html\">推荐几款好用的自用软件</a></li>\n</ul>\n","dir":"/blog/frontier/recommend/","name":"README.md","path":"blog/frontier/recommend/README.md","url":"/blog/frontier/recommend/"},{"sort":1,"layout":"default","title":"Just My Socks 介绍，Just My Socks 是什么？","content":"<h1 id=\"just-my-socks-介绍just-my-socks-是什么\">Just My Socks 介绍，Just My Socks 是什么？</h1>\n\n<p><a href=\"https://justmysocks.net/members/aff.php?aff=5696\">Just My Socks</a>，也有人喜欢搜 JustMySocks 或 JMS，或者是中文翻译：就是我的袜子。Just My Socks 本身其实是搬瓦工官方的一个 $$ 服务（机场），提供的线路也是跟搬瓦工 VPS 一样，有 CN2 GIA、日本软银、联通 AS9929 等，支持支付宝、银联和 PayPal 付款，最低月付 5.88 美元。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230423155458min.png\" alt=\"JustMySocks\" /></p>\n\n<h2 id=\"just-my-socks-介绍\">Just My Socks 介绍</h2>\n<p>Just My Socks 官网：Just My Socks 官网</p>\n\n<p>Just My Socks 是由搬瓦工官方运营的一个机场服务，并且保证 IP 可用。目前，除了最开始的 LA 方案外，Just My Socks 这几年陆续增加了香港 CMI + NTT 方案、英国伦敦联通 AS9929 方案、日本 CN2 GIA 方案、香港 CN2 GIA 方案、香港 IPLC 方案等</p>\n\n<h2 id=\"just-my-socks-优点\">Just My Socks 优点</h2>\n\n<p>相比于市面上一些其他机场，Just My Socks 作为搬瓦工官方产品，更加靠谱稳定。下面罗列几条 Just My Socks 优点：</p>\n\n<p>稳定靠谱：搬瓦工官网出品，不怕跑路。\n付款方便：支持支付宝、银联、PayPal。\n线路质量高：提供搬瓦工 CN2 GIA 线路，三网 CN2 GIA 直连，对移动、电信、联通均有优化，速度快，线路稳定。\n保证服务可用：Just My Socks 保证服务 IP 可用，不用担心 IP 被墙。\n带宽大：提供最高5Gbps带宽，不限速，不限制设备数量。</p>\n\n<h2 id=\"just-my-socks-可用地址\">Just My Socks 可用地址</h2>\n\n<p>Just My Socks官网更新历程：</p>\n\n<p>Just My Socks官网（国内无法直接访问）：<a href=\"https://justmysocks.net/members/aff.php?aff=5696\">https://justmysocks.net</a>\n2019年4月9日推出第一个官网镜像站（国内无法直接访问）：<a href=\"https://justmysocks1.net/members/aff.php?aff=5696\">https://justmysocks1.net</a>\n2020年1月8日推出第二个官网镜像站（国内无法直接访问）：<a href=\"https://justmysocks2.net/members/aff.php?aff=5696\">https://justmysocks2.net</a>\n2020年6月4日推出第三个官网镜像站：<a href=\"https://justmysocks3.net/members/aff.php?aff=5696\">https://justmysocks3.net</a></p>\n","dir":"/blog/frontier/recommend/","name":"2023-04-23_1.md","path":"blog/frontier/recommend/2023-04-23_1.md","url":"/blog/frontier/recommend/2023-04-23_1.html"},{"sort":1,"layout":"default","title":"关于Justmyfreedom网站","content":"<h1 id=\"关于justmyfreedom网站\">关于Justmyfreedom网站</h1>\n<blockquote>\n <p>大家好，我是<a href=\"https://justmyfreedom.com/\">终南有客</a>，一个热爱自由和创造，喜欢探索和发现新事物的软件开发者</p>\n\n</blockquote>\n\n<p>作为一名软件开发者，工作时间也挺久了，一直想要做一个网站，但总是因为各种原因止步，很是遗憾！</p>\n\n<p>最近在工作之余，突然又蹦出来这个念头，于是趁热打铁，防止自己又出什么幺蛾子，赶紧申请了域名：Justmyfreedom.com，顺带着查看几个感兴趣的博客布局，最终形成了Justmyfreedom网站的布局。</p>\n\n<h2 id=\"一-域名\">一. 域名</h2>\n\n<h3 id=\"1-justmyfreedom的含义\">1. Justmyfreedom的含义</h3>\n<p>在申请域名的时候想了好多域名，最终挑选了这个域名，寓意也很简单：这个网站仅仅表示个人的自由和独立，每个人应该享有自己的自由和权利。</p>\n\n<h2 id=\"二-首页布局\">二. 首页布局</h2>\n<p>首页是一个导航网站布局，Justmyfreedom导航，工作时会切换好多个搜索网站去搜索信息，并且有很多常用的网址，因此做成了这个简约风格的导航网页，使用起来会方便很多。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230423140835min.png\" alt=\"Justmyfreedom导航\" /></p>\n\n<h2 id=\"三-blog\">三. blog</h2>\n<p>blog中主要是关于平常工作、生活等方面的记录，也有一些开发记录给大家做参考。</p>\n\n<p>当然，可能有人会说不是有很多免费的网站也能记录吗？为什么不用？</p>\n\n<p>那些博客也在用，但是总感觉各种的不方便</p>\n\n<p>哈哈哈……</p>\n\n<p>真正的原因其实：Just my freedom</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230423142633min.png\" alt=\"Justmyfreedom导航博客\" /></p>\n\n<h2 id=\"四-终南有客公众号\">四. 终南有客公众号</h2>\n<p>终南有客公众号，下面是我的公众号，想要了解更多信息的朋友可以关注下，\n<img src=\"https://image.justmyfreedom.com/static/assets/common/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png\" alt=\"终南有客公众号\" /></p>\n","dir":"/blog/about/website/","name":"2023-04-23_1.md","path":"blog/about/website/2023-04-23_1.md","url":"/blog/about/website/2023-04-23_1.html"},{"sort":1,"layout":"default","title":"ChatGpt","content":"<h1 id=\"chatgpt\">ChatGpt</h1>\n\n<h2 id=\"一chatgpt是什么\">一.ChatGpt是什么</h2>\n<p>ChatGPT全称为“chat Generative Pre-trained Transformer”，翻译成中文就是生成型预训练变换模型。它是美国公司OpenAI在2022年11月30日发布研发的聊天机器人程序，能用于问答、文本摘要生成、机器翻译、分类、代码生成和对话AI。[1]是一款人工智能技术驱动的自然语言处理工具。</p>\n\n<p>ChatGPT是一种基于自然语言处理技术和深度学习算法的人工智能语言模型，由OpenAI开发。它可以理解和生成自然语言，包括文字和语音，能够进行对话、问答、摘要生成、文章创作等任务。ChatGPT的基本原理是利用深度学习算法对大规模文本数据进行训练，通过学习文本数据的模式和结构，构建出一种语言模型，可以模仿人类语言的表达和理解方式，从而实现自然语言处理的功能。ChatGPT是目前最先进的自然语言处理技术之一，具有广泛的应用前景，包括智能客服、聊天机器人、虚拟助手等。</p>\n\n<h2 id=\"1科学上网注册与使用-chatgpt\">1.科学上网注册与使用 ChatGPT</h2>\n\n<p>手把手教你如何在国内科学注册chatGPT\n，流程比较简单，主要分以下3步：</p>\n\n<ul>\n <li>科学上网</li>\n <li>注册ChatGPT</li>\n <li>手机号接收验证码</li>\n</ul>\n\n<h3 id=\"2科学上网\">2.科学上网</h3>\n\n<p>如果你已经可以科学上网了，则可以跳过这1步。</p>\n\n<p>科学上网不仅是可以用来使用chatGPT，也可以看ins、油管、face、电报、推特等，所以常备一个科学上网的账号是非常必要的。这里推荐JustMysocks服务，我个人已经使用了5年了，比较稳定，价格合理。注册方式可参考<a href=\"https://justmyfreedom.com/blog/frontier/recommend/2023-04-23_1.html\">Just My Socks 介绍，Just My Socks 是什么？\n</a></p>\n\n<h3 id=\"3注册chatgpt\">3.注册ChatGPT</h3>\n\n<p>首先打开科学上网，访问 chatGPT 官网注册 <a href=\"https://chat.openai.com/auth/login\">https://chat.openai.com/auth/login</a> 填写邮箱，验证邮箱，到手机号输入界面，这里需要一个海外手机号，如果没有请看第3步</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230512160844min.png\" alt=\"注册ChatGPT\" /></p>\n\n<h3 id=\"4接码平台\">4.接码平台</h3>\n<p>手机号接收验证码 <a href=\"https://sms-activate.org/?ref=5329402\">sms-activate</a></p>\n\n<ol>\n <li>给接码平台充值，在右上角，可以使用支付宝或银联卡充值</li>\n <li>在左边选择 openai 再选择一个国家，建议选择印度尼西亚，比较便宜，不过印度更稳定</li>\n <li>回到首页获取号码，回到ChatGPT里填写，等待接收验证码，然后填写到 ChatGPT 注册界面，完成注册</li>\n</ol>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/1232333333333333333min.png\" alt=\"sms-activate接码平台\" /></p>\n\n<h3 id=\"5使用chatgpt\">5.使用ChatGPT</h3>\n\n<p>注册完成后，重新登录，可以使用 ChatGPT 了\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230512161708min.png\" alt=\"使用ChatGPT\" /></p>\n","dir":"/blog/frontier/new/technology/","name":"2023-04-23_1.md","path":"blog/frontier/new/technology/2023-04-23_1.md","url":"/blog/frontier/new/technology/2023-04-23_1.html"},{"sort":1,"permalink":"/blog/development/html/jottings/","layout":"default","title":"随笔","content":"<h1 id=\"随笔\">随笔</h1>\n\n<ul>\n <li><a href=\"/blog/development/html/jottings/2023-04-21_1.html\">html页面如何设置适配移动端</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-04-27_1.html\">HTML页面中返回顶部的几种实现</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_1.html\">html表格导出excel有几种方式</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_2.html\">laydate渲染日期</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-17_1.html\">Html中CSS和JavaScript 文件添加版本号有哪些方式</a></li>\n</ul>\n","dir":"/blog/development/html/jottings/","name":"README.md","path":"blog/development/html/jottings/README.md","url":"/blog/development/html/jottings/"},{"sort":1,"layout":"default","title":"NGINX强制使用https访问(http跳转到https)","content":"<h1 id=\"nginx强制使用https访问http跳转到https\">NGINX强制使用https访问(http跳转到https)</h1>\n\n<p>新站SEO的朋友注意了,经本人测试,使用404强制跳转会导致页面无收录,因为爬虫不会跳转,比如访问地址<a href=\"https://justmyfreedom.com/\">https://justmyfreedom.com/</a>会直接报404,而不会去管后面跳转的地址,直接显示无页面.</p>\n\n<h2 id=\"一需求简介\">一.需求简介</h2>\n<p>  基于nginx搭建了一个https访问的虚拟主机，监听的域名是<a href=\"https://justmyfreedom.com/\">justmyfreedom.com</a>，但是很多用户不清楚https和http的区别，会很容易敲成<a href=\"https://justmyfreedom.com\">https://justmyfreedom.com</a>这时会报出404错误，所以我需要做<strong>基于justmyfreedom.com域名的http向https的强制跳转</strong></p>\n\n<h2 id=\"二http跳转到https配置方式\">二.http跳转到https配置方式</h2>\n<p>进过网上查询,总结了一下三种方式,可以根据需求进行设置.</p>\n\n<h3 id=\"1-nginx的rewrite方法\">1. nginx的rewrite方法</h3>\n<p>这应该是大家最容易想到的方法.</p>\n\n<p>第一步：打开NGINX的配置文件（通常是位于/etc/nginx/nginx.conf或/etc/nginx/conf.d/default.conf）。</p>\n\n<p>第二步：在HTTP server块中，找到对应的server段落。在该段落中，添加以下代码以将所有HTTP请求重定向到HTTPS：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 80;\n    server_name example.com;  // 替换为你的域名\n\n    # HTTP重定向到HTTPS\n    rewrite ^(.*)$ https://$host$1 permanent;\n}\n\n</code></pre>  </div></div>\n<p>这将使用rewrite指令将所有HTTP请求重定向到相应的HTTPS URL。</p>\n\n<p>第三步：在同一个配置文件中，找到HTTPS server块，该块用于处理HTTPS请求。确保以下配置选项正确设置：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 443 ssl;\n    server_name example.com;  // 替换为你的域名\n\n    # 其他SSL/TLS配置项\n    ssl_certificate /path/to/ssl_certificate.crt;  // 替换为你的SSL证书路径\n    ssl_certificate_key /path/to/private_key.key;  // 替换为你的私钥路径\n\n    # 其他配置项\n}\n\n</code></pre>  </div></div>\n<p>确保在listen指令中使用了ssl关键字，以便监听HTTPS流量。</p>\n\n<p>第四步：保存并关闭配置文件。重新加载NGINX配置，以使更改生效。可以通过运行以下命令来实现：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo service nginx reload\n\n</code></pre>  </div></div>\n<p>大功告成！</p>\n\n<h3 id=\"2-nginx的497状态码\">2. nginx的497状态码</h3>\n<p>error code 497</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>497 - normal request was sent to HTTPS\n</code></pre>  </div></div>\n<p>解释：当此虚拟站点只允许https访问时，当用http访问时nginx会报出497错误码,利用error_page命令将497状态码的链接重定向到<a href=\"https://justmyfreedom.com/\">https://justmyfreedom.com/</a>这个域名上</p>\n\n<p>可以按照以下步骤进行配置：</p>\n\n<p>第一步：打开NGINX的配置文件（通常是位于/etc/nginx/nginx.conf或/etc/nginx/conf.d/default.conf）。</p>\n\n<p>第二步：在HTTP server块中，找到对应的server段落。在该段落中，添加以下代码以将所有HTTP请求重定向到HTTPS，并返回497状态码：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 80;\n    server_name example.com;  // 替换为你的域名\n\n    # HTTP重定向到HTTPS，并返回497状态码\n    return 497;\n}\n\n</code></pre>  </div></div>\n<p>这将使用return指令将所有HTTP请求重定向到相应的HTTPS URL，并返回497状态码表示重定向。</p>\n\n<p>第三步：在同一个配置文件中，找到HTTPS server块，该块用于处理HTTPS请求。确保以下配置选项正确设置：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 443 ssl;\n    server_name example.com;  // 替换为你的域名\n\n    # 其他SSL/TLS配置项\n    ssl_certificate /path/to/ssl_certificate.crt;  // 替换为你的SSL证书路径\n    ssl_certificate_key /path/to/private_key.key;  // 替换为你的私钥路径\n\n    # 其他配置项\n}\n</code></pre>  </div></div>\n<p>确保在listen指令中使用了ssl关键字，以便监听HTTPS流量。</p>\n\n<p>第四步：保存并关闭配置文件。重新加载NGINX配置，以使更改生效。可以通过运行以下命令来实现：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo service nginx reload\n</code></pre>  </div></div>\n<p>大功告成！</p>\n\n<h3 id=\"3-indexhtml刷新网页\">3. index.html刷新网页</h3>\n<p>上述两种方法均会耗费服务器的资源，我们可以查看其他网站是如何实现http跳转到https的跳转.测试在浏览器中输入将baidu.com,发现很巧妙的利用meta的刷新作用，将baidu.com跳转到<a href=\"www.baidu.com\">www.baidu.com</a>因此我们可以基于<a href=\"https://justmyfreedom.com/\">http://justmyfreedom.com</a>的虚拟主机路径下也写一个index.html，内容就是http向https的跳转</p>\n\n<p>可以参照以下步骤设置：</p>\n\n<p>第一步：都是打开NGINX的配置文件（通常是位于/etc/nginx/nginx.conf或/etc/nginx/conf.d/default.conf）。</p>\n\n<p>第二步：在HTTP server块中，找到对应的server段落。在该段落中，添加以下代码以将所有HTTP请求重定向到HTTPS：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 80;\n    server_name example.com;  // 替换为你的域名\n\n    # HTTP重定向到HTTPS\n    return 301 https://$host$request_uri;\n}\n</code></pre>  </div></div>\n<p>这将使用return指令将所有HTTP请求重定向到相应的HTTPS URL。</p>\n\n<p>第三步：在同一个配置文件中，找到HTTPS server块，该块用于处理HTTPS请求。确保以下配置选项正确设置：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 443 ssl;\n    server_name example.com;  // 替换为你的域名\n\n    # 其他SSL/TLS配置项\n    ssl_certificate /path/to/ssl_certificate.crt;  // 替换为你的SSL证书路径\n    ssl_certificate_key /path/to/private_key.key;  // 替换为你的私钥路径\n\n    # 其他配置项\n\n    location / {\n        try_files $uri $uri/ /index.html;\n    }\n}\n</code></pre>  </div></div>\n<p>在HTTPS server块的location /段落中，使用try_files指令将请求重定向到index.html文件。这将确保在刷新页面时保持HTTPS连接。</p>\n\n<p>第四步：保存并关闭配置文件。重新加载NGINX配置，以使更改生效。可以通过运行以下命令来实现：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo service nginx reload\n</code></pre>  </div></div>\n<h3 id=\"4-使用-if-指令\">4. 使用 if 指令</h3>\n\n<p>和以上方式相同，打开配置文件，修改：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 80;\n    server_name example.com;  // 替换为你的域名\n\t\n    if ($http_x_forwarded_proto != \"https\") {\n        return 301 https://$host$request_uri;\n    }\n\n    # 其他配置项\n}\n\n</code></pre>  </div></div>\n<p>在上面配置中，使用了 $http_x_forwarded_proto 变量来判断请求是否通过 HTTP 而不是 HTTPS。如果条件成立，即请求不是通过 HTTPS 访问的，则将其重定向到相应的 HTTPS URL。</p>\n\n<p>请注意，<strong>使用 if 指令需要谨慎</strong>，因为它可能会引入一些不可预测的行为，并且在高负载环境下可能会影响性能。建议使用其他方式（如重定向或 rewrite）来实现强制使用 HTTPS 访问，以获得更可靠和高效的结果。</p>\n\n<p>在配置完成后，保存并重新加载 NGINX 配置。</p>\n\n<p><strong>注意:</strong>\n以上步骤做好之后，当用户访问的网站时，NGINX将使用rewrite指令将HTTP请求重定向到相应的HTTPS URL。确保将”example.com”替换为自己的域名，并将SSL证书和私钥的路径设置为正确的值。</p>\n\n<p>上述几种方法均可以实现基于nginx强制将http请求跳转到https请求，大家可以评价一下优劣或者根据实际需求进行选择。参考时一定要结合自己的实际情况，我很多配置基于项目安全考虑做了删减.</p>\n\n","dir":"/blog/development/html/seo/","name":"2023-04-27_1.md","path":"blog/development/html/seo/2023-04-27_1.md","url":"/blog/development/html/seo/2023-04-27_1.html"},{"sort":1,"permalink":"/blog/ancientBooks/tangShi/","layout":"default","title":"唐诗","content":"<h1 id=\"唐诗\">唐诗</h1>\n\n<p>source: <code class=\"language-plaintext highlighter-rouge\">blog/ancientBooks/tangShi/README.md</code></p>\n","dir":"/blog/ancientBooks/tangShi/","name":"README.md","path":"blog/ancientBooks/tangShi/README.md","url":"/blog/ancientBooks/tangShi/"},{"sort":1,"layout":"default","title":"2023年计划考试时间(全年)","content":"<h1 id=\"2023年计划考试时间全年\">2023年计划考试时间(全年)</h1>\n\n<p>以下是根据网上信息整理的2023年考试日期安排，部分考试时间可能后续有变动，请及时关注！</p>\n<h2 id=\"2023年1月-\">2023年1月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1月7日-8日      2023年国家公务员考试\n1月7日-8日      自学考试\n1月7日-8日      教师资格考试\n1月1日-1月31日  全国消防操作员\n1月开始  \t\t 人力资源管理师（各地自定）\n</code></pre>  </div></div>\n\n<h2 id=\"2023年2月-\">2023年2月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>2月25日         公务员省考\n2月25-26日      基金从业（专场第1次）\n</code></pre>  </div></div>\n\n<h2 id=\"2023年3月-\">2023年3月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>3月11日         教师资格考试\n3月18日-19日    2022税务师（补考）\n3月18日-19日    公共英语\n3月25日-26日    2022执业药师（补考）\n3月25日-26日    2022一级消防（补考）\n3月25日-26日    2022一级建造师（补考）\n3月25日-27日    计算机等级考试\n3月-6月         专升本考试\n</code></pre>  </div></div>\n\n<h2 id=\"2023年4月-\">2023年4月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>4月8日-9日      2022经济师（补考）\n4月8日-9日      咨询工程师（投资）\n4月8日-9日      执业护士\n4月15日-16日    初级护师\n4月15日-16 日   卫生资格\n4月15日-16日    主管护师\n4月15日-16日    自学考试\n4月22日         专八考试\n4月22日-23日    2022一级造价（补考）\n4月22日-23日    卫生资格\n</code></pre>  </div></div>\n\n<h2 id=\"2023年5月-\">2023年5月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>5月13日         BEC初级\n5月13日-14日    监理工程师\n5月13日-14日    教师资格考试\n5月13日         会计（高级）\n5月13日-17日    会计（初级）\n5月20日         全国期货从业\n5月20日         演出经纪人员资格\n5月20日         BEC高级\n5月20日-21日    基金从业（统考第1次）\n5月27日         BEC中级\n5月27日-28日    计算机等级考试\n5月27日-28日    环境影响评价工程师\n5月27日-28日    房地产经纪人\n5月27日-28日    软件水平考试\n</code></pre>  </div></div>\n\n<h2 id=\"2023年6月-\">2023年6月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>6月3-4日        银行专业资格考试\n6月3-4日        证券从业资格考试\n6月3日起        执业医师考试\n6月7日-10日     高考\n6月10日         英语四级考试\n6月10日         英语六级考试\n6月10日-11日    注册计量师（一、二级）\n6月10日-11日    机动车检测维修工程师\n6月10日-11日    二级建造师\n6月10日-11日    社会工作者考试\n6月中下旬    \t考（各地不同）\n6月17日-18日    注册核安全工程师\n6月17日-18日    不动产登记代理人\n6月17日-18日    公路水运工程试验检测师\n6月17日-18日    2022勘察设计注册工程师（补考）\n6月18日         专四考试\n6月18日         高级经济师考试\n</code></pre>  </div></div>\n\n<h2 id=\"2023年7月-\">2023年7月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>7月1日-2日      自学考试\n7月1日-2日      专利代理师\n7月8日-9日      拍卖师（纸笔作答）\n7月16日         执业兽医\n7月29日-30日    基金从业（专场第2次）\n</code></pre>  </div></div>\n\n<h2 id=\"2023年8月-\">2023年8月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>8月18日-20日    执业医师考试（第一次笔试）\n8月25日-27日    注册会计师\n8月26日-27日    拍卖师（实际操作）\n</code></pre>  </div></div>\n\n<h2 id=\"2023年9月-\">2023年9月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>9月2日-3日      矿业权评估师\n9月9日-10日     一级建造师\n9月9日-11日     中级会计职称考试\n9月16日         教师资格考试\n9月16日         全国期货从业\n9月16日-17日    法律职业资格考试\n9月16日-17日    公共英语\n9月16日-17日    注册城乡规划师\n9月23日-24日    注册测绘师\n9月23日-24日    设备监理师\n9月23日-24日    资产评估师\n9月23日-24日    注册验船师\n9月23日-24日    文物保护工程从业资格\n9月23日-24日    广播电视播音员、主持人资格\n9月23日-25日    计算机等级考试\n9月24日         审计\n</code></pre>  </div></div>\n\n<h2 id=\"2023年10月-\">2023年10月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>10月14日        出版专业资格\n10月14日        通信\n10月14日-15日   注册建筑师（一、二级）\n10月15日        法律职业资格考试\n10月21日-22日   注册建筑师（一级）\n10月21日-22日   成人高考\n10月21日-22日   执业药师考试\n10月21日-25日   精算师\n10月28日-29日   银行专业资格考试\n10月28日-29日   房地产经纪人\n10月28日-29日   自学考试\n10月28日-29日   中级注册安全工程师\n10月28日-29日   一级造价工程师\n10月29日        统计\n</code></pre>  </div></div>\n\n<h2 id=\"2023年11月-\">2023年11月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>11月4日         新闻记者职业资格\n11月4日-5日     勘察设计注册工程师\n11月4日-5日     基金从业（专场第3次）\n11月4日-5日     一级消防工程师\n11月4日-5日     计算机技术与软件\n11月4日-5日     一、二、三级翻译资格\n11月11-12日     初级经济师\n11月11-12日     中级经济师\n11月11-12日     执业医师考试（第二次笔试）\n11月11-12日     房地产估价师\n11月18日        BEC高级\n11月18日-19日   税务师\n11月18日        全国期货从业\n11月25日        BEC初级\n11月25日        导游资格\n11月26日        2024国家公务员\n</code></pre>  </div></div>\n\n<h2 id=\"2023年12月-\">2023年12月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>12月2日-3日     计算机等级考试\n12月2日         BEC中级\n12月9日         英语四级考试\n12月9日         英语六级考试\n12月9日-10日    教师资格考试（面试）\n12月23日-25日   研究生考试\n</code></pre>  </div></div>\n","dir":"/blog/frontier/new/life/","name":"2023-04-23_1.md","path":"blog/frontier/new/life/2023-04-23_1.md","url":"/blog/frontier/new/life/2023-04-23_1.html"},{"sort":1,"permalink":"/blog/frontier/","layout":"default","title":"前沿","content":"<h1 id=\"前沿\">前沿</h1>\n<p>这个板块分享前沿科技和新闻信息，旨在帮助大家了解最新的科技趋势和行业发展动态，提供有用、实用的技术和行业资讯，以帮助大家更好地应对日益变化的社会和经济环境。</p>\n\n<p>我们的网站以分享为核心，每天为大家提供最新的科技新闻和资讯，内容涵盖了人工智能、机器学习、区块链、云计算、物联网等众多领域，涵盖了全球最新的科技发展趋势和前沿技术。我们不仅分享科技新闻，还会推出各种科技教程和指南，帮助大家更好地了解和应用科技，促进科技的发展和创新。</p>\n\n<p>我们的网站采用了简洁、易用的设计风格，让大家轻松找到需要的信息。</p>\n\n<p>这里致力于分享前沿科技和信息，为大家提供有用、实用的技术和行业资讯，帮助大家更好地了解和应用科技，促进科技的发展和创新。</p>\n\n<!-- \n- [推荐](/blog/frontier/recommend/)\n - [Just My Socks 介绍，Just My Socks 是什么？](/blog/frontier/recommend/2023-04-23_1.html)\n - [推荐几款好用的自用软件](/blog/frontier/recommend/2023-04-27_1.html)\n- [新闻](/blog/frontier/new/)\n - [科技](/blog/frontier/new/technology/)\n - [ChatGpt](/blog/frontier/new/technology/2023-04-23_1.html)\n - [生活](/blog/frontier/new/life/)\n - [2023年计划考试时间(全年)](/blog/frontier/new/life/2023-04-23_1.html) -->\n","dir":"/blog/frontier/","name":"README.md","path":"blog/frontier/README.md","url":"/blog/frontier/"},{"sort":1,"layout":"default","title":"Jekyll安装配置和使用","content":"<h1 id=\"jekyll安装配置和使用\">Jekyll安装配置和使用</h1>\n\n<p>最近想试试用Jekyll在Github搭建blog。选取网站模板，修改域名等等这些网上都有很详细的教程了，文末会附上链接，这里就不再赘述了。本文主要记录在Windows本地安装jekyll环境的过程，遇到的问题及如何解决的。参考<a href=\"http://jekyllcn.com/docs/posts/\">Jekyll</a>官网</p>\n\n<h2 id=\"一-环境安装\">一. 环境安装</h2>\n\n<h3 id=\"1-安装ruby\">1. 安装Ruby</h3>\n<p>在Windows上使用RubyInstaller安装比较方便，去<a href=\"https://rubyinstaller.org/downloads/\">Ruby官网</a>下载最新版本的RubyInstaller。注意32位和64位版本的区分。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424134647min.png\" alt=\"微信截图_20230424134647min\" />\n在这里直接选择下载 Ruby+Devkit 3.1.4-1 (x64) 版本即可，就不用Ruby和Devkit分开安装了。</p>\n\n<blockquote>\n <p>注意：这里建议先选好Jekyll网站模板，在根据网站模板所需要的Ruby版本进行安装。否则在启动的时候可能会出现版本不兼容问题，处理起来比较麻烦。</p>\n</blockquote>\n\n<p>安装后选择安装msys2 -&gt;3，可能会安装失败,此处我没有管，也没有另行操作。</p>\n\n<h3 id=\"2-安装jekyll\">2. 安装Jekyll</h3>\n<p>安装这个比较费时，在cmd中输入:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>gem install jekyll\n</code></pre>  </div></div>\n<p>安装完后查看：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jekyll -v\n</code></pre>  </div></div>\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424134834min.png\" alt=\"微信截图_20230424134834min\" /></p>\n\n<h2 id=\"二-jekyll启动\">二. jekyll启动</h2>\n\n<h3 id=\"1-下载jekyll主题\">1. 下载Jekyll主题</h3>\n<p>可通过如下Jekyll主题商店自行选取喜欢的主题库：</p>\n\n<p>https://jamstackthemes.dev/ssg/jekyll/</p>\n\n<p>http://jekyllthemes.org/</p>\n\n<h4 id=\"下载jekyll主题根据喜好自行选择\">下载jekyll主题（根据喜好自行选择）</h4>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git clone https://github.com/rundocs/jekyll-rtd-theme.git\n</code></pre>  </div></div>\n\n<h3 id=\"2-启动\">2. 启动</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#进入下载好的目录\ncd jekyll-rtd-theme\n# 配置bundle国内镜像仓库\nbundle config mirror.https://rubygems.org https://gems.ruby-china.com\n# 安装依赖\nbundle install\n# 启动本地主题\njekyll serve 或 bundle exec jekyll serve 因为本身Jekyll是个代码生成器，修改MD并不是立刻映射到html文件上。可以用这条命令启动服务，这样文件被改变之后，会即刻刷新网页\n</code></pre>  </div></div>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>bundle exec jekyll serve --livereload\n</code></pre>  </div></div>\n<h3 id=\"3-访问地址\">3. 访问地址：</h3>\n<p>http://127.0.0.1:4000/</p>\n\n<h2 id=\"三-jekyll配置本地启动手机访问\">三. jekyll配置本地启动手机访问</h2>\n\n<h3 id=\"1-查询的本地-ip-地址\">1. 查询的本地 IP 地址。</h3>\n<p>如果你使用的是 macOS 或 Linux 操作系统，可以打开终端（Terminal）应用，并输入以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ifconfig\n</code></pre>  </div></div>\n\n<p>如果你使用的是 Windows 操作系统，可以打开命令提示符（Command Prompt）应用，并输入以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ifconfig 在终端或命令提示符中，你应该可以看到一个名为 \"inet\" 或 \"IPv4 Address\" 的 IP 地址。这就是你的本地 IP 地址。\n</code></pre>  </div></div>\n\n<h3 id=\"2-配置-jekyll-以使用本地-ip-地址\">2. 配置 Jekyll 以使用本地 IP 地址。</h3>\n\n<p>在终端或命令提示符中，进入你的 Jekyll 站点所在的目录，并运行以下命令：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jekyll serve --host=0.0.0.0\n或\nbundle exec jekyll serve --host=0.0.0.0\n</code></pre>  </div></div>\n<p>这个命令会让 Jekyll 使用 0.0.0.0 这个特殊的 IP 地址，表示允许任何设备访问该站点。</p>\n\n<h3 id=\"3-访问\">3. 访问</h3>\n<p>在手机浏览器中输入你的本地 IP 地址，加上 Jekyll 默认的端口号 4000。\n在手机浏览器中输入以下网址：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>http://你的本地IP地址:4000\n</code></pre>  </div></div>\n<p>例如，如果你的本地 IP 地址是 192.168.0.100，那么你应该输入以下网址：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>http://192.168.0.100:4000\n</code></pre>  </div></div>\n\n<p>现在你应该可以在手机上访问你的 Jekyll 站点了。</p>\n\n<h2 id=\"四-jekyll其他常见问题\">四. jekyll其他常见问题</h2>\n\n<h3 id=\"1-重新安装gem\">1. 重新安装gem</h3>\n<p>如果在启动过程中出现报错，大概率是版本问题，如果是版本问题，则按照以下方式处理，如果是其他问题，则查看具体问题进行处理</p>\n\n<p>查看版本</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>bundle exec jekyll --version\n</code></pre>  </div></div>\n\n<p>更新Gemfile.lock 文件里的依赖</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 重新安装一遍\ngem install bundler jekyll\n\n# 更新所有的 gems\nbundle update\n\n# 测试\njekyll --version\n</code></pre>  </div></div>\n\n<p>重新使用启动命令进行启动：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jekyll serve 或 bundle exec jekyll serve\n</code></pre>  </div></div>\n<p>如果仍未解决，可以查看主题模板所需要的版本，重新安装。</p>\n\n<h3 id=\"2-后台启动\">2. 后台启动</h3>\n<p>“jekyll serve”命令启动如果终端关闭，进程就停止了，如果想要在后台启动，则需要更换其他命令。</p>\n\n<h4 id=\"控制台启动命令\">控制台启动命令</h4>\n<p>Auto-regeneration（自动再生成文件）: 开启。使用 <code class=\"language-plaintext highlighter-rouge\">--no-watch</code> 来关闭。</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jekyll serve\nbundle exec jekyll serve\n</code></pre>  </div></div>\n<h4 id=\"后台启动命令\">后台启动命令</h4>\n<p>功能和<code class=\"language-plaintext highlighter-rouge\">jekyll serve</code>命令相同，但是会脱离终端在后台运行</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jekyll serve --detach\n</code></pre>  </div></div>\n\n<p>如果你想关闭服务器，可以使用<code class=\"language-plaintext highlighter-rouge\">kill -9 1234</code>命令，”1234” 是进程号（PID）。\n如果你找不到进程号，那么就用<code class=\"language-plaintext highlighter-rouge\">ps aux | grep jekyll</code>命令来查看，然后关闭服务器</p>\n\n<h3 id=\"3-创建新主题博客\">3. 创建新主题博客</h3>\n<p>如果不想使用模板，可以自己创建一个jekyll主题。进入进文件夹，创建一个名为myblog的主题</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ jekyll new myblog\nor \n$ jekyll new . --force\n</code></pre>  </div></div>\n<p>创建好之后，可以进行自行开发完善</p>\n\n<h3 id=\"4-其他命令\">4. 其他命令</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># gem清单\ngem list\n# 删除Bundle的一个镜像源\n$ bundle config --delete 'mirror.https://rubygems.org'\n</code></pre>  </div></div>\n<p>其他更多命令，可以使用”gem help”命令查看</p>\n\n","dir":"/blog/development/html/webdesign/","name":"2023-04-24_1.md","path":"blog/development/html/webdesign/2023-04-24_1.md","url":"/blog/development/html/webdesign/2023-04-24_1.html"},{"sort":1,"layout":"default","title":"软件开发者常用的工具有哪些(软件开发工具)？","content":"<h1 id=\"软件开发者常用的工具有哪些软件开发工具\">软件开发者常用的工具有哪些(软件开发工具)？</h1>\n\n<p>工欲善其事必先利其器，开发者们要有好的工具才能更快搞定问题。下面是一些常用的开发工具</p>\n\n<h2 id=\"一-编辑器\">一. 编辑器</h2>\n<p>编写代码是软件开发的核心工作。一个好的编辑器可以提高开发效率，减少手动输入代码的时间。</p>\n\n<h3 id=\"visual-studio-code-简称vs-code编写现代web和云应用的跨平台源代码编辑器\">Visual Studio Code (简称“VS Code”,编写现代Web和云应用的跨平台源代码编辑器）</h3>\n<p>重新定义和优化了代码编辑,以便生成和调试新式 Web 应用程序和云应用程序。也是著名的文本编辑器，它是轻量级的,vSCode的一大特点就是你可以通过多种方式来调整设置,而且Vim可以和VScode集成在一起，它还带有一个集成终端，可用的扩展太多，使开发人员的工作变得更加轻松。我最喜欢的一些扩展是AWS Toolkit, ESLint,Live Server, Live Share, Prettier-代码格式化程序，YAML,Live Sass编译器，Docker等。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/v2-6de5fb17576149fa6646498f632a1970_rmin.png\" alt=\"VisualStudioCode\" /></p>\n\n<h2 id=\"二-集成开发环境ide\">二. 集成开发环境（IDE）</h2>\n<p>集成开发环境是一种可以提供代码编辑、编译、调试、版本控制等功能的软件。</p>\n<h3 id=\"idea-intellij-idea-java-编程语言-开发的集成环境\">Idea-Intellij IDEA (java 编程语言 开发的集成环境)</h3>\n\n<p>业界排名第一的java开发工具，非常非常好用，如果还在用eclipse的朋友，赶紧来体验一把，你一定会爱上她的。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/v2-619e3bdc4bf10e953f16ab6243893c8a_720wmin.png\" alt=\"Idea-IntellijIDEA\" /></p>\n\n<h3 id=\"eclipse\">Eclipse</h3>\n<p>Java开发工具，支持多种语言。</p>\n\n<h3 id=\"visual-studio\">Visual Studio</h3>\n<p>微软开发的IDE，支持多种语言和平台。</p>\n\n<h2 id=\"三-版本控制工具\">三. 版本控制工具</h2>\n<p>版本控制工具可以帮助开发者管理代码，协作开发，追踪代码的变化</p>\n<h3 id=\"git\">Git</h3>\n<p>强大的分布式版本控制工具，广泛应用于开源项目和商业项目中。</p>\n\n<h3 id=\"svn\">SVN</h3>\n<p>集中式版本控制工具，易于学习和使用。</p>\n\n<h2 id=\"四-单元测试工具\">四. 单元测试工具</h2>\n<p>单元测试是测试软件中最小的可测试单元，可以帮助开发者发现代码中的问题。</p>\n<h3 id=\"postman-api调试工具\">Postman (api调试工具)</h3>\n<p>简单来说，四个词，简单、实用、大方、美观！postman这款网页调试工具的windows客户端，功能强大的HTTP调试与模拟插件。使用Postman可以进行API开发、请求、调试,除了它，还可以使用lnsomnia和Insomnia Designer作为API文档。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517150030min.png\" alt=\"Postman\" /></p>\n\n<h3 id=\"junit\">JUnit</h3>\n<p>Java单元测试框架，广泛应用于Java项目中。</p>\n\n<h3 id=\"pytest\">pytest</h3>\n<p>Python的单元测试框架，支持测试用例的自动化发现和运行。</p>\n\n<h3 id=\"mocha\">Mocha</h3>\n<p>JavaScript的单元测试框架，支持异步测试和浏览器测试。</p>\n\n<h2 id=\"五-集成测试工具\">五. 集成测试工具</h2>\n<p>集成测试是测试软件各个部分之间的交互和整合，可以帮助开发者发现系统集成的问题。</p>\n\n<h3 id=\"selenium\">Selenium</h3>\n<p>Web应用程序的自动化测试工具，支持多种浏览器和操作系统。</p>\n\n<h3 id=\"junit-1\">JUnit</h3>\n<p>Java的单元测试框架，也可以用于集成测试。</p>\n\n<h3 id=\"pytest-1\">pytest</h3>\n<p>Python的单元测试框架，也可以用于集成测试。</p>\n\n<h2 id=\"六-编译工具\">六. 编译工具</h2>\n<p>编译器可以将源代码转换为目标代码，以便计算机可以理解和执行。</p>\n\n<h3 id=\"gcc\">GCC</h3>\n<p>GNU编译器套件，支持多种语言和平台。</p>\n\n<h3 id=\"clang\">Clang</h3>\n<p>开源的编译器，支持多种语言和平台。</p>\n\n<h3 id=\"msvc\">MSVC</h3>\n<p>微软的编译器，支持C++和C#等语言。</p>\n\n<h2 id=\"集成开发及部署工具\">集成开发及部署工具</h2>\n<p>集成开发及部署工具可以帮助开发者自动化构建、测试、部署软件。</p>\n\n<h3 id=\"jenkins\">Jenkins</h3>\n<p>开源的自动化构建工具，支持多种语言和平台。</p>\n\n<h3 id=\"travis-ci\">Travis CI</h3>\n<p>为GitHub项目提供持续集成服务。</p>\n\n<h3 id=\"docker\">Docker</h3>\n<p>开源的容器化平台，可以帮助开发者打包、发布和运行应用程序。</p>\n\n<h2 id=\"七-其他工具\">七. 其他工具</h2>\n\n<h3 id=\"navicatpremium-数据库管理工具\">NavicatPremium (数据库管理工具)</h3>\n<p>Navicat premium是一款数据库管理工具,是一个可多重连线资料库的管理工具，它可以让你以单一程式同时连线到 MySQL、SQLite、Oracle 及 PostgreSQL 资料库，让管理不同类型的资料库更加的方便。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/v2-9c539429abf9e740c326c94f9a8b5025_720wmin.png\" alt=\"NavicatPremium\" /></p>\n\n<h3 id=\"redisdesktopmanager-一款可视化-redis管理工具-\">RedisDesktopManager (一款可视化 redis管理工具 )</h3>\n<p>Redis Desktop Manager是一款简单快速、跨平台的Redis桌面管理工具，也被称作Redis可视化工具，Redis Desktop Manager官方版是一款开源软件，支持通过SSH Tunnel连接，支持windows、mac等多平台。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517150142min.png\" alt=\"RedisDesktopManager\" /></p>\n\n<h3 id=\"securecrt-ssh终端仿真程序\">SecureCRT (SSH终端仿真程序)</h3>\n<p>SecureCRT是一款终端仿真程序，支持SSH（SSH1和SSH2）以及Telnet和rlogin协议。SecureCRT用于连接运行包括Windows、UNIX和VMS在内的远程系统的理想工具。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/v2-9ff0dca191c25be6a6ab5b7ac7667886_r.jpg\" alt=\"SecureCRT\" /></p>\n","dir":"/blog/development/tool/software/","name":"2023-05-17_1.md","path":"blog/development/tool/software/2023-05-17_1.md","url":"/blog/development/tool/software/2023-05-17_1.html"},{"sort":1,"permalink":"/blog/development/tool/redis/","layout":"default","title":"Redis","content":"<h1 id=\"redis\">Redis</h1>\n\n<ul>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_1.html\">Windows部署redis集群模式</a></li>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_2.html\">redis如何设置密码</a></li>\n</ul>\n","dir":"/blog/development/tool/redis/","name":"README.md","path":"blog/development/tool/redis/README.md","url":"/blog/development/tool/redis/"},{"sort":1,"layout":"default","title":"Windows部署redis集群模式","content":"<h1 id=\"windows部署redis集群模式\">Windows部署redis集群模式</h1>\n\n<h2 id=\"一-安装\">一. 安装</h2>\n<h3 id=\"1-安装环境\">1. 安装环境</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>操作系统： win7\nredis版本：redis-5.0.10\n</code></pre>  </div></div>\n\n<h3 id=\"2-安装包\">2. 安装包</h3>\n\n<p>redis官方没有Windows版本安装包，需在开源的GitHub下载</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>下载地址：https://github.com/tporadowski/redis/releases\n安装包：Redis-x64-5.0.10.zip\n</code></pre>  </div></div>\n\n<p>redis集群模式至少需要3主3从共集成6个redis节点</p>\n\n<p>在D盘创建redis集群目录redis-cluster，下载安装包后解压到该目录并复制5次，分别重命名为 redis-7001 至 redis-7006</p>\n\n<h2 id=\"二-配置\">二. 配置</h2>\n<h3 id=\"1-配置文件\">1. 配置文件</h3>\n\n<p>修改所有redis目录下的配置文件：redis.windows.conf</p>\n\n<blockquote>\n <p>注意：不同节点的端口号和集群配置文件不同，其他配置都相同</p>\n\n <p>端口号：将各个节点端口号分别修改为7001-7006</p>\n\n <p>集群配置文件：将文件名后面的6379改成各自节点的端口号</p>\n</blockquote>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 修改绑定IP，支持远程登录\nbind 0.0.0.0 \n# 修改端口号，将各个节点端口号分别修改为7001-7006\nport 7001 # 修改密码，6个节点的密码必须一致\n# 不设置密码也可以，登录时不需要密码\nrequirepass 123456 \n# 修改所属主节点密码\n# 若未设置密码则不需要修改\nmasterauth 123456 \n# 开启集群模式\ncluster-enabled yes \n# 集群超时配置\ncluster-node-timeout 15000 \n# 集群配置文件\n# 集群部署成功后会在该redis目录生成该文件\ncluster-config-file nodes-7001.conf \n# 开启AOF持久化\n# redis默认使用RDB持久化，将该配置修改为yes则使用AOF持久化\nappendonly yes\n</code></pre>  </div></div>\n\n<h3 id=\"2-启动脚本\">2. 启动脚本</h3>\n\n<h4 id=\"21-一个文件\">2.1 一个文件</h4>\n<p>建立名字为<strong>RedisCluster.bat</strong>的脚本文件，后缀是bat。将下面内容复制进去，一次性全部启动起来。\n将路径改为redis位置的真实路径。</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>start \"Redis7001\" cmd  /c \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7001&amp;&amp;redis-server.exe redis.windows-service.conf\"\n\nstart \"Redis7002\" cmd  /k \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7002&amp;&amp;redis-server.exe redis.windows-service.conf\"\n\nstart \"Redis7003\" cmd  /k \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7003&amp;&amp;redis-server.exe redis.windows-service.conf\"\n\nstart \"Redis7004\" cmd  /k \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7004&amp;&amp;redis-server.exe redis.windows-service.conf\"\n\nstart \"Redis7005\" cmd  /k \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7005&amp;&amp;redis-server.exe redis.windows-service.conf\"\n\nstart \"Redis7006\" cmd  /k \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7006&amp;&amp;redis-server.exe redis.windows-service.conf\"\n</code></pre>  </div></div>\n<h4 id=\"22-分多个文件\">2.2 分多个文件</h4>\n\n<p>直接在redis-cluster目录下创建6个bat脚本，以 start-7001.bat 至 start-7006命名，分别启动6个redis节点\n。</p>\n\n<p>start-7001.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7001 cd ./redis-7001redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<p>start-7002.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7002 cd ./redis-7002redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<p>start-7003.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7003 cd ./redis-7003redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<p>start-7004.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7004 cd ./redis-7004redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<p>start-7005.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7005 cd ./redis-7005redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<p>start-7006.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7006 cd ./redis-7006redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<hr />\n\n<h2 id=\"三-创建集群\">三. 创建集群</h2>\n\n<p>首先双击6个bat脚本启动所有redis节点</p>\n\n<p>然后到任意一个节点的reids目录下，启动cmd控制台。使用下面命令创建集群：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 无密码创建集群命令\nredis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 \n# 有密码创建集群命令\nredis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1   -a 123456\n</code></pre>  </div></div>\n\n<p>执行该命令后提示：Can I set the above configuration? (type ‘yes’ to accept): </p>\n\n<p>输入yes，回车，redis集群创建成功，各个redis节点下面会生成集群配置文件，如：nodes-7001.conf，nodes-7002.conf</p>\n\n<p>所有redis节点关闭后重新启动，无需再执行该命令创建集群</p>\n\n<h2 id=\"四-测试\">四. 测试</h2>\n\n<p>登录redis集群的任意一个节点即可<br />\n一定要加上-c，不然使用get等命令时节点之间是无法自动跳转的</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 无密码登录\nredis-cli -c -h 127.0.0.1 -p 7001 \n# 密码登录\nredis-cli -c -h 127.0.0.1 -p 7001 -a 123456\n</code></pre>  </div></div>\n\n<p>cluster集群命令</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 查看当前节点信息\ncluster info \n# 查看当前集群信息\ncluster nodes\n</code></pre>  </div></div>\n","dir":"/blog/development/tool/redis/","name":"2023-04-30_1.md","path":"blog/development/tool/redis/2023-04-30_1.md","url":"/blog/development/tool/redis/2023-04-30_1.html"},{"sort":1,"permalink":"/blog/development/interview/","layout":"default","title":"面试宝典","content":"<h1 id=\"面试宝典\">面试宝典</h1>\n\n<ul>\n <li><a href=\"/blog/development/interview/java/\">Java面试题</a>\n <ul>\n <li><a href=\"/blog/development/interview/java/2023-04-23_1.html\">Java面试宝典一(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_2.html\">Java面试宝典二(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_3.html\">Java面试宝典三(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_4.html\">Java面试宝典四(2023最新Java面试题)</a></li>\n </ul>\n </li>\n</ul>\n\n","dir":"/blog/development/interview/","name":"README.md","path":"blog/development/interview/README.md","url":"/blog/development/interview/"},{"sort":1,"layout":"default","title":"Java面试宝典一(2023最新Java面试题)","content":"<h1 id=\"java面试宝典一2023最新java面试题\">Java面试宝典一(2023最新Java面试题)</h1>\n\n<p>最近正在考虑找新工作，进行面试，但是工作时间比较久了，很多基础知识都很模糊，所以得复习下，顺便做下记录。</p>\n\n<p>包含Java基础相关的面试题，本文的宗旨是为读者朋友们整理一份详实而又准确的面试清单，下面一起进入主题吧</p>\n\n<p>本文分为十九个模块，分别是：<strong>「Java 基础、容器、多线程、反射、对象拷贝、Java Web 、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、MyBatis、RabbitMQ、Kafka、Zookeeper、MySQL、Redis、JVM」</strong></p>\n\n<h2 id=\"一-java-基础\">一. Java 基础</h2>\n\n<h3 id=\"1-jdk-和-jre-有什么区别\"><strong>1. JDK 和 JRE 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。\nJRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。\n</code></pre>  </div></div>\n\n<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p>\n\n<h3 id=\"2--和-equals-的区别是什么\"><strong>2. == 和 equals 的区别是什么？</strong></h3>\n\n<p><strong>「== 解读」</strong></p>\n\n<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>基本类型：比较的是值是否相同；\n引用类型：比较的是引用是否相同；\n</code></pre>  </div></div>\n\n<p>代码示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>String x = \"string\";\nString y = \"string\";\nString z = new String(\"string\");\nSystem.out.println(x==y); // true\nSystem.out.println(x==z); // false\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x.equals(z)); // true\n</code></pre>  </div></div>\n\n<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>\n\n<p><strong>「equals 解读」</strong></p>\n\n<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>\n\n<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>class Cat{    \n\tpublic Cat(String name){        \n\t\tthis.name = name;    \n\t}     \n\t\n\tprivate String name;\n\t\n\tpublic String getName(){        \n\t\treturn name;    \n\t}     \n\tpublic void setName(String name){        \n\t\tthis.name = name;    \n\t}\n} \n\nCat c1 = new Cat(\"王磊\");\nCat c2 = new Cat(\"王磊\");\nSystem.out.println(c1.equals(c2)); // false\n</code></pre>  </div></div>\n\n<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public boolean equals(Object obj){        \n\treturn (this == obj);\n}\n</code></pre>  </div></div>\n\n<p>原来 equals 本质上就是 ==。</p>\n\n<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>String s1 = new String(\"老王\");\nString s2 = new String(\"老王\");\nSystem.out.println(s1.equals(s2)); // true\n</code></pre>  </div></div>\n\n<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public boolean equals(Object anObject){    \n\tif (this == anObject) {        \n\t\treturn true;    \n\t}    \n\tif (anObject instanceof String) {        \n\t\tString anotherString = (String)anObject;        \n\t\tint n = value.length;        \n\t\tif (n == anotherString.value.length) {            \n\t\t\tchar v1[] = value;            \n\t\t\tchar v2[] = anotherString.value;            \n\t\t\tint i = 0;            \n\t\t\twhile (n-- != 0) {                \n\t\t\t\tif (v1[i] != v2[i])                    \n\t\t\t\treturn false;                \n\t\t\t\ti++;            \t\n\t\t\t}            \n\t\t\treturn true;        \n\t\t}    \n\t}    \n\treturn false;\n}\n</code></pre>  </div></div>\n\n<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>\n\n<p><strong>「总结」</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>\n\n<h3 id=\"3-两个对象的-hashcode-相同则-equals-也一定为-true对吗\"><strong>3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</strong></h3>\n\n<p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p>\n\n<p>代码示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>String str1 = \"通话\";\nString str2 = \"重地\";\nSystem.out.println(String.format(\"str1：%d | str2：%d\", str1.hashCode(), str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n</code></pre>  </div></div>\n\n<p>执行的结果：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>str1：1179395 | str2：1179395 false\n</code></pre>  </div></div>\n\n<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>\n\n<h3 id=\"4-final-在-java-中有什么作用\"><strong>4. final 在 Java 中有什么作用？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>final 修饰的类叫最终类，该类不能被继承。\nfinal 修饰的方法不能被重写。\nfinal 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n</code></pre>  </div></div>\n\n<h3 id=\"5-java-中的-math-round-1-5-等于多少\"><strong>5. Java 中的 Math. round(-1. 5) 等于多少？</strong></h3>\n\n<p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>\n\n<h3 id=\"6-string-属于基础的数据类型吗\"><strong>6. String 属于基础的数据类型吗？</strong></h3>\n\n<p>String 不属于基础类型，基础类型有 8 种：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>byte、boolean、char、short、int、float、long、double\n</code></pre>  </div></div>\n\n<p>而 String 属于对象。</p>\n\n<h3 id=\"7-java-中操作字符串都有哪些类它们之间有什么区别\"><strong>7. Java 中操作字符串都有哪些类？它们之间有什么区别？</strong></h3>\n\n<p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\n\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n</code></pre>  </div></div>\n\n<h3 id=\"8-string-stri与-string-strnew-stringi一样吗\"><strong>8. String str=”i”与 String str=new String(“i”)一样吗？</strong></h3>\n\n<p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>\n\n<h3 id=\"9-如何将字符串反转\"><strong>9. 如何将字符串反转？</strong></h3>\n\n<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>\n\n<p>示例代码：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// StringBuffer reverse\nStringBuffer stringBuffer = new StringBuffer();\nstringBuffer.append(\"abcdefg\");\nSystem.out.println(stringBuffer.reverse()); // gfedcba\n// StringBuilder reverse\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"abcdefg\");\nSystem.out.println(stringBuilder.reverse()); // gfedcba\n</code></pre>  </div></div>\n\n<h3 id=\"10-string-类的常用方法都有那些\"><strong>10. String 类的常用方法都有那些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>indexOf()：返回指定字符的索引。\ncharAt()：返回指定索引处的字符。\nreplace()：字符串替换。\ntrim()：去除字符串两端空白。\nsplit()：分割字符串，返回一个分割后的字符串数组。\ngetBytes()：返回字符串的 byte 类型数组。\nlength()：返回字符串长度。\ntoLowerCase()：将字符串转成小写字母。\ntoUpperCase()：将字符串转成大写字符。\nsubstring()：截取字符串。\nequals()：字符串比较。\n</code></pre>  </div></div>\n\n<h3 id=\"11-抽象类必须要有抽象方法吗\"><strong>11. 抽象类必须要有抽象方法吗？</strong></h3>\n\n<p>不需要，抽象类不一定非要有抽象方法。</p>\n\n<p>示例代码：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>abstract classCat{    \n\tpublicstaticvoidsayHi(){        \n\t\tSystem. out. println(\"hi~\");    \n\t}\n}\n</code></pre>  </div></div>\n\n<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>\n\n<h3 id=\"12-普通类和抽象类有哪些区别\"><strong>12. 普通类和抽象类有哪些区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>普通类不能包含抽象方法，抽象类可以包含抽象方法。\n抽象类不能直接实例化，普通类可以直接实例化。\n</code></pre>  </div></div>\n\n<h3 id=\"13-抽象类能使用-final-修饰吗\"><strong>13. 抽象类能使用 final 修饰吗？</strong></h3>\n\n<p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，编辑器也会提示错误信息：Illegal combination of modifiers: ‘abstract’ and ‘final’</p>\n\n<h3 id=\"14-接口和抽象类有什么区别\"><strong>14. 接口和抽象类有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n构造函数：抽象类可以有构造函数；接口不能有。\n实现数量：类可以实现很多个接口；但是只能继承一个抽象类。\n访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n</code></pre>  </div></div>\n\n<h3 id=\"15-java-中-io-流分为几种\"><strong>15. Java 中 IO 流分为几种？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>按功能来分：输入流（input）、输出流（output）。\n按类型来分：字节流和字符流。\n</code></pre>  </div></div>\n\n<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>\n\n<h3 id=\"16-bionioaio-有什么区别\"><strong>16. BIO、NIO、AIO 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\nNIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\nAIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n</code></pre>  </div></div>\n\n<h3 id=\"17-files的常用方法都有哪些\"><strong>17. Files的常用方法都有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Files.exists()：检测文件路径是否存在。\nFiles.createFile()：创建文件。\nFiles.createDirectory()：创建文件夹。\nFiles.delete()：删除一个文件或目录。\nFiles.copy()：复制文件。\nFiles.move()：移动文件。\nFiles.size()：查看文件个数。\nFiles.read()：读取文件。\nFiles.write()：写入文件。\n</code></pre>  </div></div>\n\n<h2 id=\"二-容器\">二. 容器</h2>\n\n<h3 id=\"1-java-容器都有哪些\"><strong>1. Java 容器都有哪些？</strong></h3>\n\n<p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Collection\n\tList\n\t\tArrayList\n\t\tLinkedList\n\t\tVector\n\t\tStack\n\tSet\n\t\tHashSet\n\t\tLinkedHashSet\n\t\tTreeSet\nMap\n\tHashMap\n\t\tLinkedHashMap\n\tTreeMap\n\tConcurrentHashMap\n\tHashtable\n</code></pre>  </div></div>\n\n<h3 id=\"2-collection-和-collections-有什么区别\"><strong>2. Collection 和 Collections 有什么区别？</strong></h3>\n\n<ul>\n <li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li>\n <li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法：Collections. sort(list)。</li>\n</ul>\n\n<h3 id=\"3-listsetmap-之间的区别是什么\"><strong>3. List、Set、Map 之间的区别是什么？</strong></h3>\n\n<p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>\n\n<p>三者之间的区别，如下表：\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230423195054min.png\" alt=\"List、Set、Map 之间的区别\" /></p>\n\n<h3 id=\"4-hashmap-和-hashtable-有什么区别\"><strong>4. HashMap 和 Hashtable 有什么区别？</strong></h3>\n\n<ul>\n <li>存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</li>\n <li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li>\n <li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>\n</ul>\n\n<h3 id=\"5-如何决定使用-hashmap-还是-treemap\"><strong>5. 如何决定使用 HashMap 还是 TreeMap？</strong></h3>\n\n<p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>\n\n<h3 id=\"6-说一下-hashmap-的实现原理\"><strong>6. 说一下 HashMap 的实现原理？</strong></h3>\n\n<p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>\n\n<h3 id=\"7-说一下-hashset-的实现原理\"><strong>7. 说一下 HashSet 的实现原理？</strong></h3>\n\n<p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>\n\n<h3 id=\"8-arraylist-和-linkedlist-的区别是什么\"><strong>8. ArrayList 和 LinkedList 的区别是什么？</strong></h3>\n\n<ul>\n <li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>\n <li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>\n <li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>\n</ul>\n\n<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>\n\n<h3 id=\"9-如何实现数组和-list-之间的转换\"><strong>9. 如何实现数组和 List 之间的转换？</strong></h3>\n\n<ul>\n <li>数组转 List：使用 Arrays.asList(array) 进行转换。</li>\n <li>List 转数组：使用 List 自带的 toArray() 方法。</li>\n</ul>\n\n<p>代码示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// list to array\nList&lt;String&gt; list = new ArrayList&lt;String&gt;();\nlist. add(\"王磊\");\nlist. add(\"的博客\");\nlist. toArray();\n// array to list\nString[] array = new String[]{\"王磊\",\"的博客\"};\nArrays. asList(array);\n</code></pre>  </div></div>\n\n<h3 id=\"10-arraylist-和-vector-的区别是什么\"><strong>10. ArrayList 和 Vector 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。\n性能：ArrayList 在性能方面要优于 Vector。\n扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。\n</code></pre>  </div></div>\n\n<h3 id=\"11-array-和-arraylist-有何区别\"><strong>11. Array 和 ArrayList 有何区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。\nArray 是指定固定大小的，而 ArrayList 大小是自动扩展的。\nArray 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。\n</code></pre>  </div></div>\n\n<h3 id=\"12-在-queue-中-poll和-remove有什么区别\"><strong>12. 在 Queue 中 poll()和 remove()有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>相同点：都是返回第一个元素，并在队列中删除返回的对象。\n不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。\n</code></pre>  </div></div>\n\n<p>代码示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();\nqueue.offer(\"string\"); // add\nSystem.out.println(queue.poll());\nSystem.out.println(queue.remove());\nSystem.out.println(queue.size());\n</code></pre>  </div></div>\n\n<h3 id=\"13-哪些集合类是线程安全的\"><strong>13. 哪些集合类是线程安全的？</strong></h3>\n\n<p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java.util.concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>\n\n<h3 id=\"14-迭代器-iterator-是什么\"><strong>14. 迭代器 Iterator 是什么？</strong></h3>\n\n<p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>\n\n<h3 id=\"15-iterator-怎么使用有什么特点\"><strong>15. Iterator 怎么使用？有什么特点？</strong></h3>\n\n<p>Iterator 使用代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nIterator&lt;String&gt; it = list. iterator();\nwhile(it. hasNext()){  \n\tString obj = it. next();  \n\tSystem. out. println(obj);\n}\n</code></pre>  </div></div>\n\n<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>\n\n<h3 id=\"16-iterator-和-listiterator-有什么区别\"><strong>16. Iterator 和 ListIterator 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。\nIterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。\nListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。\n</code></pre>  </div></div>\n\n<h3 id=\"17-怎么确保一个集合不能被修改\"><strong>17. 怎么确保一个集合不能被修改？</strong></h3>\n\n<p>可以使用 Collections.unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java.lang.UnsupportedOperationException 异常。</p>\n\n<p>示例代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist. add(\"x\");\nCollection&lt;String&gt; clist = Collections.unmodifiableCollection(list);\nclist. add(\"y\"); // 运行时此行报错\nSystem. out. println(list. size());\n</code></pre>  </div></div>\n\n<h2 id=\"三-多线程\">三. 多线程</h2>\n\n<h3 id=\"1-并行和并发有什么区别\"><strong>1. 并行和并发有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>并行：多个处理器或多核处理器同时处理多个任务。\n并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。 例如：\n\n并发 = 两个队列和一个售票员。\n并行 = 两个队列和两个售票员。\n</code></pre>  </div></div>\n\n<h3 id=\"2-线程和进程的区别\"><strong>2. 线程和进程的区别？</strong></h3>\n\n<p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>\n\n<h3 id=\"3-守护线程是什么\"><strong>3. 守护线程是什么？</strong></h3>\n\n<p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>\n\n<h3 id=\"4-创建线程有哪几种方式\"><strong>4. 创建线程有哪几种方式？</strong></h3>\n\n<p>创建线程有三种方式：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>继承 Thread 重写 run 方法；\n实现 Runnable 接口；\n实现 Callable 接口。\n</code></pre>  </div></div>\n\n<h3 id=\"5-说一下-runnable-和-callable-有什么区别\"><strong>5. 说一下 runnable 和 callable 有什么区别？</strong></h3>\n\n<p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p>\n\n<h3 id=\"6-线程有哪些状态\"><strong>6. 线程有哪些状态？</strong></h3>\n\n<p>线程的状态：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NEW 尚未启动\nRUNNABLE 正在执行中\nBLOCKED 阻塞的（被同步锁或者IO锁阻塞）\nWAITING 永久等待状态\nTIMED_WAITING 等待指定的时间重新被唤醒的状态\nTERMINATED 执行完成\n</code></pre>  </div></div>\n\n<h3 id=\"7-sleep-和-wait-有什么区别\"><strong>7. sleep() 和 wait() 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>类的不同：sleep() 来自 Thread，wait() 来自 Object。\n释放锁：sleep() 不释放锁；wait() 释放锁。\n用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。\n</code></pre>  </div></div>\n\n<h3 id=\"8-notify和-notifyall有什么区别\"><strong>8. notify()和 notifyAll()有什么区别？</strong></h3>\n\n<p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。</p>\n\n<p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。</p>\n\n<p>而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>\n\n<h3 id=\"9-线程的-run-和-start-有什么区别\"><strong>9. 线程的 run() 和 start() 有什么区别？</strong></h3>\n\n<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>\n\n<h3 id=\"10-创建线程池有哪几种方式\"><strong>10. 创建线程池有哪几种方式？</strong></h3>\n\n<p>线程池创建有七种方式，最核心的是最后一种：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；\n\nnewCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；\n\nnewFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；\n\nnewSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；\n\nnewScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；\n\nnewWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；\n\nThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。\n</code></pre>  </div></div>\n\n<h3 id=\"11-线程池都有哪些状态\"><strong>11. 线程池都有哪些状态？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。\nSHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。\nSTOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。\nTIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。\nTERMINATED：terminated()方法结束后，线程池的状态就会变成这个。\n</code></pre>  </div></div>\n\n<h3 id=\"12-线程池中-submit-和-execute-方法有什么区别\"><strong>12. 线程池中 submit() 和 execute() 方法有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>execute()：只能执行 Runnable 类型的任务。\nsubmit()：可以执行 Runnable 和 Callable 类型的任务。\n</code></pre>  </div></div>\n\n<p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p>\n\n<h3 id=\"13-在-java-程序中怎么保证多线程的运行安全\"><strong>13. 在 Java 程序中怎么保证多线程的运行安全？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>方法一：使用安全类，比如 Java. util. concurrent 下的类。\n方法二：使用自动锁 synchronized。\n方法三：使用手动锁 Lock。\n</code></pre>  </div></div>\n\n<p>手动锁 Java 示例代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Lock lock = new ReentrantLock();\nlock.lock();\ntry {    \n\tSystem. out. println(\"获得锁\");\n} catch (Exception e) {    \n\t// TODO: handle exception\n} finally {    \n\tSystem. out. println(\"释放锁\");    \n\tlock. unlock();\n}\n</code></pre>  </div></div>\n\n<h3 id=\"14-多线程中-synchronized-锁升级的原理是什么\"><strong>14. 多线程中 synchronized 锁升级的原理是什么？</strong></h3>\n\n<p><strong>synchronized 锁升级原理</strong>：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>\n\n<p><strong>锁的升级的目的</strong>：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>\n\n<h3 id=\"15-什么是死锁\"><strong>15. 什么是死锁？</strong></h3>\n\n<p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>\n\n<h3 id=\"16-怎么防止死锁\"><strong>16. 怎么防止死锁？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。\n尽量使用 Java. util. concurrent 并发类代替自己手写锁。\n尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。\n尽量减少同步的代码块。\n</code></pre>  </div></div>\n\n<h3 id=\"17-threadlocal-是什么有哪些使用场景\"><strong>17. ThreadLocal 是什么？有哪些使用场景？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。\nThreadLocal 的经典使用场景是数据库连接和 session 管理等。\n</code></pre>  </div></div>\n\n<h3 id=\"18-说一下-synchronized-底层实现原理\"><strong>18. 说一下 synchronized 底层实现原理？</strong></h3>\n\n<p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>\n\n<h3 id=\"19-synchronized-和-volatile-的区别是什么\"><strong>19. synchronized 和 volatile 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。\nvolatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。\nvolatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\n</code></pre>  </div></div>\n\n<h3 id=\"20-synchronized-和-lock-有什么区别\"><strong>20. synchronized 和 Lock 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。\nsynchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\n</code></pre>  </div></div>\n\n<h3 id=\"21-synchronized-和-reentrantlock-区别是什么\"><strong>21. synchronized 和 ReentrantLock 区别是什么？</strong></h3>\n\n<p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。\n主要区别如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；\nReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；\nReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。\n</code></pre>  </div></div>\n\n<h3 id=\"22-说一下-atomic-的原理\"><strong>22. 说一下 atomic 的原理？</strong></h3>\n\n<p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>\n\n<h2 id=\"四-反射\">四. 反射</h2>\n\n<h3 id=\"1-什么是反射\"><strong>1. 什么是反射？</strong></h3>\n\n<p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>\n\n<h3 id=\"2-什么是-java-序列化什么情况下需要序列化\"><strong>2. 什么是 Java 序列化？什么情况下需要序列化？</strong></h3>\n\n<p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。\n以下情况需要使用 Java 序列化：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>想把的内存中的对象状态保存到一个文件中或者数据库中时候；\n想用套接字在网络上传送对象的时候；\n想通过RMI（远程方法调用）传输对象的时候。\n</code></pre>  </div></div>\n\n<h3 id=\"3-动态代理是什么有哪些应用\"><strong>3. 动态代理是什么？有哪些应用？</strong></h3>\n\n<p>动态代理是运行时动态生成代理类。</p>\n\n<p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>\n\n<h3 id=\"4-怎么实现动态代理\"><strong>4. 怎么实现动态代理？</strong></h3>\n\n<p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>\n\n<h2 id=\"五-对象拷贝\">五. 对象拷贝</h2>\n\n<h3 id=\"1-为什么要使用克隆\"><strong>1. 为什么要使用克隆？</strong></h3>\n\n<p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p>\n\n<h3 id=\"2-如何实现对象克隆\"><strong>2. 如何实现对象克隆？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。\n实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。\n</code></pre>  </div></div>\n\n<h3 id=\"3-深拷贝和浅拷贝区别是什么\"><strong>3. 深拷贝和浅拷贝区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。\n深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。\n</code></pre>  </div></div>\n","dir":"/blog/development/interview/java/","name":"2023-04-23_1.md","path":"blog/development/interview/java/2023-04-23_1.md","url":"/blog/development/interview/java/2023-04-23_1.html"},{"sort":1,"layout":"default","title":"Maven推送本地jar包到仓库","content":"<h1 id=\"maven推送本地jar包到仓库\">Maven推送本地jar包到仓库</h1>\n<h2 id=\"一-maven推送本地jar包到仓库通用方式\">一. Maven推送本地jar包到仓库(通用方式)</h2>\n<p>要将本地的 JAR 包推送到 Maven 仓库，可以使用 Maven 的 deploy:deploy-file 插件目标。以下是推送本地 JAR 包到 Maven 仓库的通用方式，步骤：</p>\n\n<p><strong>第一步：</strong>在 Maven 项目的根目录下，打开终端或命令行窗口。</p>\n\n<p><strong>第二步：</strong>运行以下 Maven 命令，将 JAR 包推送到仓库：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mvn deploy:deploy-file -DgroupId=&lt;groupId&gt; -DartifactId=&lt;artifactId&gt; -Dversion=&lt;version&gt; -Dpackaging=jar -Dfile=&lt;path-to-jar&gt; -Durl=&lt;repository-url&gt; -DrepositoryId=&lt;repository-id&gt;\n</code></pre>  </div></div>\n<p>具体参数含义：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;groupId&gt;：项目的 Group ID。\n&lt;artifactId&gt;：项目的 Artifact ID。\n&lt;version&gt;：项目的版本号。\n&lt;path-to-jar&gt;：本地 JAR 包的路径。\n&lt;repository-url&gt;：Maven 仓库的 URL。\n&lt;repository-id&gt;：Maven 仓库的 ID。 根据实际情况替换上述命令中的占位符（\\&lt;groupId&gt;、\\&lt;artifactId&gt;、\\&lt;version&gt;、\\&lt;path-to-jar&gt;、\\&lt;repository-url&gt;、\\&lt;repository-id&gt;）为相应的值。\n</code></pre>  </div></div>\n\n<p><strong>第三步：</strong>运行命令后，Maven 将会将本地的 JAR 包推送到指定的 Maven 仓库。</p>\n\n<p>确保在运行命令之前已经正确配置了 Maven 的 settings.xml 文件中的 <servers> 部分，其中包含仓库的认证凭据（用户名和密码）。</servers></p>\n\n<p>注意：推送 JAR 包到远程 Maven 仓库需要有相应的权限和认证凭据。如果没有访问远程仓库的权限，可以考虑将 JAR 包安装到本地仓库（使用 mvn install:install-file 插件目标），或者搭建私有 Maven 仓库。</p>\n\n<h2 id=\"二-maven推送本地jar包到远程仓库\">二. Maven推送本地jar包到远程仓库</h2>\n\n<p>需要将功能打成打包推上远程nexus仓库,具体推送及操作记录一下：</p>\n\n<h3 id=\"1-配置pomxml\">1. 配置pom.xml</h3>\n<p>在pom文件中添加远程仓库的地址和id.名称可以不需要.当然具体根据实际操作.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!--配置远程仓库地址--&gt;\n&lt;distributionManagement&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;ceshi-id&lt;/id&gt;\n\t\t\t&lt;name&gt;名称&lt;/name&gt;\n\t\t\t&lt;url&gt;http://xxx.xxx.x.xx:8081/repository/ceshi-id/&lt;/url&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/distributionManagement&gt;\n</code></pre>  </div></div>\n\n<h3 id=\"2-配置maven的settingxml\">2. 配置Maven的setting.xml</h3>\n\n<p>在maven配置文件中配置远程仓库的账号密码,id和pom文件中的必须一致.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;servers&gt;\n        &lt;server&gt;\n            &lt;id&gt;ceshi-id&lt;/id&gt;\n            &lt;username&gt;用户名&lt;/username&gt;\n            &lt;password&gt;密码&lt;/password&gt;\n        &lt;/server&gt;\n    &lt;/servers&gt;\n</code></pre>  </div></div>\n\n<h3 id=\"3-打包并推送到远程仓库\">3. 打包并推送到远程仓库</h3>\n<p>使用以下命令进行推送</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>maven clean deploy\n</code></pre>  </div></div>\n<p>如果使用IDE,右侧可以直接点击命令\n或者可以直接在命令栏使用命令推送.\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230428114825min.png\" alt=\"maven打包并推送到远程仓库\" /></p>\n\n<h2 id=\"maven的三个常用打包启动相关命令\">Maven的三个常用打包启动相关命令</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mvn clean package\n</code></pre>  </div></div>\n\n<p>依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等7个阶段。</p>\n\n<p>package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mvn clean install\n</code></pre>  </div></div>\n\n<p>依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install等8个阶段。</p>\n\n<p>install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mvn clean deploy\n</code></pre>  </div></div>\n\n<p>依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy等9个阶段。</p>\n\n<p>deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库</p>\n\n<h3 id=\"其他maven命令\">其他maven命令:</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>编译：mvn compile\n清理：mvn clean\n测试：mvn test\n打包：mvn package\n安装到repository：mvn install(具有编译和打包的功能)\n部署到tomcat：mvn deploy\n</code></pre>  </div></div>\n\n","dir":"/blog/development/tool/maven/","name":"2023-04-27_1.md","path":"blog/development/tool/maven/2023-04-27_1.md","url":"/blog/development/tool/maven/2023-04-27_1.html"},{"sort":1,"permalink":"/blog/development/tool/git/","layout":"default","title":"Git","content":"<h1 id=\"git\">Git</h1>\n\n<ul>\n <li><a href=\"/blog/development/tool/git/2023-04-27_1.html\">最新Github创建仓库,将项目上传到GitHub</a></li>\n <li><a href=\"/blog/development/tool/git/2023-04-28_1.html\">Git一份代码同时提交两个Git仓库</a></li>\n <li><a href=\"/blog/development/tool/git/2023-05-12_1.html\">Git常用操作命令</a></li>\n</ul>\n","dir":"/blog/development/tool/git/","name":"README.md","path":"blog/development/tool/git/README.md","url":"/blog/development/tool/git/"},{"sort":1,"layout":"default","title":"最新Github创建仓库,将项目上传到GitHub","content":"<h1 id=\"最新github创建仓库将项目上传到github\">最新Github创建仓库,将项目上传到GitHub</h1>\n<blockquote>\n <p>最近进行项目学习,想将代码放在GitHub上,但是找了多个攻略,都不全,因此自己制作一份,将创建仓库的过程记录下来,大家共同学习下.适合新手,有什么问题可以在底下指出,</p>\n</blockquote>\n\n<h2 id=\"一登录github创建仓库\">一.登录GitHub,创建仓库</h2>\n<p>GitHub账号应该都有的,如果没有,可以上<a href=\"https://github.com/\">https://github.com/</a> 进行账号注册,这个就不细说了.下面上干货.</p>\n<h3 id=\"1创建新仓库\">1.创建新仓库</h3>\n<p>点击右上角的+号,选择创建新仓库</p>\n\n<h3 id=\"2填写仓库详细信息\">2.填写仓库详细信息</h3>\n<p>按照图片上注释写就ok,所有填完,点最底下的创建就好了</p>\n\n<h3 id=\"3看完成后的仓库结构\">3.看完成后的仓库结构</h3>\n<p>此处我创建的仓库交JPA-demo,因为是学习jpa做的小demo.因此名字和项目名统一.\n创建后的项目中有两个文件LICENSE和README\n没有的小伙伴看下上一步填写信息时是不是忘了勾选什么.</p>\n\n<h2 id=\"二将本地项目上传github\">二.将本地项目上传GitHub</h2>\n\n<blockquote>\n <p>注意:这里默认本地已经安装好Git了,如果没有安装的小伙伴点击<a href=\"http://git-scm.com/download/\">http://git-scm.com/download/</a>根据自己电脑的进行下载\n或者使用我这里提供的win10 64的版本:</p>\n</blockquote>\n\n<p>链接：https://pan.baidu.com/s/1Ms3Qn4Z4Z5tDMh2ajSjISw 提取码：i0w7</p>\n\n<p>安装步骤很简单,全都默认就可以了\n安装完,打开Git Bash 将用户名和邮箱设置下</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ git config  –global  user.name  \"用户名\"\n$ git config  –global  user.email  \"邮箱\"\n</code></pre>  </div></div>\n\n<h3 id=\"1在本地项目中打开git-bash\">1.在本地项目中打开Git Bash</h3>\n\n<p>比如此处我向上传bbs项目,在bbs项目中打开</p>\n\n<h3 id=\"2按照以下命令一条一条输入\">2.按照以下命令一条一条输入</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. git init //把这个目录变成Git可以管理的仓库\n\n2.  git add . //不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 \n\n3. git commit -m \"first commit\" //把文件提交到仓库的信息\n\n4. git remote add origin  克隆的地址use shh的 //关联远程仓库\n\n5 .git push -u origin master //把本地库的所有内容推送到远程库上\n</code></pre>  </div></div>\n\n<p>这里可能有点问题,在输入第五步时报权限不足</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Warning: Permanently added 'github.com,13.229.188.59' (RSA) to the list of known hosts.\nAgent admitted failure to sign using the key.\nPermission denied (publickey).\nfatal: Could not read from remote repository.\n</code></pre>  </div></div>\n\n<p>最后查找了下,是因为没有在GitHub上配置密钥的原因.\n以下解决步骤:</p>\n\n<p>1.打开.ssh文件夹,一般在C盘的用户下的用户名下\n看里面除了known_hosts 文件,是否还有其他文件,若没有,则代表你没有生成密钥,有的话最好重新生成下,不确定存在的能不能用.</p>\n\n<p>2.生成密钥\n在此文件夹下,打开Git Bash, 运行命令</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ssh-keygen -t rsa -C “你的邮箱”\n</code></pre>  </div></div>\n\n<p>会生成id_rsa 和 id_rsa_pub,这代表这密钥已经生成</p>\n\n<p>3.将公共密钥复制到GitHub\n以记事本的格式打开id_rsa_pub\n将其中的内容复制到</p>\n\n<p>打开</p>\n\n<p>创建新密钥</p>\n\n<p>名字就起项目名,复制的东西放入底下的那个框中,完成.</p>\n\n<p>回到刚才命令的第五步,重新进行第五步,发现报错</p>\n\n<p>使用</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git pull --rebase origin master 该命令的意思是把远程库中的更新合并到（pull=fetch+merge）本地库中，–-rebase的作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中 然后重新进行第五步,完成\n</code></pre>  </div></div>\n\n","dir":"/blog/development/tool/git/","name":"2023-04-27_1.md","path":"blog/development/tool/git/2023-04-27_1.md","url":"/blog/development/tool/git/2023-04-27_1.html"},{"sort":1,"layout":"default","title":"Django中url与path及re_path区别","content":"<h1 id=\"django中url与path及re_path区别\">Django中url与path及re_path区别</h1>\n<p>一般不能分清两者的区别,所这简单介绍下两者.首先,url是Django 1.x中的写法,p在Django2.1中，开始舍弃django1.x中的url写法。在django2.x中，描写url配置的有两个函数path和re_path.re_path()函数可以看做是django 1.x中得url函数,即可以在路径中使用正则.</p>\n\n<h2 id=\"一path和url的区别\">一.path和url的区别：</h2>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>django.urls path\ndjango.conf.urls url\n</code></pre>  </div></div>\n\n<p>path与url是两个不同的模块,效果都是响应返回页面, path调用的是python第三方模块或框架,而url则是自定义的模块,如Views下的def函数对应你url中的参数值.</p>\n\n<p>例如:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>url(r'^login',views.login)，\ndef login(request):\n    return render(request,'login.html')\n</code></pre>  </div></div>\n<h3 id=\"1-url旧版本使用\">1. url（旧版本使用）</h3>\n<p>在settings.py文件中有一个ROOT_URLCONF设置，设置的是在访问网址时通过哪一个url文件去匹配所请求的网址</p>\n\n<h4 id=\"url参数\">url参数</h4>\n<p>url或者re_path要复杂一些 （r’^blog/(?P[0-9]{4})/′）首先需要开始符和结尾符 '） 首先需要开始符^和结尾符 ′）首先需要开始符和结尾符,参数匹配一个 （）就是一个匹配参数，\n(?P<匹配的字段名>正则表达式)</匹配的字段名></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>用法：url(regex, view, kwargs=None, name=None)\n正则表达式：使用正则表达式进行URL匹配。\n参数 regex：指定要匹配的URL模式，可以使用正则表达式。\n参数 view：指定要调用的视图函数或处理程序。\n参数 kwargs：一个可选的关键字参数字典，用于传递额外的参数给视图函数或处理程序。\n参数 name：一个可选的URL名称，用于在模板中引用该URL。\n</code></pre>  </div></div>\n\n<p>进行匹配是不包括get或者post请求方式的参数及域名比如<a href=\"www.qq.com/blog?num=1\">www.qq.com/blog?num=1</a>并不会匹配？后边的字符</p>\n\n<p>可以给request参数设置一个默认值,最常见的分页url，比如</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    urlpatterns=[\n          url(r'^page/$',views.page),\n          url(r'^page(?P&lt;num&gt;[0-9]+)$',views.page)\n    ]\n    \n    #views\n    \n    def page(request,num='1'):\n         pass\n</code></pre>  </div></div>\n\n<p>自定义错误页面关键字handler400=blog.views.page_no_find</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    #urls.py\n    …\n    handler400=blog.views.page_no_find\n</code></pre>  </div></div>\n\n<h3 id=\"2path\">2、path</h3>\n<p>参数的使用方法path(‘blog/str:string/’) 简单了很多，就是尖括号，前边是str代表参数的类型，后面代表参数的名称</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>用法：path(route, view, kwargs=None, name=None)\n路径匹配：使用路径匹配规则进行URL匹配。\n参数 route：指定要匹配的URL模式，以字符串形式表示，不使用正则表达式。\n参数 view：指定要调用的视图函数或处理程序。\n参数 kwargs：一个可选的关键字参数字典，用于传递额外的参数给视图函数或处理程序。\n参数 name：一个可选的URL名称，用于在模板中引用该URL。\n</code></pre>  </div></div>\n\n<h4 id=\"path参数类型\">path参数类型</h4>\n<p>捕获url中的参数需要用到尖括号&lt;&gt; 指定尖括号中的值类型比如int:astr:link这个转换器还有许多类型比如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>int 匹配0和正整数\nstr 匹配任何空字符串但不包括/\nslug 可理解为注释 匹配任何ascii码包括连接线和下划线\nuuid 匹配一个uuid对象（该对象必须包括破折号—，所有字母必须小写）\npath 匹配所有的字符串 包括/（意思就是path前边和后边的所有）\n</code></pre>  </div></div>\n\n<h3 id=\"3re_path\">3.re_path</h3>\n<p>如果遇上路径和转换器语法都不足以定义的URL模式，那么就需要使用正则表达式，这时候就需要使用re_path()，而非path()。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>用法：re_path(regex, view, kwargs=None, name=None)\n正则表达式：使用正则表达式进行URL匹配，与 url 函数类似。\n参数 regex：指定要匹配的URL模式，可以使用正则表达式。\n参数 view：指定要调用的视图函数或处理程序。\n参数 kwargs：一个可选的关键字参数字典，用于传递额外的参数给视图函数或处理程序。\n参数 name：一个可选的URL名称，用于在模板中引用该URL。\n</code></pre>  </div></div>\n\n<p>举例：传递 数字结尾的参数</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    re_path(r'(\\d+)/$',views.peopleList,name='peopleList'),\n</code></pre>  </div></div>\n\n<h3 id=\"总结\">总结</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>url 使用正则表达式进行URL匹配，是较旧的方式。\npath 使用路径匹配规则进行URL匹配，是较新的方式。\nre_path 与 url 类似，也使用正则表达式进行URL匹配。 从Django 3.1版本开始，推荐使用 path 函数进行URL路由，因为它提供了更简单和更直观的语法。但是，如果需要更复杂的URL匹配，仍可以使用 re_path 或 url 函数。\n</code></pre>  </div></div>\n\n<h2 id=\"二python3中使用django2常见设置path问题\">二、python3中使用django2,常见设置path问题</h2>\n<h3 id=\"1django2中使用\">1.Django2中使用</h3>\n<p>在python3中使用django2的时候，在设置urls的时候，会遇到一些坑。这里做一下记录。\n系统的urls.py里，在1.X的时候，都是采用的url方式。如下</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    url(r'^', include(\"test1.urls\")),\n</code></pre>  </div></div>\n\n<p>在2.0中，它推荐使用的是path模块，所以这里就改写一下。引包</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    from django.urls import path\n    \n    path('', include(\"test1.urls\")),\n</code></pre>  </div></div>\n\n<p>注意:</p>\n<blockquote>\n <p>如果要使用正则，则要引入re_path，from django.urls import path, re_path\n这里面的正则写法，有点意思，一定要使用（）把正则包起来，然后用?P正式表达式 这种形式来表式</p>\n</blockquote>\n\n<h3 id=\"2app中使用path\">2.APP中使用path</h3>\n<p>1.x里面的写法是</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    url(r’^page=(\\d+)&amp;key=(\\w+)$’, views.detail, name=”detail”),\n</code></pre>  </div></div>\n<p>现在的写法</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    re_path('page=(?P&lt;page&gt;\\d+)&amp;key=(?P&lt;key&gt;\\w+)', views.detail, name=\"detail\"),\n</code></pre>  </div></div>\n<p>这样一对比就能明白了吧,使用的链接是http://127.0.0.1:8000/page=12&amp;key=abc</p>\n\n<h3 id=\"3系统的urlspy里的namespace的问题\">3.系统的urls.py里的namespace的问题</h3>\n<p>1.x中写法</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    url(r'^', include(\"test1.urls\", namespace='test1')),\n</code></pre>  </div></div>\n\n<p>可是在2.0中你这么写，会报错，说什么app_name的，这个自己可以看一下，怎么解决呢，其实很简单，只要在自己项目urls.py中加上这句就行了.如果不加的话可能报错,</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    app_name = 'test1'(你的APP名)\n</code></pre>  </div></div>\n\n<p>注:</p>\n<blockquote>\n <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>使用url也是可以的,为了简便起见,尽量使用符合版本的字段,另外在写路径时应该严格按照语法,比如'^' 和/$就不能缺,不能前面写url,括号里面确按照path的写法,这样很容易出错,到了关键时刻,很难定位问题点,很浪费时间.\n</code></pre>  </div> </div>\n</blockquote>\n","dir":"/blog/development/python/django/","name":"2023-04-27_1.md","path":"blog/development/python/django/2023-04-27_1.md","url":"/blog/development/python/django/2023-04-27_1.html"},{"sort":1,"layout":"default","title":"Windows端口常见问题解决","content":"<h1 id=\"windows端口常见问题解决\">Windows端口常见问题解决</h1>\n<p>在windows中启动项目经常会遇到各种问题，这里记录下解决方式</p>\n\n<h2 id=\"一-windows端口占用问题\">一. Windows端口占用问题</h2>\n<p>当要使用的端口已经被其他应用程序占用时，会导致新应用程序无法绑定该端口。解决方法包括关闭占用该端口的应用程序或更改新应用程序要使用的端口。</p>\n\n<h3 id=\"1根据被占用端口查询pid\">1.根据被占用端口查询pid</h3>\n<p>查看端口占用的进程号：netstat -ano|findstr “端口”</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>netstat -ano|findstr 8080\n</code></pre>  </div></div>\n<h3 id=\"2-根据查询的pid进程号删除进程\">2. 根据查询的pid进程号删除进程</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>taskkill /pid 8124  -t  -f\n</code></pre>  </div></div>\n","dir":"/blog/development/os/windows/","name":"2023-04-27_1.md","path":"blog/development/os/windows/2023-04-27_1.md","url":"/blog/development/os/windows/2023-04-27_1.html"},{"sort":1,"layout":"default","title":"Java中map常见操作集合","content":"<h1 id=\"java中map常见操作集合\">Java中map常见操作集合</h1>\n\n<h2 id=\"一-java中遍历map的几种常见方式\">一. Java中遍历Map的几种常见方式</h2>\n\n<p>在Java中，可以使用不同的方式来遍历Map，以下是常见的几种方式：</p>\n\n<h3 id=\"1-使用迭代器遍历map\">1. 使用迭代器遍历Map</h3>\n<p>使用Map.Entry对象的迭代器来遍历Map中的键值对，示例代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", 1);\nmap.put(\"B\", 2);\nmap.put(\"C\", 3);\n\nIterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry&lt;String, Integer&gt; entry = iterator.next();\n    String key = entry.getKey();\n    Integer value = entry.getValue();\n    System.out.println(key + \": \" + value);\n}\n</code></pre>  </div></div>\n\n<h3 id=\"2-使用foreach循环遍历map\">2. 使用foreach循环遍历Map</h3>\n<p>使用foreach循环遍历Map中的键值对，示例代码如下：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", 1);\nmap.put(\"B\", 2);\nmap.put(\"C\", 3);\n\nfor (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {\n    String key = entry.getKey();\n    Integer value = entry.getValue();\n    System.out.println(key + \": \" + value);\n}\n</code></pre>  </div></div>\n\n<h3 id=\"3-使用lambda表达式和stream-api遍历map\">3. 使用Lambda表达式和Stream API遍历Map</h3>\n<p>使用Lambda表达式和Stream API遍历Map中的键值对，示例代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", 1);\nmap.put(\"B\", 2);\nmap.put(\"C\", 3);\n\nmap.entrySet().stream().forEach(entry -&gt; {\n    String key = entry.getKey();\n    Integer value = entry.getValue();\n    System.out.println(key + \": \" + value);\n});\n</code></pre>  </div></div>\n\n<h3 id=\"4-使用java-8中的foreach方法遍历map\">4. 使用Java 8中的forEach()方法遍历Map</h3>\n<p>使用Java 8中的forEach()方法遍历Map中的键值对，示例代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", 1);\nmap.put(\"B\", 2);\nmap.put(\"C\", 3);\n\nmap.forEach((key, value) -&gt; System.out.println(key + \": \" + value));\n</code></pre>  </div></div>\n\n<p>需要注意的是，以上方式都是遍历Map中的键值对，如果只需要遍历Map中的键或值，也可以使用keySet()或values()方法来获取相应的集合，然后使用迭代器或Stream API遍历它们。</p>\n\n<h2 id=\"二-计算java中所有map值的总和\">二. 计算Java中所有Map值的总和</h2>\n<p>可以使用 values() 方法。现在任务简化为汇总集合中的所有值。这可以在 Java 中以多种方式完成：</p>\n\n<h3 id=\"1-使用-java-8\">1. 使用 Java 8</h3>\n<p>在 Java 8 或更高版本中，可以使用 Streams 轻松完成求和运算，而无需任何循环。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import java.util.HashMap;\nimport java.util.Map;\n \npublic class Main{\n    public static void main(String[] args){\n        Map&lt;String, Integer&gt; persons = new HashMap&lt;&gt;();\n \n        persons.put(\"John\", 25);\n        persons.put(\"Neil\", 15);\n        persons.put(\"Rosy\", 18);\n \n        int sum = persons.values().stream().mapToInt(Integer::intValue).sum();\n \n        System.out.println(sum);        // 58\n    }\n}\n</code></pre>  </div></div>\n\n<p>还可以使用 reduce() 方法。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import java.util.HashMap;\nimport java.util.Map;\n \npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Map&lt;String, Integer&gt; persons = new HashMap&lt;&gt;();\n \n        persons.put(\"John\", 25);\n        persons.put(\"Neil\", 15);\n        persons.put(\"Rosy\", 18);\n \n        int sum = persons.values().stream().reduce(0, Integer::sum);\n \n        System.out.println(sum);        // 58\n    }\n}\n</code></pre>  </div></div>\n<h3 id=\"2-使用for循环\">2. 使用for循环</h3>\n\n<p>在 Java 8 之前，我们可以使用简单的 for 循环替换 Stream API 链：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import java.util.HashMap;\nimport java.util.Map;\n \npublic class Main{\n    public static void main(String[] args){\n        Map&lt;String, Integer&gt; persons = new HashMap&lt;&gt;();\n \n        persons.put(\"John\", 25);\n        persons.put(\"Neil\", 15);\n        persons.put(\"Rosy\", 18);\n \n        int sum = 0;\n        for (int value: persons.values()) {\n            sum += value;\n        }\n \n        System.out.println(sum);        // 58\n    }\n}\n</code></pre>  </div></div>\n\n<p>这就是计算 a 中所有值的总和 Map&lt;?, Integer&gt; 在Java。</p>\n","dir":"/blog/development/java/basics/","name":"2023-04-24_1.md","path":"blog/development/java/basics/2023-04-24_1.md","url":"/blog/development/java/basics/2023-04-24_1.html"},{"sort":1,"permalink":"/blog/development/os/linux/","layout":"default","title":"linux","content":"<h1 id=\"linux\">linux</h1>\n\n<ul>\n <li><a href=\"/blog/development/os/linux/2023-05-17_2.html\">Linux命令大全(Linux常用命令基础)</a></li>\n <li><a href=\"/blog/development/os/linux/2023-05-17_3.html\">Linux命令大全(Linux常用命令进阶)</a></li>\n <li><a href=\"/blog/development/os/linux/2023-04-23_1.html\">Linux的上传和下载功能</a></li>\n <li><a href=\"/blog/development/os/linux/2023-05-17_1.html\">Centos防火墙配置</a></li>\n</ul>\n","dir":"/blog/development/os/linux/","name":"README.md","path":"blog/development/os/linux/README.md","url":"/blog/development/os/linux/"},{"sort":1,"layout":"default","title":"Linux命令大全(Linux常用命令基础)","content":"<h1 id=\"linux命令大全linux常用命令基础\">Linux命令大全(Linux常用命令基础)</h1>\n\n<p>大家好，我是<strong>终南有客</strong>，Linux 的学习对于一个程序员的重要性是不言而喻的。学好它是程序员必备修养之一。同时也是很多公司的面试题。</p>\n\n<p>这里基于网上资料的基础上，做个Linux 常用命令大全的文章。</p>\n\n<h2 id=\"一-linux-基础\">一. Linux 基础</h2>\n\n<h3 id=\"1-操作系统\">1. 操作系统</h3>\n<p>操作系统 <code class=\"language-plaintext highlighter-rouge\">Operating System</code> 简称 <code class=\"language-plaintext highlighter-rouge\">OS</code> ，是软件的一部分，它是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁。</p>\n\n<p>操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能，如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序。</p>\n\n<h3 id=\"2-什么是-linux\">2. 什么是 Linux</h3>\n<h4 id=\"linux-系统内核与-linux-发行套件的区别\">Linux 系统内核与 Linux 发行套件的区别</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">Linux</code> 系统内核指的是由 <code class=\"language-plaintext highlighter-rouge\">Linus Torvalds</code> 负责维护，提供硬件抽象层、硬盘及文件系统控制及多任务功能的系统核心程序。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Linux</code> 发行套件系统是我们常说的 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 操作系统，也即是由 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 内核与各种常用软件的集合产品。</li>\n</ul>\n\n<p><strong>「总结：真正的 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 指的是系统内核，而我们常说的 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 指的是“发行版完整的包含一些基础软件的操作系统”。」</strong></p>\n\n<h3 id=\"3-linux-对比-windows\">3. Linux 对比 Windows</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>稳定且有效率；\n免费（或少许费用）；\n漏洞少且快速修补；\n多任务多用户；\n更加安全的用户与文件权限策略；\n适合小内核程序的嵌入系统；\n相对不耗资源。\n</code></pre>  </div></div>\n\n<h3 id=\"4-linux-系统种类\">4. Linux 系统种类</h3>\n\n<ul>\n <li><strong>「红帽企业版 Linux：」</strong> <code class=\"language-plaintext highlighter-rouge\">RHEL</code> 是全世界内使用最广泛的 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 系统。它具有极强的性能与稳定性，是众多生成环境中使用的（收费的）系统。</li>\n <li><strong>「Fedora：」</strong> 由红帽公司发布的桌面版系统套件，用户可以免费体验到最新的技术或工具，这些技术或工具在成熟后会被加入到 <code class=\"language-plaintext highlighter-rouge\">RHEL</code> 系统中，因此 <code class=\"language-plaintext highlighter-rouge\">Fedora</code> 也成为 <code class=\"language-plaintext highlighter-rouge\">RHEL</code> 系统的试验版本。</li>\n <li><strong>「CentOS：」</strong> 通过把 <code class=\"language-plaintext highlighter-rouge\">RHEL</code> 系统重新编译并发布给用户免费使用的 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 系统，具有广泛的使用人群。</li>\n <li><strong>「Deepin：」</strong> 中国发行，对优秀的开源成品进行集成和配置。</li>\n <li><strong>「Debian：」</strong> 稳定性、安全性强，提供了免费的基础支持，在国外拥有很高的认可度和使用率。</li>\n <li><strong>「Ubuntu：」</strong> 是一款派生自 <code class=\"language-plaintext highlighter-rouge\">Debian</code> 的操作系统，对新款硬件具有极强的兼容能力。 <code class=\"language-plaintext highlighter-rouge\">Ubuntu</code> 与 <code class=\"language-plaintext highlighter-rouge\">Fedora</code> 都是极其出色的 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 桌面系统，而且 <code class=\"language-plaintext highlighter-rouge\">Ubuntu</code> 也可用于服务器领域。</li>\n</ul>\n\n<h3 id=\"5-终端连接服务器\">5. 终端连接服务器</h3>\n<p>要通过终端连接到Linux服务器，你可以使用SSH（Secure Shell）协议进行安全的远程登录。下面是在不同操作系统上连接到Linux服务器的方法</p>\n\n<h4 id=\"windows\">Windows:</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>使用SSH客户端工具，如PuTTY或MobaXterm。这些工具可在它们的官方网站上下载并安装。\n打开SSH客户端工具，输入Linux服务器的IP地址或主机名。\n配置连接的端口号，默认情况下SSH使用22端口。\n选择SSH作为连接类型。\n点击连接按钮，输入你的用户名和密码来登录到Linux服务器。\n</code></pre>  </div></div>\n\n<h4 id=\"macos-或-linux\">MacOS 或 Linux:</h4>\n<p>打开终端应用程序。使用以下命令连接到Linux服务器：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ssh username@server-ip-address\n</code></pre>  </div></div>\n<p>将username替换为你的用户名，server-ip-address替换为Linux服务器的IP地址或主机名。\n输入你的密码来登录到Linux服务器。</p>\n\n<p><strong>注意</strong>：在连接之前，确保你拥有正确的登录凭据（用户名和密码）以及服务器的IP地址或主机名。此外，还可以使用SSH密钥进行身份验证，以提高安全性和便利性。如果你想使用SSH密钥进行身份验证，请确保在服务器上配置了相应的公钥授权。</p>\n\n<p>连接成功后，你将在终端或SSH客户端中获得对Linux服务器的远程访问权限，并可以在服务器上执行命令和操作。</p>\n\n<h3 id=\"6-shell\">6. Shell</h3>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Shell</code> 这个单词的原意是“外壳”，跟 <code class=\"language-plaintext highlighter-rouge\">kernel</code>（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">Shell</code> 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（ <code class=\"language-plaintext highlighter-rouge\">command line interface</code> ，简写为 <code class=\"language-plaintext highlighter-rouge\">CLI</code> ）。 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Shell</code> 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 命令写出各种小程序，又称为 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 脚本。这些脚本都通过 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 的解释执行，而不通过编译。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Shell</code> 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</li>\n</ul>\n\n<h4 id=\"shell-的种类\">Shell 的种类</h4>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Shell</code> 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 。</p>\n\n<p>历史上，主要的 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 有下面这些：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Bourne Shell（sh）\nBourne Again shell（bash）\nC Shell（csh）\nTENEX C Shell（tcsh）\nKorn shell（ksh）\nZ Shell（zsh）\nFriendly Interactive Shell（fish）\n</code></pre>  </div></div>\n<p>其中 <code class=\"language-plaintext highlighter-rouge\">Bash</code> 是目前最常用的 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 。 <code class=\"language-plaintext highlighter-rouge\">MacOS</code> 中的默认 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 就是 <code class=\"language-plaintext highlighter-rouge\">Bash</code> 。</p>\n\n<p>通过执行 <code class=\"language-plaintext highlighter-rouge\">echo $SHELL</code> 命令可以查看到当前正在使用的 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>echo $SHELL\n</code></pre>  </div></div>\n\n<p>还可以通过 <code class=\"language-plaintext highlighter-rouge\">cat /etc/shells</code> 查看当前系统安装的所有 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 种类。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cat /etc/shells\n</code></pre>  </div></div>\n<h3 id=\"7-命令\">7. 命令</h3>\n\n<h4 id=\"命令行提示符\">命令行提示符</h4>\n\n<p>进入命令行环境以后，用户会看到 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 的提示符。</p>\n\n<p>提示符往往是一串前缀，最后以 一个# （或者 $）结尾，用户可以在这个符号后面输入各种命令。</p>\n\n<p>执行一个简单的命令 <code class=\"language-plaintext highlighter-rouge\">pwd</code> ：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[root@centos1 ~]# pwd\n/root\n</code></pre>  </div></div>\n<h4 id=\"命令解析\">命令解析</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>`root`：表示用户名；\n`iZm5e8dsxce9ufaic7hi3uZ`：表示主机名；\n`~`：表示目前所在目录为家目录，其中 `root` 用户的家目录是 `/root` 普通用户的家目录在 `/home` 下；\n`#`：指示你所具有的权限（ `root` 用户为 `#` ，普通用户为 `$` ）。\n执行 `whoami` 命令可以查看当前用户名；\n执行 `hostname` 命令可以查看当前主机名；\n</code></pre>  </div></div>\n\n<p>关于如何创建、切换、删除用户，在后面的用户与权限会具体讲解，这里先使用 <code class=\"language-plaintext highlighter-rouge\">root</code> 用户进行演示。</p>\n\n<blockquote>\n <p>[备注] <code class=\"language-plaintext highlighter-rouge\">root</code> 是超级用户，具备操作系统的一切权限。</p>\n</blockquote>\n\n<p>注意： <code class=\"language-plaintext highlighter-rouge\">root</code> 用户为 <code class=\"language-plaintext highlighter-rouge\">#</code> ，普通用户为 <code class=\"language-plaintext highlighter-rouge\">$</code></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[root@centos1 ~]# /root\n-bash: /root: Is a directory\n[root@centos1 ~]# su minikube\n[minikube@centos1 root]$\n</code></pre>  </div></div>\n\n<h4 id=\"命令格式\">命令格式</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>command parameters（命令 参数）\n</code></pre>  </div></div>\n\n<h5 id=\"长短参数\">长短参数</h5>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>单个参数：ls -a（a 是英文 all 的缩写，表示“全部”）\n多个参数：ls -al（全部文件 + 列表形式展示）\n单个长参数：ls --all\n多个长参数：ls --reverse --all\n长短混合参数：ls --all -l\n</code></pre>  </div></div>\n\n<h5 id=\"参数值\">参数值</h5>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>短参数：command -p 10（例如：ssh root@121.42.11.34 -p 22）\n长参数：command --paramters=10（例如：ssh root@121.42.11.34 --port=22）\n</code></pre>  </div></div>\n\n<h3 id=\"8-快捷方式\">8. 快捷方式</h3>\n<p>在开始学习 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 命令之前，有这么一些快捷方式，是必须要提前掌握的，它将贯穿整个 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 使用生涯。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>通过上下方向键 ↑ ↓ 来调取过往执行过的 `Linux` 命令；\n命令或参数仅需输入前几位就可以用 `Tab` 键补全；\n`Ctrl + R` ：用于查找使用过的命令（`history` 命令用于列出之前使用过的所有命令，然后输入 `!` 命令加上编号( `!2` )就可以直接执行该历史命令）；\n`Ctrl + L`：清除屏幕并将当前行移到页面顶部；\n`Ctrl + C`：中止当前正在执行的命令；\n`Ctrl + U`：从光标位置剪切到行首；\n`Ctrl + K`：从光标位置剪切到行尾；\n`Ctrl + W`：剪切光标左侧的一个单词；\n`Ctrl + Y`：粘贴 `Ctrl + U | K | Y` 剪切的命令；\n`Ctrl + A`：光标跳到命令行的开头；\n`Ctrl + E`：光标跳到命令行的结尾；\n`Ctrl + D`：关闭 `Shell` 会话；\n</code></pre>  </div></div>\n\n<h2 id=\"二-文件和目录\">二. 文件和目录</h2>\n\n<h3 id=\"1-文件的组织\">1. 文件的组织</h3>\n\n<h4 id=\"pwd\">pwd</h4>\n<p>查看路径，显示当前目录的路径</p>\n\n<p>查看命令的可执行文件所在路径， <code class=\"language-plaintext highlighter-rouge\">Linux</code> 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， <code class=\"language-plaintext highlighter-rouge\">which</code> 命令本身对应的程序也存在于 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 中。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>which\n</code></pre>  </div></div>\n\n<p>总的来说一个命令就是一个可执行程序。</p>\n\n<h3 id=\"2-浏览和切换目录\">2. 浏览和切换目录</h3>\n\n<h4 id=\"ls\">ls</h4>\n\n<p>列出文件和目录，它是 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 最常用的命令之一。</p>\n\n<p>【常用参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-a</code> 显示所有文件和目录包括隐藏的</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-l</code> 显示详细列表</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-h</code> 适合人类阅读的</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-t</code> 按文件最近一次修改时间排序</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-i</code> 显示文件的 <code class=\"language-plaintext highlighter-rouge\">inode</code> （ <code class=\"language-plaintext highlighter-rouge\">inode</code> 是文件内容的标识）</li>\n</ul>\n\n<h4 id=\"cd\">cd</h4>\n\n<p><code class=\"language-plaintext highlighter-rouge\">cd</code> 是英语 <code class=\"language-plaintext highlighter-rouge\">change directory</code> 的缩写，表示切换目录。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cd / --&gt; 跳转到根目录\ncd ~ --&gt; 跳转到家目录\ncd .. --&gt; 跳转到上级目录\ncd ./home --&gt; 跳转到当前目录的home目录下\ncd /home/lion --&gt; 跳转到根目录下的home目录下的lion目录\ncd --&gt; 不添加任何参数，也是回到家目录\n</code></pre>  </div></div>\n\n<p>[注意] 输入<code class=\"language-plaintext highlighter-rouge\">cd /ho</code> + 单次 <code class=\"language-plaintext highlighter-rouge\">tab</code> 键会自动补全路径 + 两次 <code class=\"language-plaintext highlighter-rouge\">tab</code> 键会列出所有可能的目录列表。</p>\n\n<h4 id=\"du\">du</h4>\n\n<p>列举目录大小信息。</p>\n\n<p>【常用参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-h</code> 适合人类阅读的；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-a</code> 同时列举出目录下文件的大小信息；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-s</code> 只显示总计大小，不显示具体信息。</li>\n</ul>\n\n<h3 id=\"3-浏览和创建文件\">3. 浏览和创建文件</h3>\n\n<h4 id=\"cat\">cat</h4>\n\n<p>一次性显示文件所有内容，更适合查看小的文件。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cat cloud-init.log\n</code></pre>  </div></div>\n\n<p>【常用参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-n</code> 显示行号。</li>\n</ul>\n\n<h4 id=\"less\">less</h4>\n\n<p>分页显示文件内容，更适合查看大的文件。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>less cloud-init.log\n</code></pre>  </div></div>\n\n<p>【快捷操作】</p>\n\n<ul>\n <li>空格键：前进一页（一个屏幕）；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">b</code> 键：后退一页；</li>\n <li>回车键：前进一行；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">y</code> 键：后退一行；</li>\n <li>上下键：回退或前进一行；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">d</code> 键：前进半页；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">u</code> 键：后退半页；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">q</code> 键：停止读取文件，中止 <code class=\"language-plaintext highlighter-rouge\">less</code> 命令；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">=</code> 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">h</code> 键：显示帮助文档；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">/</code> 键：进入搜索模式后，按 <code class=\"language-plaintext highlighter-rouge\">n</code> 键跳到一个符合项目，按 <code class=\"language-plaintext highlighter-rouge\">N</code> 键跳到上一个符合项目，同时也可以输入正则表达式匹配。</li>\n</ul>\n\n<h4 id=\"head\">head</h4>\n\n<p>显示文件的开头几行（默认是10行）</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>head cloud-init.log\n</code></pre>  </div></div>\n\n<p>【参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-n</code> 指定行数 <code class=\"language-plaintext highlighter-rouge\">head cloud-init.log -n 2</code></li>\n</ul>\n\n<h4 id=\"tail\">tail</h4>\n\n<p>显示文件的结尾几行（默认是10行）</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>tail cloud-init.log\n</code></pre>  </div></div>\n\n<p>【参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-n</code> 指定行数 <code class=\"language-plaintext highlighter-rouge\">tail cloud-init.log -n 2</code></li>\n <li><code class=\"language-plaintext highlighter-rouge\">-f</code> 会每过1秒检查下文件是否有更新内容，也可以用 <code class=\"language-plaintext highlighter-rouge\">-s</code> 参数指定间隔时间 <code class=\"language-plaintext highlighter-rouge\">tail -f -s 4 xxx.log</code></li>\n</ul>\n\n<h4 id=\"touch\">touch</h4>\n\n<p>创建一个文件</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>touch new_file\n</code></pre>  </div></div>\n\n<h4 id=\"mkdir\">mkdir</h4>\n\n<p>创建一个目录</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mkdir new_folder\n</code></pre>  </div></div>\n\n<p>【常用参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-p</code> 递归的创建目录结构 <code class=\"language-plaintext highlighter-rouge\">mkdir -p one/two/three</code></li>\n</ul>\n\n<h3 id=\"4-文件的复制和移动\">4. 文件的复制和移动</h3>\n\n<h4 id=\"cp\">cp</h4>\n\n<p>拷贝文件和目录</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cp file file_copy --&gt; file 是目标文件，file_copy 是拷贝出来的文件\ncp file one --&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 file\ncp file one/file_copy --&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copy\ncp *.txt folder --&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下\n</code></pre>  </div></div>\n\n<p>【常用参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-r</code> 递归的拷贝，常用来拷贝一整个目录</li>\n</ul>\n\n<h4 id=\"mv\">mv</h4>\n\n<p>移动（重命名）文件或目录，与cp命令用法相似。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mv file one --&gt; 将 file 文件移动到 one 目录下\nmv new_folder one --&gt; 将 new_folder 文件夹移动到one目录下\nmv *.txt folder --&gt; 把当前目录下所有 txt 文件移动到 folder 目录下\nmv file new_file --&gt; file 文件重命名为 new_file\n</code></pre>  </div></div>\n\n<h3 id=\"5-文件的删除和链接\">5. 文件的删除和链接</h3>\n\n<h4 id=\"rm\">rm</h4>\n\n<p>删除文件和目录，由于 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>rm new_file  --&gt; 删除 new_file 文件\nrm f1 f2 f3  --&gt; 同时删除 f1 f2 f3 3个文件\n</code></pre>  </div></div>\n\n<p>【常用参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-i</code> 向用户确认是否删除；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-f</code> 文件强制删除；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-r</code> 递归删除文件夹，著名的删除操作 <code class=\"language-plaintext highlighter-rouge\">rm -rf</code> 。</li>\n</ul>\n\n<h4 id=\"ln\">ln</h4>\n\n<p>英文 <code class=\"language-plaintext highlighter-rouge\">Link</code> 的缩写，表示创建链接。</p>\n\n<p>学习创建链接之前，首先要理解链接是什么，我们先来看看 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 的文件是如何存储的：</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Linux</code> 文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 <code class=\"language-plaintext highlighter-rouge\">inode</code> 标识绑定到文件内容。</p>\n\n<p>Linux 下有两种链接类型：硬链接和软链接。</p>\n\n<h5 id=\"硬链接\">硬链接</h5>\n\n<p>使链接的两个文件共享同样文件内容，就是同样的 <code class=\"language-plaintext highlighter-rouge\">inode</code> ，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，因此软链接使用更加广泛。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ln file1 file2  --&gt; 创建 file2 为 file1 的硬链接\n</code></pre>  </div></div>\n\n<p>如果我们用 <code class=\"language-plaintext highlighter-rouge\">rm file1</code> 来删除 <code class=\"language-plaintext highlighter-rouge\">file1</code> ，对 <code class=\"language-plaintext highlighter-rouge\">file2</code> 没有什么影响，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除。只有同时删除了 <code class=\"language-plaintext highlighter-rouge\">file1</code> 与 <code class=\"language-plaintext highlighter-rouge\">file2</code> 后，它们共同指向的文件内容才会消失。</p>\n\n<h5 id=\"软链接\">软链接</h5>\n\n<p>软链接就类似 <code class=\"language-plaintext highlighter-rouge\">windows</code> 下快捷方式。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ln -s file1 file2\n</code></pre>  </div></div>\n\n<p>执行 <code class=\"language-plaintext highlighter-rouge\">ls -l</code> 命名查看当前目录下文件的具体信息</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>total 0\n-rw-r--r-- 1 root root 0 Jan 14 06:29 file1\nlrwxrwxrwx 1 root root 5 Jan 14 06:42 file2 -&gt; file1  # 表示file2 指向 file1\n</code></pre>  </div></div>\n\n<p>其实 <code class=\"language-plaintext highlighter-rouge\">file2</code> 只是 <code class=\"language-plaintext highlighter-rouge\">file1</code> 的一个快捷方式，它指向的是 <code class=\"language-plaintext highlighter-rouge\">file1</code> ，所以显示的是 <code class=\"language-plaintext highlighter-rouge\">file1</code> 的内容，但其实 <code class=\"language-plaintext highlighter-rouge\">file2</code> 的 <code class=\"language-plaintext highlighter-rouge\">inode</code> 与 <code class=\"language-plaintext highlighter-rouge\">file1</code> 并不相同。如果我们删除了 <code class=\"language-plaintext highlighter-rouge\">file2</code> 的话， <code class=\"language-plaintext highlighter-rouge\">file1</code> 是不会受影响的，但如果删除 <code class=\"language-plaintext highlighter-rouge\">file1</code> 的话， <code class=\"language-plaintext highlighter-rouge\">file2</code> 就会变成死链接，因为指向的文件不见了。</p>\n\n<h2 id=\"三-用户与权限\">三. 用户与权限</h2>\n\n<h3 id=\"1-用户\">1. 用户</h3>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Linux</code> 是一个多用户的操作系统。在 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫 <code class=\"language-plaintext highlighter-rouge\">root</code> ，是一个很特殊的用户，它是超级用户，拥有最高权限。</p>\n\n<p>自己创建的用户是有限权限的用户，这样大大提高了 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 系统的安全性，有效防止误操作或是病毒攻击，但是我们执行的某些命令需要更高权限时可以使用 <code class=\"language-plaintext highlighter-rouge\">sudo</code> 命令。</p>\n\n<h4 id=\"sudo\">sudo</h4>\n\n<p>以 <code class=\"language-plaintext highlighter-rouge\">root</code> 身份运行命令</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo date  --&gt; 当然查看日期是不需要sudo的这里只是演示，sudo 完之后一般还需要输入用户密码的\n</code></pre>  </div></div>\n\n<h4 id=\"useradd--passwd\">useradd + passwd</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">useradd</code> 添加新用户</li>\n <li><code class=\"language-plaintext highlighter-rouge\">passwd</code> 修改用户密码</li>\n</ul>\n\n<p>这两个命令需要 <code class=\"language-plaintext highlighter-rouge\">root</code> 用户权限</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>useradd lion --&gt; 添加一个lion用户，添加完之后在 /home 路径下可以查看\npasswd lion --&gt; 修改lion用户的密码\n</code></pre>  </div></div>\n\n<h4 id=\"userdel\">userdel</h4>\n\n<p>删除用户，需要 <code class=\"language-plaintext highlighter-rouge\">root</code> 用户权限</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>userdel lion --&gt; 只会删除用户名，不会从/home中删除对应文件夹\nuserdel lion -r --&gt; 会同时删除/home下的对应文件夹\n</code></pre>  </div></div>\n\n<h4 id=\"su\">su</h4>\n\n<p>切换用户，需要 <code class=\"language-plaintext highlighter-rouge\">root</code> 用户权限</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo su --&gt; 切换为root用户（exit 命令或 CTRL + D 快捷键都可以使普通用户切换为 root 用户）\nsu lion --&gt; 切换为普通用户\nsu - --&gt; 切换为root用户\n</code></pre>  </div></div>\n\n<h3 id=\"2-群组的管理\">2. 群组的管理</h3>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Linux</code> 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。</p>\n\n<h4 id=\"groupadd\">groupadd</h4>\n\n<p>创建群组，用法和 <code class=\"language-plaintext highlighter-rouge\">useradd</code> 类似。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>groupadd friends\n</code></pre>  </div></div>\n\n<h4 id=\"groupdel\">groupdel</h4>\n\n<p>删除一个已存在的群组</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>groupdel foo  --&gt; 删除foo群组\n</code></pre>  </div></div>\n\n<h4 id=\"groups\">groups</h4>\n\n<p>查看用户所在群组</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>groups lion  --&gt; 查看 lion 用户所在的群组\n</code></pre>  </div></div>\n\n<h4 id=\"usermod\">usermod</h4>\n\n<p>用于修改用户的账户。</p>\n\n<p>【常用参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-l</code> 对用户重命名。需要注意的是 <code class=\"language-plaintext highlighter-rouge\">/home</code> 中的用户家目录的名字不会改变，需要手动修改。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-g</code> 修改用户所在的群组，例如 <code class=\"language-plaintext highlighter-rouge\">usermod -g friends lion</code> 修改 <code class=\"language-plaintext highlighter-rouge\">lion</code> 用户的群组为 <code class=\"language-plaintext highlighter-rouge\">friends</code> 。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-G</code> 一次性让用户添加多个群组，例如 <code class=\"language-plaintext highlighter-rouge\">usermod -G friends,foo,bar lion</code> 。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-a</code> <code class=\"language-plaintext highlighter-rouge\">-G</code> 会让你离开原先的群组，如果你不想这样做的话，就得再添加 <code class=\"language-plaintext highlighter-rouge\">-a</code> 参数，意味着 <code class=\"language-plaintext highlighter-rouge\">append</code> 追加的意思。</li>\n</ul>\n\n<h4 id=\"chgrp\">chgrp</h4>\n\n<p>用于修改文件的群组。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>chgrp bar file.txt --&gt; file.txt文件的群组修改为bar\n</code></pre>  </div></div>\n\n<h4 id=\"chown\">chown</h4>\n\n<p>改变文件的所有者，需要 <code class=\"language-plaintext highlighter-rouge\">root</code> 身份才能运行。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>chown lion file.txt --&gt; 把其它用户创建的file.txt转让给lion用户\nchown lion:bar file.txt --&gt; 把file.txt的用户改为lion，群组改为bar\n</code></pre>  </div></div>\n\n<p>【常用参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-R</code> 递归设置子目录和子文件， <code class=\"language-plaintext highlighter-rouge\">chown -R lion:lion /home/frank</code> 把 <code class=\"language-plaintext highlighter-rouge\">frank</code> 文件夹的用户和群组都改为 <code class=\"language-plaintext highlighter-rouge\">lion</code> 。</li>\n</ul>\n\n<h3 id=\"3-文件权限管理\">3. 文件权限管理</h3>\n\n<h4 id=\"chmod\">chmod</h4>\n\n<p>修改访问权限。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>chmod 740 file.txt\n</code></pre>  </div></div>\n\n<p>【常用参数】</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-R</code> 可以递归地修改文件访问权限，例如 <code class=\"language-plaintext highlighter-rouge\">chmod -R 777 /home/lion</code></li>\n</ul>\n\n<p>修改权限的确简单，但是理解其深层次的意义才是更加重要的。下面我们来系统的学习 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 的文件权限。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[root@lion ~]# ls -l\ndrwxr-xr-x 5 root root 4096 Apr 13  2020 climb\nlrwxrwxrwx 1 root root    7 Jan 14 06:41 hello2.c -&gt; hello.c\n-rw-r--r-- 1 root root  149 Jan 13 06:14 hello.c\n</code></pre>  </div></div>\n\n<p>其中 <code class=\"language-plaintext highlighter-rouge\">drwxr-xr-x</code> 表示文件或目录的权限。让我们一起来解读它具体代表什么？</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">d</code> ：表示目录，就是说这是一个目录，普通文件是 <code class=\"language-plaintext highlighter-rouge\">-</code> ，链接是 <code class=\"language-plaintext highlighter-rouge\">l</code> 。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">r</code> ： <code class=\"language-plaintext highlighter-rouge\">read</code> 表示文件可读。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">w</code> ： <code class=\"language-plaintext highlighter-rouge\">write</code> 表示文件可写，一般有写的权限，就有删除的权限。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">x</code> ： <code class=\"language-plaintext highlighter-rouge\">execute</code> 表示文件可执行。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-</code> ：表示没有相应权限。</li>\n</ul>\n\n<p>权限的整体是按用户来划分的。</p>\n\n<p>现在再来理解这句权限 <code class=\"language-plaintext highlighter-rouge\">drwxr-xr-x</code> 的意思：</p>\n\n<ul>\n <li>它是一个文件夹；</li>\n <li>它的所有者具有：读、写、执行权限；</li>\n <li>它的群组用户具有：读、执行的权限，没有写的权限；</li>\n <li>它的其它用户具有：读、执行的权限，没有写的权限。</li>\n</ul>\n\n<p>现在理解了权限，我们使用 <code class=\"language-plaintext highlighter-rouge\">chmod</code> 来尝试修改权限。 <code class=\"language-plaintext highlighter-rouge\">chmod</code> 它不需要是 <code class=\"language-plaintext highlighter-rouge\">root</code> 用户才能运行的，只要你是此文件所有者，就可以用 <code class=\"language-plaintext highlighter-rouge\">chmod</code> 来修改文件的访问权限。</p>\n\n<h5 id=\"数字分配权限\">数字分配权限</h5>\n\n<p>因此要改变权限，只要做一些简单的加法就行：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>chmod 640 hello.c \n# 分析\n6 = 4 + 2 + 0 表示所有者具有 rw 权限\n4 = 4 + 0 + 0 表示群组用户具有 r 权限\n0 = 0 + 0 + 0 表示其它用户没有权限\n对应文字权限为：-rw-r-----\n</code></pre>  </div></div>\n\n<h5 id=\"用字母来分配权限\">用字母来分配权限</h5>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">u</code> ： <code class=\"language-plaintext highlighter-rouge\">user</code> 的缩写，用户的意思，表示所有者。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">g</code> ： <code class=\"language-plaintext highlighter-rouge\">group</code> 的缩写，群组的意思，表示群组用户。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">o</code> ： <code class=\"language-plaintext highlighter-rouge\">other</code> 的缩写，其它的意思，表示其它用户。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">a</code> ： <code class=\"language-plaintext highlighter-rouge\">all</code> 的缩写，所有的意思，表示所有用户。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">+</code> ：加号，表示添加权限。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-</code> ：减号，表示去除权限。</li>\n <li>\n <p><code class=\"language-plaintext highlighter-rouge\">=</code> ：等于号，表示分配权限。</p>\n\n <p>chmod u+rx file –&gt; 文件file的所有者增加读和运行的权限\nchmod g+r file –&gt; 文件file的群组用户增加读的权限\nchmod o-r file –&gt; 文件file的其它用户移除读的权限\nchmod g+r o-r file –&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限\nchmod go-r file –&gt; 文件file的群组和其他用户移除读的权限\nchmod +x file –&gt; 文件file的所有用户增加运行的权限\nchmod u=rwx,g=r,o=- file –&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限</p>\n </li>\n</ul>\n\n<h2 id=\"四-查找文件\">四. 查找文件</h2>\n\n<h3 id=\"1-locate\">1. locate</h3>\n\n<p>搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。</p>\n\n<h4 id=\"安装-locate\">安装 locate</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>yum -y install mlocate --&gt; 安装包\nupdatedb --&gt; 更新数据库\nlocate file.txt\nlocate fil*.txt\n</code></pre>  </div></div>\n\n<p>[注意] <code class=\"language-plaintext highlighter-rouge\">locate</code> 命令会去文件数据库中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 <code class=\"language-plaintext highlighter-rouge\">updatedb</code> 命令去更新数据库。</p>\n\n<h3 id=\"2-find\">2. find</h3>\n\n<p>用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;\n</code></pre>  </div></div>\n\n<ul>\n <li><strong>「何处」</strong>：指定在哪个目录查找，此目录的所有子目录也会被查找。</li>\n <li><strong>「何物」</strong>：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。</li>\n <li><strong>「做什么」</strong>：找到文件后，可以进行后续处理，如果不指定这个参数， <code class=\"language-plaintext highlighter-rouge\">find</code> 命令只会显示找到的文件。</li>\n</ul>\n\n<h4 id=\"根据文件名查找\">根据文件名查找</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find -name \"file.txt\" --&gt; 当前目录以及子目录下通过名称查找文件\nfind . -name \"syslog\" --&gt; 当前目录以及子目录下通过名称查找文件\nfind / -name \"syslog\" --&gt; 整个硬盘下查找syslog\nfind /var/log -name \"syslog\" --&gt; 在指定的目录/var/log下查找syslog文件\nfind /var/log -name \"syslog*\" --&gt; 查找syslog1、syslog2 ... 等文件，通配符表示所有\nfind /var/log -name \"*syslog*\" --&gt; 查找包含syslog的文件\n</code></pre>  </div></div>\n\n<p>[注意] <code class=\"language-plaintext highlighter-rouge\">find</code> 命令只会查找完全符合 “何物” 字符串的文件，而 <code class=\"language-plaintext highlighter-rouge\">locate</code> 会查找所有包含关键字的文件。</p>\n\n<h4 id=\"根据文件大小查找\">根据文件大小查找</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find /var -size +10M --&gt; /var 目录下查找文件大小超过 10M 的文件\nfind /var -size -50k --&gt; /var 目录下查找文件大小小于 50k 的文件\nfind /var -size +1G --&gt; /var 目录下查找文件大小查过 1G 的文件\nfind /var -size 1M --&gt; /var 目录下查找文件大小等于 1M 的文件\n</code></pre>  </div></div>\n\n<h4 id=\"根据文件最近访问时间查找\">根据文件最近访问时间查找</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find -name \"*.txt\" -atime -7  --&gt; 近 7天内访问过的.txt结尾的文件\n</code></pre>  </div></div>\n\n<h4 id=\"仅查找目录或文件\">仅查找目录或文件</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find . -name \"file\" -type f  --&gt; 只查找当前目录下的file文件\nfind . -name \"file\" -type d  --&gt; 只查找当前目录下的file目录\n</code></pre>  </div></div>\n\n<h4 id=\"操作查找结果\">操作查找结果</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>find -name \"*.txt\" -printf \"%p - %u\\n\" --&gt; 找出所有后缀为txt的文件，并按照 %p - %u\\n 格式打印，其中%p=文件名，%u=文件所有者\nfind -name \"*.jpg\" -delete --&gt; 删除当前目录以及子目录下所有.jpg为后缀的文件，不会有删除提示，因此要慎用\nfind -name \"*.c\" -exec chmod 600 {} \\; --&gt; 对每个.c结尾的文件，都进行 -exec 参数指定的操作，{} 会被查找到的文件替代，\\; 是必须的结尾\nfind -name \"*.c\" -ok chmod 600 {} \\; --&gt; 和上面的功能一直，会多一个确认提示\n</code></pre>  </div></div>\n\n<h2 id=\"五-软件仓库\">五. 软件仓库</h2>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Linux</code> 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。 <code class=\"language-plaintext highlighter-rouge\">Red Hat</code> 家族的软件包后缀名一般为 <code class=\"language-plaintext highlighter-rouge\">.rpm</code> ， <code class=\"language-plaintext highlighter-rouge\">Debian</code> 家族的软件包后缀是 <code class=\"language-plaintext highlighter-rouge\">.deb</code> 。</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Linux</code> 的包都存在一个仓库，叫做软件仓库，它可以使用 <code class=\"language-plaintext highlighter-rouge\">yum</code> 来管理软件包， <code class=\"language-plaintext highlighter-rouge\">yum</code> 是 <code class=\"language-plaintext highlighter-rouge\">CentOS</code> 中默认的包管理工具，适用于 <code class=\"language-plaintext highlighter-rouge\">Red Hat</code> 一族。可以理解成 <code class=\"language-plaintext highlighter-rouge\">Node.js</code> 的 <code class=\"language-plaintext highlighter-rouge\">npm</code> 。</p>\n\n<h3 id=\"1-yum-常用命令\">1. yum 常用命令</h3>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">yum update | yum upgrade</code> 更新软件包</li>\n <li><code class=\"language-plaintext highlighter-rouge\">yum search xxx</code> 搜索相应的软件包</li>\n <li><code class=\"language-plaintext highlighter-rouge\">yum install xxx</code> 安装软件包</li>\n <li><code class=\"language-plaintext highlighter-rouge\">yum remove xxx</code> 删除软件包</li>\n</ul>\n\n<h3 id=\"2-切换-centos-软件源\">2. 切换 CentOS 软件源</h3>\n\n<p>有时候 <code class=\"language-plaintext highlighter-rouge\">CentOS</code> 默认的 <code class=\"language-plaintext highlighter-rouge\">yum</code> 源不一定是国内镜像，导致 <code class=\"language-plaintext highlighter-rouge\">yum</code> 在线安装及更新速度不是很理想。这时候需要将 <code class=\"language-plaintext highlighter-rouge\">yum</code> 源设置为国内镜像站点。国内主要开源的镜像站点是网易和阿里云。</p>\n\n<p>1、首先备份系统自带 <code class=\"language-plaintext highlighter-rouge\">yum</code> 源配置文件 <code class=\"language-plaintext highlighter-rouge\">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></p>\n\n<p>2、下载阿里云的 <code class=\"language-plaintext highlighter-rouge\">yum</code> 源配置文件到 <code class=\"language-plaintext highlighter-rouge\">/etc/yum.repos.d/CentOS7</code></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\n</code></pre>  </div></div>\n\n<p>3、生成缓存</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>yum makecache\n</code></pre>  </div></div>\n\n<h2 id=\"六-阅读手册\">六. 阅读手册</h2>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Linux</code> 命令种类繁杂，我们凭借记忆不可能全部记住，因此学会查用手册是非常重要的。</p>\n\n<h3 id=\"1-man\">1. man</h3>\n\n<h4 id=\"安装更新-man\">安装更新 man</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo yum install -y man-pages --&gt; 安装\nsudo mandb --&gt; 更新\n</code></pre>  </div></div>\n\n<h4 id=\"man-手册种类\">man 手册种类</h4>\n\n<ol>\n <li>可执行程序或 <code class=\"language-plaintext highlighter-rouge\">Shell</code> 命令；</li>\n <li>系统调用（ <code class=\"language-plaintext highlighter-rouge\">Linux</code> 内核提供的函数）；</li>\n <li>库调用（程序库中的函数）；</li>\n <li>文件（例如 <code class=\"language-plaintext highlighter-rouge\">/etc/passwd</code> ）；</li>\n <li>特殊文件（通常在 <code class=\"language-plaintext highlighter-rouge\">/dev</code> 下）；</li>\n <li>游戏；</li>\n <li>杂项（ <code class=\"language-plaintext highlighter-rouge\">man(7)</code> ，<code class=\"language-plaintext highlighter-rouge\">groff(7)</code> ）；</li>\n <li>系统管理命令（通常只能被 <code class=\"language-plaintext highlighter-rouge\">root</code> 用户使用）；</li>\n <li>内核子程序。</li>\n</ol>\n\n<h4 id=\"man--数字--命令\">man + 数字 + 命令</h4>\n\n<p>输入 man + 数字 + 命令/函数，可以查到相关的命令和函数，若不加数字， <code class=\"language-plaintext highlighter-rouge\">man</code> 默认从数字较小的手册中寻找相关命令和函数</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>man 3 rand  --&gt; 表示在手册的第三部分查找 rand 函数\nman ls    --&gt; 查找 ls 用法手册\n</code></pre>  </div></div>\n\n<p>man 手册核心区域解析：(以 <code class=\"language-plaintext highlighter-rouge\">man pwd</code> 为例)</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NAME # 命令名称和简单描述\n     pwd -- return working directory name\n \nSYNOPSIS # 使用此命令的所有方法\n     pwd [-L | -P]\n \nDESCRIPTION # 包括所有参数以及用法\n     The pwd utility writes the absolute pathname of the current working directory to the standard output.\n \n     Some shells may provide a builtin pwd command which is similar or identical to this utility.  Consult the builtin(1) manual page.\n \n     The options are as follows:\n \n     -L      Display the logical current working directory.\n \n     -P      Display the physical current working directory (all symbolic links resolved).\n \n     If no options are specified, the -L option is assumed.\n \nSEE ALSO # 扩展阅读相关命令\n     builtin(1), cd(1), csh(1), sh(1), getcwd(3)\n</code></pre>  </div></div>\n\n<h3 id=\"2-help\">2. help</h3>\n\n<p><code class=\"language-plaintext highlighter-rouge\">man</code> 命令像新华词典一样可以查询到命令或函数的详细信息，但其实我们还有更加快捷的方式去查询， <code class=\"language-plaintext highlighter-rouge\">command --help</code> 或 <code class=\"language-plaintext highlighter-rouge\">command -h</code> ，它没有 <code class=\"language-plaintext highlighter-rouge\">man</code> 命令显示的那么详细，但是它更加易于阅读。</p>\n","dir":"/blog/development/os/linux/","name":"2023-05-17_2.md","path":"blog/development/os/linux/2023-05-17_2.md","url":"/blog/development/os/linux/2023-05-17_2.html"},{"sort":1,"layout":"default","title":"EASYEXCEL使用详解","content":"<h1 id=\"easyexcel使用详解\">EASYEXCEL使用详解</h1>\n\n<h2 id=\"一-easyexcel导出\">一. EASYEXCEL导出</h2>\n<p>两种方式RESPONSE返回文件流下载和保存到服务器返回下载链接</p>\n\n<h3 id=\"1-response方式返回excel文件流\">1. response方式返回excel文件流</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>\t@GetMapping(\"/exportExcel\")\n    public void exportExcel(@RequestParam(value = \"menu\") String menu,\n                            @RequestParam(value = \"dwflglId\") int dwflglId,\n                            @RequestParam(value = \"qjCode\") String qjCode,\n                            HttpServletResponse response) throws IOException { //内容集合\n        List&lt;ZjlrysIndexView&gt; jthz = getJthz(dwflglId, qjCode); //表头集合\n        List&lt;ZjlrysTableHead&gt; header = getHeaderOfHz(dwflglId, qjCode);\n        response.setHeader(\"Content-Disposition\", \"attachment; filename=Zjlryshz.xlsx\"); // 响应类型,编码\n        response.setContentType(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n        String bigTitle = \"资金流入预算表\";\n        EasyExcel.write(response.getOutputStream()).head(getExcelHeader(header, bigTitle)).registerWriteHandler(new Custemhandler()).sheet(\"资金流入预算导出模板\").doWrite(getExportData(jthz));\n    }\n</code></pre>  </div></div>\n\n<h3 id=\"2-通过在服务器中生成excel临时文件返回下载链接给前端下载\">2. 通过在服务器中生成excel临时文件，返回下载链接给前端下载</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// 获取当前时间\nString updTm = DateUtil.getAllTime(); //filePath为服务器存放临时文件的路径，本地开发环境的时候先可以用本地电脑的路径，比如c:users/，这里加上时间是因为不想被覆盖，也可以加uuid之类的\nFileOutputStream fileOutputStream = new FileOutputStream(filePath + \"xx导出模板\" + updTm + \".xlsx\");\n\nEasyExcel.write(fileOutputStream).head(getDownLoadExcelHead())\n        .registerWriteHandler(new CustomSheetWriteHandler(map)).registerWriteHandler(new Custemhandler())\n        .sheet(\"数据字典导出模板\").doWrite(downLoadExcelData); //url_prefix为服务器的域名之类的下载路径\nString url = url_prefix + \"xx导出模板\" + updTm + \".xlsx\"; /* \\* try {\n \\* \n \\* // 若不进行编码在IE下会乱码\n \\* \n \\* url = URLEncoder.encode(url, \"UTF-8\");\n \\* \n \\* } catch (UnsupportedEncodingException e) {\n \\* \n \\* e.printStackTrace();\n \\* \n \\* } */    \n</code></pre>  </div></div>\n<h3 id=\"3-以流的形式上传到服务器\">3. 以流的形式上传到服务器</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>//创建流\nByteArrayOutputStream bos=new ByteArrayOutputStream();\n//生成easyexcel的流\nEasyExcel.write(bos).head(getHead()).sheet(sheetName).doWrite(getData());\n//然后把bos上传到服务器,这里我是写了上传工具类，返回下载链接\nString path=OssClientUtil.upload(fileName,bos.toByteArray());\n</code></pre>  </div></div>\n\n","dir":"/blog/development/java/tool/","name":"2023-05-12_1.md","path":"blog/development/java/tool/2023-05-12_1.md","url":"/blog/development/java/tool/2023-05-12_1.html"},{"sort":1,"permalink":"/blog/development/java/jottings/","layout":"default","title":"随笔","content":"<h1 id=\"随笔\">随笔</h1>\n\n<ul>\n <li><a href=\"/blog/development/java/jottings/2023-04-23_1.html\">Java学习大纲路径</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_1.html\">Spring中的事务回滚机制</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_2.html\">Java开发环境安装配置JDK+Maven+Tomcat</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-05-12_1.html\">Restful风格开发方式</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-05-18_1.html\">Java8 新特性全面介绍</a></li>\n</ul>\n","dir":"/blog/development/java/jottings/","name":"README.md","path":"blog/development/java/jottings/README.md","url":"/blog/development/java/jottings/"},{"sort":1,"permalink":"/blog/","layout":"default","title":"JustMyFreedom","content":"<h1 id=\"justmyfreedom\">JustMyFreedom</h1>\n\n<p>JustMyFreedom……</p>\n\n<p>自由的探索这个世界。</p>\n\n<p>这是一个专注于技术分享和前沿科技、实时新闻的网站，记录我们所感兴趣的事件，顺便为大家提供高质量、有价值的内容。</p>\n\n<p>首页，是一个简约、无广告的导航页。相信大家来到<a href=\"https://justmyfreedom.com/\">JustMyFreedom</a>网站是为了获取有用的信息，而不是被无尽的广告所干扰。因此，我们在设计上采用了极简主义的风格，以保证大家能够专注于他们所需的内容。</p>\n\n<p>如果你想查看我们的博客内容，只需点击右上角的Blog图标即可。在我们的博客页，我们会定期分享最新的技术趋势、前沿科技的新闻、以及实时的资讯。通过我们的博客，你可以了解到最新的科技发展动态，以及一些实用的技术教程。</p>\n\n<p>总之，JustMyFreedom致力于为大家提供最新的科技资讯和有价值的技术分享。我们的网站旨在成为一个全方位的科技资讯平台，为你提供一个可以深入了解科技前沿的场所。我们相信，通过我们的努力，我们可以帮助大家更好地了解世界的变化，以及如何更好地应对这些变化。</p>\n\n<p>网站正在持续建设中……</p>\n\n<p>如果有任何建议或疑问，可以在下方的公众号或邮箱中给出建议！</p>\n\n<!-- \n- [前沿](/blog/frontier/)\n - [推荐](/blog/frontier/recommend/)\n - [Just My Socks 介绍，Just My Socks 是什么？](/blog/frontier/recommend/2023-04-23_1.html)\n - [推荐几款好用的自用软件](/blog/frontier/recommend/2023-04-27_1.html)\n - [新闻](/blog/frontier/new/)\n - [科技](/blog/frontier/new/technology/)\n - [ChatGpt](/blog/frontier/new/technology/2023-04-23_1.html)\n - [生活](/blog/frontier/new/life/)\n - [2023年计划考试时间(全年)](/blog/frontier/new/life/2023-04-23_1.html)\n- [开发技术](/blog/development/)\n - [面试宝典](/blog/development/interview/)\n - [Java面试题](/blog/development/interview/java/)\n - [Java面试宝典一(2023最新Java面试题)](/blog/development/interview/java/2023-04-23_1.html)\n - [Java面试宝典二(2023最新Java面试题)](/blog/development/interview/java/2023-04-23_2.html)\n - [Java面试宝典三(2023最新Java面试题)](/blog/development/interview/java/2023-04-23_3.html)\n - [Java面试宝典四(2023最新Java面试题)](/blog/development/interview/java/2023-04-23_4.html)\n - [前端笔记](/blog/development/html/)\n - [随笔](/blog/development/html/jottings/)\n - [html页面如何设置适配移动端](/blog/development/html/jottings/2023-04-21_1.html)\n - [HTML页面中返回顶部的几种实现](/blog/development/html/jottings/2023-04-27_1.html)\n - [html表格导出excel有几种方式](/blog/development/html/jottings/2023-05-12_1.html)\n - [laydate渲染日期](/blog/development/html/jottings/2023-05-12_2.html)\n - [Html中CSS和JavaScript 文件添加版本号有哪些方式](/blog/development/html/jottings/2023-05-17_1.html)\n - [Jekyll网站开发](/blog/development/html/webdesign/)\n - [Jekyll安装配置和使用](/blog/development/html/webdesign/2023-04-24_1.html)\n - [七牛云对象存储(图床)免费使用](/blog/development/html/webdesign/2023-04-24_2.html)\n - [免费的Jekyll静态网站发布平台](/blog/development/html/webdesign/2023-05-12_1.html)\n - [SEO优化](/blog/development/html/seo/)\n - [NGINX强制使用https访问(http跳转到https)](/blog/development/html/seo/2023-04-27_1.html)\n - [最新主流搜索引擎提交sitemap大全（网站地图）](/blog/development/html/seo/2023-04-27_2.html)\n - [SEO实操小技巧关键字](/blog/development/html/seo/2023-04-27_3.html)\n - [Java语言](/blog/development/java/)\n - [随笔](/blog/development/java/jottings/)\n - [Java学习大纲路径](/blog/development/java/jottings/2023-04-23_1.html)\n - [Spring中的事务回滚机制](/blog/development/java/jottings/2023-04-27_1.html)\n - [Java开发环境安装配置JDK+Maven+Tomcat](/blog/development/java/jottings/2023-04-27_2.html)\n - [Restful风格开发方式](/blog/development/java/jottings/2023-05-12_1.html)\n - [Java8 新特性全面介绍](/blog/development/java/jottings/2023-05-18_1.html)\n - [Java基础](/blog/development/java/basics/)\n - [Java中map常见操作集合](/blog/development/java/basics/2023-04-24_1.html)\n - [Java中Json转换的常见操作方式](/blog/development/java/basics/2023-04-24_2.html)\n - [Java中计算List求和或List对象中某个字段的总和](/blog/development/java/basics/2023-04-24_3.html)\n - [Java中BigDecimal类型详解](/blog/development/java/basics/2023-04-27_1.html)\n - [Java框架](/blog/development/java/framework/)\n - [Spring Framework](/blog/development/java/framework/spring/)\n - [Spring IOC 容器](/blog/development/java/framework/spring/2023-05-18_1.html)\n - [Spring AOP使用](/blog/development/java/framework/spring/2023-05-18_2.html)\n - [Spring 访问数据库](/blog/development/java/framework/spring/2023-05-18_3.html)\n - [Spring 开发Web应用](/blog/development/java/framework/spring/2023-05-18_4.html)\n - [Spring 集成第三方组件](/blog/development/java/framework/spring/2023-05-18_5.html)\n - [工具包](/blog/development/java/tool/)\n - [EASYEXCEL使用详解](/blog/development/java/tool/2023-05-12_1.html)\n - [Python笔记](/blog/development/python/)\n - [随笔](/blog/development/python/jottings/)\n - [Django](/blog/development/python/django/)\n - [Django中url与path及re_path区别](/blog/development/python/django/2023-04-27_1.html)\n - [操作系统](/blog/development/os/)\n - [linux](/blog/development/os/linux/)\n - [Linux命令大全(Linux常用命令基础)](/blog/development/os/linux/2023-05-17_2.html)\n - [Linux命令大全(Linux常用命令进阶)](/blog/development/os/linux/2023-05-17_3.html)\n - [Linux的上传和下载功能](/blog/development/os/linux/2023-04-23_1.html)\n - [Centos防火墙配置](/blog/development/os/linux/2023-05-17_1.html)\n - [windows](/blog/development/os/windows/)\n - [Windows端口常见问题解决](/blog/development/os/windows/2023-04-27_1.html)\n - [Windows常用小技巧](/blog/development/os/windows/2023-05-17_1.html)\n - [工具](/blog/development/tool/)\n - [Redis](/blog/development/tool/redis/)\n - [Windows部署redis集群模式](/blog/development/tool/redis/2023-04-30_1.html)\n - [redis如何设置密码](/blog/development/tool/redis/2023-04-30_2.html)\n - [Git](/blog/development/tool/git/)\n - [最新Github创建仓库,将项目上传到GitHub](/blog/development/tool/git/2023-04-27_1.html)\n - [Git一份代码同时提交两个Git仓库](/blog/development/tool/git/2023-04-28_1.html)\n - [Git常用操作命令](/blog/development/tool/git/2023-05-12_1.html)\n - [Maven](/blog/development/tool/maven/)\n - [Maven推送本地jar包到仓库](/blog/development/tool/maven/2023-04-27_1.html)\n - [开发工具](/blog/development/tool/software/)\n - [软件开发者常用的工具有哪些(软件开发工具)？](/blog/development/tool/software/2023-05-17_1.html)\n - [Idea-Intellij IDEA常用功能及功能优化设置](/blog/development/tool/software/2023-05-17_2.html)\n - [Visual Studio Code常用功能及功能优化设置](/blog/development/tool/software/2023-05-17_3.html)\n- [人生](/blog/life/)\n - [趣事小记](/blog/life/travel/)\n- [典籍](/blog/ancientBooks/)\n - [诗经](/blog/ancientBooks/shiJing/)\n - [唐诗](/blog/ancientBooks/tangShi/)\n- [宗教](/blog/religion/)\n - [道教](/blog/religion/taoism/)\n- [关于](/blog/about/)\n - [网站](/blog/about/website/)\n - [关于Justmyfreedom网站](/blog/about/website/2023-04-23_1.html) -->\n","dir":"/blog/","name":"README.md","path":"blog/README.md","url":"/blog/"},{"sort":1,"layout":"default","title":"Spring IOC 容器","content":"<h1 id=\"spring-ioc-容器\">Spring IOC 容器</h1>\n\n<p>在学习 Spring 框架时，我们遇到的第一个也是最核心的概念就是容器。</p>\n\n<p>什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat 就是一个 Servlet 容器，它可以为 Servlet 的运行提供运行环境。类似 Docker 这样的软件也是一个容器，它提供了必要的 Linux 环境以便运行一个特定的 Linux 进程。</p>\n\n<p>通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet 容器底层实现了 TCP 连接，解析 HTTP 协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像 Servlet 这样代码简单，功能强大的组件。早期的 JavaEE 服务器提供的 EJB 容器最重要的功能就是通过声明式事务服务，使得 EJB 组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。</p>\n\n<p>Spring 的核心就是提供了一个 IoC 容器，它可以管理所有轻量级的 JavaBean 组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP 支持，以及建立在 AOP 基础上的声明式事务服务等。</p>\n\n<p>这里主要介绍 Spring 容器如何对组件进行生命周期管理和配置组装服务。</p>\n\n<h2 id=\"一-ioc-原理\">一. IOC 原理</h2>\n\n<p>Spring IOC（Inversion of Control，控制反转）容器的原理是基于依赖注入（Dependency Injection，DI）的设计模式。它通过将对象的创建和依赖关系的管理交给容器来实现控制反转。</p>\n\n<h3 id=\"1-为什么使用-ioc\">1. 为什么使用 IOC</h3>\n\n<p>在没有使用 Spring IOC 容器的情况下，Java 组件可以通过手动管理对象的实例化和依赖关系来协作。</p>\n\n<p>以下是一个简单的示例：假设我们有两个类：UserService 和 UserRepository。UserService 需要依赖 UserRepository 来执行数据库操作。</p>\n\n<p><strong>第一步：</strong>定义接口和实现类：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public interface UserRepository {\n    void save(User user);\n}\n\npublic class UserRepositoryImpl implements UserRepository {\n    public void save(User user) {\n        // 实现保存用户到数据库的逻辑\n    }\n}\n\npublic class UserService {\n    private UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public void saveUser(User user) {\n        userRepository.save(user);\n    }\n}\n</code></pre>  </div></div>\n\n<p><strong>第二步：</strong>手动实例化和注入依赖：\n在应用程序中，我们需要手动创建 UserService 和 UserRepository 的实例，并将 UserRepository 的实例注入到 UserService 中。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class MyApp {\n    public static void main(String[] args) {\n        UserRepository userRepository = new UserRepositoryImpl();\n        UserService userService = new UserService(userRepository);\n\n        // 使用userService进行操作\n    }\n}\n</code></pre>  </div></div>\n\n<p>在上面的示例中，我们手动创建了 UserRepositoryImpl 的实例，并将其作为参数传递给 UserService 的构造函数来实例化 UserService。这样，我们手动管理了对象的实例化和依赖关系。</p>\n\n<p>需要注意的是，没有使用 IOC 容器的情况下，对象的实例化和依赖注入需要由开发者自行处理。这会导致代码的耦合度增加，并且在对象依赖关系复杂或需要更改时，需要手动修改代码。相比之下，使用 Spring IOC 容器可以更好地解耦对象之间的关系，提高代码的可维护性和灵活性。</p>\n\n<p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，上述示例中，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p>\n\n<p>在 IoC 模式下，控制权发生了反转，即从应用程序转移到了 IoC 容器，所有组件不再由应用程序自己创建和配置，而是由 IoC 容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。</p>\n\n<h3 id=\"2-ioc-使用\">2 IOC 使用</h3>\n\n<p>IOC 的原理是通过依赖注入（Dependency Injection，DI）实现的。依赖注入是指将对象的依赖关系从代码中移动到外部容器中，并通过容器将依赖注入到对象中。</p>\n\n<h4 id=\"21-ioc-使用示例\">2.1 IOC 使用示例</h4>\n\n<p>示例：假设我们有一个简单的应用程序，其中包含两个类：UserService 和 UserRepository。UserService 需要依赖 UserRepository 来执行数据库操作。</p>\n\n<p><strong>第一步：</strong>定义接口和实现类：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public interface UserRepository {\n    void save(User user);\n}\n\npublic class UserRepositoryImpl implements UserRepository {\n    public void save(User user) {\n        // 实现保存用户到数据库的逻辑\n    }\n}\n\npublic class UserService {\n    private UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public void saveUser(User user) {\n        userRepository.save(user);\n    }\n}\n\n</code></pre>  </div></div>\n\n<p><strong>第二步：</strong>使用 Spring IOC 容器进行依赖注入：\n在 Spring 中，我们可以通过 XML 配置或注解来定义对象之间的依赖关系。</p>\n\n<p>XML 配置示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;bean id=\"userRepository\" class=\"com.example.UserRepositoryImpl\" /&gt;\n\n&lt;bean id=\"userService\" class=\"com.example.UserService\"&gt;\n    &lt;constructor-arg ref=\"userRepository\" /&gt;\n&lt;/bean&gt;\n</code></pre>  </div></div>\n\n<p>注解配置示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Repository\npublic class UserRepositoryImpl implements UserRepository {\n    // 实现代码\n}\n\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n\n    @Autowired\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    // 方法代码\n}\n</code></pre>  </div></div>\n\n<p><strong>第三步：</strong>使用 IOC 容器获取 UserService 实例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class MyApp {\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserService userService = context.getBean(\"userService\", UserService.class);\n        // 使用userService进行操作\n    }\n}\n</code></pre>  </div></div>\n\n<p>在上面的示例中，我们通过 Spring IOC 容器实现了对 UserService 和 UserRepository 的依赖注入。在应用程序启动时，IOC 容器会负责创建 UserService 和 UserRepository 的实例，并将 UserRepository 的实例注入到 UserService 中。开发者无需手动实例化对象或管理对象之间的依赖关系，从而实现了控制反转和解耦。</p>\n\n<h4 id=\"22-ioc-容器中-javabean-的配置方式\">2.2 IOC 容器中 JavaBean 的配置方式</h4>\n\n<p>在 Spring IOC 容器中，可以使用不同的配置方式来定义和配置 JavaBean。以下是几种常用的配置方式：</p>\n\n<p><strong>方式一：XML 配置方式：</strong>使用 XML 文件来配置 JavaBean。可以通过<bean>元素来定义和配置 JavaBean 的属性、依赖关系等。示例：</bean></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;bean id=\"userService\" class=\"com.example.UserService\"&gt;\n    &lt;property name=\"userRepository\" ref=\"userRepository\" /&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"userRepository\" class=\"com.example.UserRepositoryImpl\" /&gt;\n</code></pre>  </div></div>\n\n<p><strong>方式二：注解配置方式：</strong>使用注解来标识 JavaBean，并由容器自动进行扫描和注册。可以使用注解如@Component、@Service、@Repository、@Controller 等来标识 JavaBean，并使用@Autowired、@Resource 等注解来注入依赖。示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}\n\n@Component\npublic class UserRepositoryImpl implements UserRepository {\n    // 实现代码\n}\n</code></pre>  </div></div>\n\n<p><strong>方式三：Java 配置方式：</strong>使用 Java 类来配置 JavaBean。可以通过 Java 类中的特定方法来定义和配置 JavaBean，并使用 Spring 提供的注解如@Configuration、@Bean 等来标识和配置 JavaBean。示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Configuration\npublic class AppConfig {\n    @Bean\n    public UserService userService() {\n        UserService userService = new UserService();\n        userService.setUserRepository(userRepository());\n        return userService;\n    }\n\n    @Bean\n    public UserRepository userRepository() {\n        return new UserRepositoryImpl();\n    }\n}\n</code></pre>  </div></div>\n\n<p>需要注意的是，以上的配置方式可以单独使用，也可以组合使用。例如，在 XML 配置中可以引用注解配置的 JavaBean，或在 Java 配置中引用 XML 配置的 JavaBean。</p>\n\n<p>无论使用哪种配置方式，Spring IOC 容器都会根据配置信息来实例化 JavaBean，并管理它们的生命周期和依赖关系。</p>\n\n<h4 id=\"23-依赖注入方式\">2.3 依赖注入方式</h4>\n\n<p><strong>方式一：构造函数注入（Constructor Injection）：</strong>通过构造函数来注入依赖。在对象实例化时，容器会调用带有依赖参数的构造函数来创建对象，并将依赖对象作为参数传递进去。\n示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class UserService {\n    private UserRepository userRepository;\n\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n</code></pre>  </div></div>\n\n<p><strong>方式二：属性注入（Setter Injection）：</strong>通过属性的 Setter 方法来注入依赖。容器在对象实例化后，通过调用对象的 Setter 方法来设置依赖对象。\n示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class UserService {\n    private UserRepository userRepository;\n\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}\n</code></pre>  </div></div>\n\n<p><strong>方式三：接口注入（Interface Injection）：</strong>通过特定的接口方法来注入依赖。通常使用 Java 提供的 InitializingBean 接口或 Spring 提供的@PostConstruct 注解来定义初始化方法，在该方法中进行依赖注入。\n示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class UserService implements InitializingBean {\n    private UserRepository userRepository;\n\n    public void afterPropertiesSet() throws Exception {\n        // 在该方法中进行依赖注入\n    }\n}\n</code></pre>  </div></div>\n\n<p><strong>方式四：注解注入（Annotation Injection）：</strong>通过使用注解来标记依赖关系，并由容器自动完成注入。Spring 提供了多个注解，如@Autowired、@Inject、@Resource 等，用于标识依赖关系。\n示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}\n</code></pre>  </div></div>\n\n<p>需要注意的是，以上的依赖注入方式可以单独使用，也可以组合使用，根据具体的场景和需求选择适合的方式。此外，Spring IOC 容器还支持通过配置文件（如 XML 配置）来进行依赖注入。在配置文件中，可以通过<property>元素来设置属性的值，或使用<constructor-arg>元素来设置构造函数参数的值。</constructor-arg></property></p>\n\n<h3 id=\"3-无侵入容器\">3. 无侵入容器</h3>\n\n<p>在设计上，Spring 的 IoC 容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现 Spring 的特定接口，或者说，组件根本不知道自己在 Spring 的容器中运行。这种无侵入的设计有以下好处：</p>\n\n<p><strong>解耦：</strong>IOC 容器负责管理对象的创建和依赖注入，将对象之间的关系从代码中解耦。开发者只需声明对象的依赖关系，而不需要手动实例化对象或管理对象之间的依赖关系，从而降低了代码的耦合度。</p>\n\n<p><strong>可测试性：</strong>IOC 使得应用程序中的对象更易于测试。由于对象的依赖关系由 IOC 容器管理，开发者可以通过模拟依赖对象来进行单元测试，而无需关注对象的实例化和依赖注入。</p>\n\n<p><strong>可维护性：</strong>通过使用 IOC 容器，应用程序的配置信息集中在一个地方，易于维护和修改。开发者可以通过简单的配置文件或注解来管理对象的依赖关系，而无需修改源代码。</p>\n\n<p><strong>灵活性：</strong>IOC 容器使得应用程序更加灵活，可以在运行时动态地替换对象的实现或配置。开发者可以通过更改配置信息，实现不同的对象组合或切换不同的实现，而无需修改代码。</p>\n\n<h2 id=\"二-装配-bean-xml-配置方式\">二. 装配 Bean-XML 配置方式</h2>\n\n<h3 id=\"1-使用方式\">1. 使用方式</h3>\n\n<p>来看一个具体的使用 xml 配置方式的用户注册和登录示例</p>\n\n<p>整个工程的结构如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring-ioc-appcontext\n├── pom.xml\n└── src\n    └── main\n        ├── java\n        │   └── com\n        │       └── justmyfreedom\n        │           └── zhongnan\n        │               ├── MainApp.java\n\t\t│               ├── UserService.java\n\t\t│               ├── entity\n\t\t│               │   └── User.java\n        │               └── service\n\t\t│                   ├── UserRepository.java\n\t\t│                   └── impl\n\t\t│                   \t└── UserRepositoryImpl.java\n        └── resources\n            └── application.xml\n</code></pre>  </div></div>\n\n<h4 id=\"11-创建工程\">1.1 创建工程</h4>\n\n<p>首先，我们用 Maven 创建工程并引入 spring-context 依赖。</p>\n\n<h4 id=\"12-创建接口和实现类\">1.2 创建接口和实现类</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public interface UserRepository {\n    void saveUser(User user);\n    User getUser(String username);\n}\n\npublic class UserRepositoryImpl implements UserRepository {\n    private Map&lt;String, User&gt; users = new HashMap&lt;&gt;();\n\n    public void saveUser(User user) {\n        users.put(user.getUsername(), user);\n    }\n\n    public User getUser(String username) {\n        return users.get(username);\n    }\n}\n\npublic class User {\n    private String username;\n    private String password;\n\n    // 省略构造函数和Getter/Setter方法\n}\n</code></pre>  </div></div>\n\n<h4 id=\"13-创建-spring-配置文件\">1.3 创建 Spring 配置文件</h4>\n\n<p>编写一个特定的 application.xml 配置文件，告诉 Spring 的 IoC 容器应该如何创建并组装,Beanapplication.xml：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n    &lt;!-- 配置UserRepository bean --&gt;\n    &lt;bean id=\"userRepository\" class=\"com.justmyfreedom.zhongnan.service.impl.UserRepositoryImpl\" /&gt;\n\n    &lt;!-- 配置UserService bean --&gt;\n    &lt;bean id=\"userService\" class=\"com.justmyfreedom.zhongnan.UserService\"&gt;\n        &lt;property name=\"userRepository\" ref=\"userRepository\" /&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre>  </div></div>\n\n<p>注意观察上述配置文件，其中与 XML Schema 相关的部分格式是固定的，我们只关注两个&lt;bean …&gt;的配置：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>每个&lt;bean ...&gt;都有一个id标识，相当于Bean的唯一ID；\n在userServiceBean中，通过&lt;property name=\"...\" ref=\"...\" /&gt;注入了另一个Bean；\nBean的顺序不重要，Spring根据依赖关系会自动正确初始化。\n</code></pre>  </div></div>\n\n<p>如果注入的不是 Bean，而是 boolean、int、String 这样的数据类型，则通过 value 注入，例如，创建一个 HikariDataSource：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;bean id=\"dataSource\" class=\"com.zaxxer.hikari.HikariDataSource\"&gt;\n    &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/test\" /&gt;\n    &lt;property name=\"username\" value=\"root\" /&gt;\n    &lt;property name=\"password\" value=\"password\" /&gt;\n    &lt;property name=\"maximumPoolSize\" value=\"10\" /&gt;\n    &lt;property name=\"autoCommit\" value=\"true\" /&gt;\n&lt;/bean&gt;\n</code></pre>  </div></div>\n\n<h4 id=\"14-编写业务类\">1.4 编写业务类</h4>\n\n<p>编写用户注册和登录的业务类 UserService：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class UserService {\n    private UserRepository userRepository;\n\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public void registerUser(User user) {\n        userRepository.saveUser(user);\n        System.out.println(\"用户注册成功！\");\n    }\n\n    public void loginUser(String username, String password) {\n        User user = userRepository.getUser(username);\n        if (user != null &amp;&amp; user.getPassword().equals(password)) {\n            System.out.println(\"用户登录成功！\");\n        } else {\n            System.out.println(\"用户名或密码错误！\");\n        }\n    }\n}\n</code></pre>  </div></div>\n\n<h4 id=\"15-编写主类\">1.5 编写主类</h4>\n\n<p>编写应用程序主类 MainApp：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class MainApp {\n    public static void main(String[] args) {\n\t\t//创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n\n\t\t// 获取Bean:\n        UserService userService = context.getBean(\"userService\", UserService.class);\n\n        // 用户注册\n        User user = new User(\"john\", \"password123\");\n\t\t// 正常调用Bean:\n        userService.registerUser(user);\n\n        // 用户登录\n        userService.loginUser(\"john\", \"password123\");\n    }\n}\n</code></pre>  </div></div>\n\n<p>在以上示例中，通过 XML 配置文件中的<bean>元素定义了 userRepository 和 userService 两个 bean，并使用<property>元素将 userRepository 注入到 userService 中。在应用程序主类中，通过加载 Spring 配置文件和获取 userService bean 实例来进行用户注册和登录操作。</property></bean></p>\n\n<p>通过以上示例，使用 Spring 的 XML 配置方式实现了用户注册和登录的功能，利用 Spring 的 IOC 容器进行依赖注入，简化了组件之间的配置和管理。</p>\n\n<h3 id=\"2-applicationcontext\">2. ApplicationContext</h3>\n\n<p>从创建 Spring 容器的代码：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ApplicationContext context = new ClassPathXmlApplicationContext(\"application.xml\");\n</code></pre>  </div></div>\n\n<p>可以看到，Spring 容器就是 ApplicationContext，它是一个接口，有很多实现类，这里我们选择 ClassPathXmlApplicationContext，表示它会自动从 classpath 中查找指定的 XML 配置文件。</p>\n\n<p>获得了 ApplicationContext 的实例，就获得了 IoC 容器的引用。从 ApplicationContext 中我们可以根据 Bean 的 ID 获取 Bean，但更多的时候我们根据 Bean 的类型获取 Bean 的引用：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>UserService userService = context.getBean(\"userService\", UserService.class);\n</code></pre>  </div></div>\n\n<p>Spring 还提供另一种 IoC 容器叫 BeanFactory，使用方式和 ApplicationContext 类似：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>BeanFactory factory = new XmlBeanFactory(new ClassPathResource(\"application.xml\"));\nUserService userService = factory.getBean(\"userService\", UserService.class);\n</code></pre>  </div></div>\n\n<p><strong>BeanFactory 和 ApplicationContext 的区别在于：</strong>BeanFactory 的实现是按需创建，即第一次获取 Bean 时才创建这个 Bean，而 ApplicationContext 会一次性创建所有的 Bean。实际上，ApplicationContext 接口是从 BeanFactory 接口继承而来的，并且，ApplicationContext 提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用 ApplicationContext，很少会考虑使用 BeanFactory。</p>\n\n<h2 id=\"三-装配-bean-annotation-配置\">三. 装配 Bean-Annotation 配置</h2>\n\n<p>Spring 的 IoC 容器，实际上就是通过类似 XML 这样的配置文件，把我们自己的 Bean 的依赖关系描述出来，然后让容器来创建并装配 Bean。一旦容器初始化完毕，我们就直接从容器中获取 Bean 使用它们。</p>\n\n<p>使用 XML 配置的优点是所有的 Bean 都能一目了然地列出来，并通过配置注入能直观地看到每个 Bean 的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的 Bean 配置到 XML 中。</p>\n\n<p>我们可以使用更简单的方式，Annotation 配置，可以完全不需要 XML，让 Spring 自动扫描 Bean 并组装它们。</p>\n\n<p>把上面的示例改造一下，先删除 application.xml 配置文件，然后注解标记的组件类：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\npublic class UserRepositoryImpl implements UserRepository {\n    private Map&lt;String, User&gt; users = new HashMap&lt;&gt;();\n\n    public void saveUser(User user) {\n        users.put(user.getUsername(), user);\n    }\n\n    public User getUser(String username) {\n        return users.get(username);\n    }\n}\n\n@Component\npublic class UserService {\n    private UserRepository userRepository;\n\n    @Autowired\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    public void registerUser(User user) {\n        userRepository.saveUser(user);\n        System.out.println(\"用户注册成功！\");\n    }\n\n    public void loginUser(String username, String password) {\n        User user = userRepository.getUser(username);\n        if (user != null &amp;&amp; user.getPassword().equals(password)) {\n            System.out.println(\"用户登录成功！\");\n        } else {\n            System.out.println(\"用户名或密码错误！\");\n        }\n    }\n}\n</code></pre>  </div></div>\n\n<p>更新应用程序主类 MainApp，不再需要显式配置 bean：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class MainApp {\n    public static void main(String[] args) {\n        ApplicationContext context = new AnnotationConfigApplicationContext(MainApp.class);\n        context.scan(\"com.justmyfreedom.zhongnan\"); // 扫描包路径下的组件\n\n        UserService userService = context.getBean(UserService.class);\n\n        // 用户注册\n        User user = new User(\"john\", \"password123\");\n        userService.registerUser(user);\n\n        // 用户登录\n        userService.loginUser(\"john\", \"password123\");\n\n        context.close();\n    }\n}\n</code></pre>  </div></div>\n\n<p>或者</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Configuration\n@ComponentScan\npublic class MainApp {\n    public static void main(String[] args) {\n        ApplicationContext context = new AnnotationConfigApplicationContext(MainApp.class);\n\n        UserService userService = context.getBean(UserService.class);\n\n        // 用户注册\n        User user = new User(\"john\", \"password123\");\n        userService.registerUser(user);\n\n        // 用户登录\n        userService.loginUser(\"john\", \"password123\");\n\n        context.close();\n    }\n}\n</code></pre>  </div></div>\n\n<p>MainApp 标注了@Configuration，表示它是一个配置类，因为我们创建 ApplicationContext 时：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ApplicationContext context = new AnnotationConfigApplicationContext(MainApp.class);\n</code></pre>  </div></div>\n\n<p>使用的实现类是 AnnotationConfigApplicationContext，必须传入一个标注了@Configuration 的类名。</p>\n\n<p>此外，AppConfig 还标注了@ComponentScan，它告诉容器，自动搜索当前类所在的包以及子包，把所有标注为@Component 的 Bean 自动创建出来，并根据@Autowired 进行装配。</p>\n\n<p>整个工程的结构如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring-ioc-appcontext\n├── pom.xml\n└── src\n    └── main\n        ├── java\n            └── com\n                └── justmyfreedom\n                    └── zhongnan\n                        ├── MainApp.java\n\t\t                ├── UserService.java\n\t\t                ├── entity\n\t\t                │   └── User.java\n                        └── service\n\t\t                    ├── UserRepository.java\n\t\t                    └── impl\n\t\t                    \t└── UserRepositoryImpl.java\n</code></pre>  </div></div>\n\n<p>使用 Annotation 配合自动扫描能大幅简化 Spring 的配置，我们只需要保证：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>每个Bean被标注为@Component并正确使用@Autowired注入；\n配置类被标注为@Configuration和@ComponentScan；\n所有Bean均在指定包以及子包内。\n</code></pre>  </div></div>\n\n<p>使用@ComponentScan 非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置 MainApp 位于自定义的顶层包（例如 com.justmyfreedom.zhongnan），其他 Bean 按类别放入子包。</p>\n\n<h2 id=\"四-自定义-bean\">四. 自定义 Bean</h2>\n\n<h3 id=\"1-spring-作用域-scope\">1. Spring 作用域 Scope</h3>\n\n<p>Scope（作用域）用于定义和管理 bean 的生命周期和实例化方式。Spring 提供了多种作用域，用于控制 bean 的创建和销毁方式，以及共享 bean 实例的范围。以下是几种常用的 Spring 作用域：</p>\n\n<p>对于 Spring 容器来说，当我们把一个 Bean 标记为@Component 后，它就会自动为我们创建一个单例（Singleton），即容器初始化时创建 Bean，容器关闭前销毁 Bean。在容器运行期间，我们调用 getBean(Class)获取到的 Bean 总是同一个实例。</p>\n\n<p>还有一种 Bean，我们每次调用 getBean(Class)，容器都返回一个新的实例，这种 Bean 称为 Prototype（原型），它的生命周期显然和 Singleton 不同。</p>\n\n<p>以下是几种常用的 Spring 作用域：</p>\n\n<h4 id=\"11-singleton默认\">1.1 Singleton（默认）</h4>\n\n<p>Singleton（默认）：在整个应用程序中，只会创建一个 bean 实例。每次请求获取该 bean 时，都返回同一个实例。在整个应用程序中，只会创建一个 bean 实例。每次请求获取该 bean 时，都返回同一个实例。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\n@Scope(\"singleton\")\npublic class MySingletonBean {\n    // Bean的定义和逻辑\n}\n</code></pre>  </div></div>\n\n<h4 id=\"12-prototype\">1.2 Prototype</h4>\n\n<p>Prototype：每次请求获取该 bean 时，都会创建一个新的实例。每个实例都是独立的，具有不同的状态。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\n@Scope(\"prototype\")\npublic class MyPrototypeBean {\n    // Bean的定义和逻辑\n}\n</code></pre>  </div></div>\n\n<h4 id=\"13-request\">1.3 Request</h4>\n\n<p>Request：每个 HTTP 请求都会创建一个新的 bean 实例。适用于 Web 应用程序，确保每个请求都使用独立的 bean 实例。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\n@Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class MyRequestBean {\n    // Bean的定义和逻辑\n}\n</code></pre>  </div></div>\n\n<h4 id=\"14-session\">1.4 Session</h4>\n\n<p>Session：每个 HTTP 会话（Session）期间只会创建一个 bean 实例。适用于 Web 应用程序，确保同一会话期间共享同一个 bean 实例。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\n@Scope(value = \"session\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class MySessionBean {\n    // Bean的定义和逻辑\n}\n</code></pre>  </div></div>\n\n<h4 id=\"15-global-session\">1.5 Global Session</h4>\n\n<p>Global Session：类似于 Session 作用域，但适用于 Portlet 应用程序，每个 Portlet 应用程序的全局会话期间只会创建一个 bean 实例。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\n@Scope(value = \"globalSession\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class MyGlobalSessionBean {\n    // Bean的定义和逻辑\n}\n</code></pre>  </div></div>\n\n<p>在上述示例中，使用@Scope 注解来指定 bean 的作用域。其中，proxyMode 属性用于处理作用域代理的方式。当在单例作用域的 bean 中注入原型作用域的 bean 时，需要使用 ScopedProxyMode.TARGET_CLASS 模式来进行作用域代理。</p>\n\n<p>通过使用不同的作用域，可以灵活地控制 bean 的生命周期和实例化方式，满足不同场景下的需求。开发者可以根据具体的业务需求选择合适的作用域来配置 bean。</p>\n\n<h3 id=\"2-注入-list\">2. 注入 List</h3>\n\n<p>有些时候，我们会有一系列接口相同，不同实现类的 Bean。需要将多个 bean 注入到一个列表中，可以使用<list>标签或@Autowired 注解结合 List 类型来实现。</list></p>\n\n<p>例如：例中，定义了 BeanInterface 接口，并创建了两个实现类 Bean1 和 Bean2。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public interface BeanInterface {\n    void doSomething();\n}\n\n@Component\npublic class Bean1 implements BeanInterface {\n    public void doSomething() {\n        System.out.println(\"Bean1 is doing something.\");\n    }\n}\n\n@Component\npublic class Bean2 implements BeanInterface {\n    public void doSomething() {\n        System.out.println(\"Bean2 is doing something.\");\n    }\n}\n</code></pre>  </div></div>\n\n<h4 id=\"21-使用-xml-配置方式注入\">2.1 使用 XML 配置方式注入</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;bean id=\"bean1\" class=\"com.example.Bean1\" /&gt;\n&lt;bean id=\"bean2\" class=\"com.example.Bean2\" /&gt;\n\n&lt;bean id=\"listBean\" class=\"com.example.ListBean\"&gt;\n    &lt;property name=\"beanList\"&gt;\n        &lt;list&gt;\n            &lt;ref bean=\"bean1\" /&gt;\n            &lt;ref bean=\"bean2\" /&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>  </div></div>\n\n<p>使用 XML 配置方式将 Bean1 和 Bean2 注入到 ListBean 的 beanList 属性中。</p>\n\n<h4 id=\"22-使用注解方式注入\">2.2 使用注解方式注入</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\npublic class ListBean {\n    @Autowired\n    private List&lt;BeanInterface&gt; beanList;\n\n    public void executeBeans() {\n        for (BeanInterface bean : beanList) {\n            bean.doSomething();\n        }\n    }\n}\n</code></pre>  </div></div>\n\n<p>使用注解方式在 ListBean 中使用@Autowired 注解将实现了 BeanInterface 接口的所有 bean 注入到 beanList 属性中。</p>\n\n<p>最后，在 ListBean 中，通过遍历 beanList，执行每个 bean 的 doSomething()方法。</p>\n\n<p>这样，当应用程序运行时，ListBean 中的 beanList 属性将包含所有实现了 BeanInterface 接口的 bean，并可以对它们进行操作。</p>\n\n<p>请注意，如果没有匹配的 bean，List 将为空列表（不为 null）。</p>\n\n<p>需要确保所有要注入到 List 中的 bean 都已经定义并配置为 Spring 的 bean。</p>\n\n<h4 id=\"23-注入顺序\">2.3 注入顺序</h4>\n\n<p>Spring 是通过扫描 classpath 获取到所有的 Bean，而 List 是有序的，要指定 List 中 Bean 的顺序，可以加上@Order 注解：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public interface BeanInterface {\n    void doSomething();\n}\n\n@Component\n@Order(1)\npublic class Bean1 implements BeanInterface {\n    public void doSomething() {\n        System.out.println(\"Bean1 is doing something.\");\n    }\n}\n\n@Component\n@Order(2)\npublic class Bean2 implements BeanInterface {\n    public void doSomething() {\n        System.out.println(\"Bean2 is doing something.\");\n    }\n}\n</code></pre>  </div></div>\n\n<h3 id=\"3-可选注入\">3. 可选注入</h3>\n\n<p>默认情况下，当我们标记了一个@Autowired 后，Spring 如果没有找到对应类型的 Bean，它会抛出 NoSuchBeanDefinitionException 异常。</p>\n\n<p>可以给@Autowired 增加一个 required = false 的参数：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\npublic class MailService {\n    @Autowired(required = false)\n\tZoneId zoneId = ZoneId.systemDefault();\n    ...\n}\n</code></pre>  </div></div>\n\n<p>ZoneId 是 Java 8 引入的类，用于表示时区。ZoneId.systemDefault()返回当前系统的默认时区。</p>\n\n<p>这个参数告诉 Spring 容器，如果找到一个类型为 ZoneId 的 Bean，就注入，如果找不到，就忽略。</p>\n\n<p>这种方式非常适合有定义就使用定义，没有就使用默认值的情况。</p>\n\n<h3 id=\"4-创建第三方-bean\">4. 创建第三方 Bean</h3>\n\n<p>如果一个 Bean 不在我们自己的 package 管理之内，如何创建它？</p>\n\n<p>在 Java Spring 中，创建第三方 Bean 可以通过以下几种方式实现：</p>\n\n<h4 id=\"41-使用component-注解\">4.1 使用@Component 注解</h4>\n\n<p>使用@Component 注解：如果你有第三方类的源代码，并且可以对其进行修改，可以在类上添加@Component 注解，将其声明为一个 Spring 的组件。然后，Spring 将会自动扫描并创建该类的实例，使其可以在应用程序中使用。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\npublic class ThirdPartyBean {\n    // ...\n}\n</code></pre>  </div></div>\n\n<h4 id=\"42-使用bean-注解\">4.2 使用@Bean 注解</h4>\n\n<p>使用@Bean 注解：如果你不能修改第三方类的源代码，或者需要进行更复杂的配置，可以在一个@Configuration 类中创建一个@Bean 方法，用于返回第三方类的实例。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Configuration\npublic class ThirdPartyConfig {\n    @Bean\n    public ThirdPartyBean thirdPartyBean() {\n        return new ThirdPartyBean();\n    }\n}\n</code></pre>  </div></div>\n\n<h4 id=\"43-使用-xml-配置文件\">4.3 使用 XML 配置文件</h4>\n\n<p>使用 XML 配置文件：如果你的项目使用 XML 配置方式，可以在 XML 文件中使用<bean>标签来配置第三方类的实例。</bean></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;bean id=\"thirdPartyBean\" class=\"com.example.ThirdPartyBean\" /&gt;\n</code></pre>  </div></div>\n\n<p>以上方法都可以将第三方类作为 Spring 的 Bean 进行管理，使其可以在应用程序中进行注入和使用。</p>\n\n<p>需要注意的是，对于第三方类，如果其依赖其他的第三方类或库，你需要确保这些依赖也被正确地配置和管理。具体的配置方式取决于第三方类和库的要求和约束。</p>\n\n<h3 id=\"5-初始化和销毁\">5. 初始化和销毁</h3>\n\n<p>有些时候，一个 Bean 在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。在 Java Spring 中，可以通过初始化和销毁回调方法来控制 bean 的生命周期。以下是几种常用的方式：</p>\n\n<h4 id=\"51-使用postconstruct-和predestroy-注解\">5.1 使用@PostConstruct 和@PreDestroy 注解</h4>\n\n<p>可以在 bean 的初始化方法上使用@PostConstruct 注解，以及在销毁方法上使用@PreDestroy 注解。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\npublic class MyBean {\n\n    @PostConstruct\n    public void init() {\n        // 初始化逻辑\n    }\n\n    @PreDestroy\n    public void cleanup() {\n        // 销毁逻辑\n    }\n}\n</code></pre>  </div></div>\n\n<p>在上述示例中，使用@PostConstruct 注解标记了 init()方法作为初始化回调方法，使用@PreDestroy 注解标记了 cleanup()方法作为销毁回调方法。</p>\n\n<h4 id=\"52-使用bean-注解的-initmethod-和-destroymethod-属性\">5.2 使用@Bean 注解的 initMethod 和 destroyMethod 属性</h4>\n\n<p>在使用@Bean 注解定义 bean 时，可以使用 initMethod 属性指定初始化回调方法，使用 destroyMethod 属性指定销毁回调方法。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Configuration\npublic class MyConfig {\n\n    @Bean(initMethod = \"init\", destroyMethod = \"cleanup\")\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n</code></pre>  </div></div>\n\n<p>在上述示例中，通过@Bean 注解定义了一个名为 myBean 的 bean，其中 initMethod 属性指定了初始化回调方法为”init”，destroyMethod 属性指定了销毁回调方法为”cleanup”。需要注意的是，对应的初始化和销毁方法需要在 MyBean 类中实现。</p>\n\n<h4 id=\"53-实现-initializingbean-和-disposablebean-接口\">5.3 实现 InitializingBean 和 DisposableBean 接口</h4>\n\n<p>可以让 bean 类实现 InitializingBean 接口来定义初始化逻辑，并实现 DisposableBean 接口来定义销毁逻辑。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class MyBean implements InitializingBean, DisposableBean {\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        // 初始化逻辑\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        // 销毁逻辑\n    }\n}\n</code></pre>  </div></div>\n\n<p>在上述示例中，MyBean 类实现了 InitializingBean 和 DisposableBean 接口，并分别实现了 afterPropertiesSet()方法和 destroy()方法。</p>\n\n<h3 id=\"6-使用别名\">6. 使用别名</h3>\n\n<p>在 Java Spring 中，可以为 bean 定义使用别名，以便在应用程序中使用不同的名称来引用同一个 bean。</p>\n\n<h4 id=\"61-使用-xml-配置文件\">6.1 使用 XML 配置文件</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;bean id=\"myBean\" class=\"com.example.MyBean\" /&gt;\n\n&lt;alias name=\"myBean\" alias=\"beanAlias1\" /&gt;\n&lt;alias name=\"myBean\" alias=\"beanAlias2\" /&gt;\n</code></pre>  </div></div>\n\n<p>在上述示例中，定义了一个名为”myBean”的 bean，并使用<alias>标签创建了两个别名\"beanAlias1\"和\"beanAlias2\"，它们都指向同一个 bean 实例。</alias></p>\n\n<h4 id=\"62-使用component-注解\">6.2 使用@Component 注解</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component(\"myBean\")\npublic class MyBean {\n    // ...\n}\n</code></pre>  </div></div>\n\n<p>在上述示例中，通过@Component 注解为 MyBean 类定义了一个 bean，并指定了名称为”myBean”。\n然后，可以在应用程序中使用这些别名来引用 bean：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Autowired\nprivate MyBean beanAlias1;\n\n@Autowired\nprivate MyBean beanAlias2;\n</code></pre>  </div></div>\n<p>在上述示例中，通过@Autowired注解将名为”beanAlias1”和”beanAlias2”的别名注入到相应的字段中。这样，无论使用”myBean”、”beanAlias1”还是”beanAlias2”，实际上都引用了同一个MyBean实例。</p>\n\n<h4 id=\"63-使用bean注解\">6.3 使用@Bean注解</h4>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Configuration\npublic class MyConfig {\n\n    @Bean(name = {\"beanAlias1\", \"beanAlias2\"})\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n</code></pre>  </div></div>\n<p>在上述示例中，使用@Bean注解为MyBean创建了一个bean，并通过name属性指定了别名为”beanAlias1”和”beanAlias2”，它们都指向同一个bean实例。</p>\n\n<h4 id=\"64-使用qualifier注解\">6.4 使用@Qualifier注解</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\n@Qualifier(\"beanAlias1\")\npublic class MyBean {\n    // ...\n}\n</code></pre>  </div></div>\n<p>在上述示例中，使用@Component注解标记了MyBean类为一个bean，并通过@Qualifier注解指定了别名为”beanAlias1”。然后，可以在应用程序中使用这些别名来引用bean：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Autowired\n@Qualifier(\"beanAlias1\")\nprivate MyBean beanAlias1;\n\n@Autowired\n@Qualifier(\"beanAlias2\")\nprivate MyBean beanAlias2;\n</code></pre>  </div></div>\n<p>在上述示例中，通过@Autowired注解和@Qualifier注解将名为”beanAlias1”和”beanAlias2”的别名注入到相应的字段中。</p>\n\n<p>无论是使用@Bean注解还是@Qualifier注解，都可以为bean定义使用别名，并在应用程序中使用这些别名来引用bean。这样，无论使用哪个别名，实际上都引用了同一个bean实例。</p>\n\n<p>如果把其中某个Bean指定为<strong>@Primary</strong>，那么在使用的时候如果没有设置别名，则默认使用此bean。</p>\n\n<h3 id=\"7-使用factorybean\">7. 使用FactoryBean</h3>\n<p>在Java Spring中，可以使用FactoryBean接口来创建复杂的Bean实例。FactoryBean是一个特殊的Bean，它负责创建和管理其他Bean的实例。通过实现FactoryBean接口，你可以自定义Bean的创建逻辑，从而实现更高级的实例化和配置过程。</p>\n\n<p><strong>第一步：</strong>创建一个实现FactoryBean接口的类，并实现其方法。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class MyBeanFactory implements FactoryBean&lt;MyBean&gt; {\n\n    @Override\n    public MyBean getObject() throws Exception {\n        // 在这里执行自定义的实例化逻辑，返回MyBean实例\n        return new MyBean();\n    }\n\n    @Override\n    public Class&lt;?&gt; getObjectType() {\n        return MyBean.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return true; // 指定是否为单例\n    }\n}\n</code></pre>  </div></div>\n<p>在上述示例中，创建了一个实现FactoryBean接口的类MyBeanFactory，并实现了getObject()、getObjectType()和isSingleton()方法。在getObject()方法中，你可以自定义Bean的实例化逻辑，并返回一个MyBean实例。</p>\n\n<p><strong>第二步：</strong>在配置类中注册FactoryBean。</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Configuration\npublic class MyConfig {\n\n    @Bean\n    public MyBeanFactory myBeanFactory() {\n        return new MyBeanFactory();\n    }\n\n    @Bean\n    public MyBean myBean() throws Exception {\n        return myBeanFactory().getObject(); // 获取FactoryBean创建的MyBean实例\n    }\n}\n</code></pre>  </div></div>\n<p>在上述示例中，使用@Bean注解分别创建了MyBeanFactory和MyBean。通过调用myBeanFactory().getObject()方法，获取MyBeanFactory创建的MyBean实例。\n<strong>第三步：</strong>使用FactoryBean创建Bean实例。</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Autowired\nprivate MyBean myBean;\n</code></pre>  </div></div>\n<p>在上述示例中，使用@Autowired注解将MyBean注入到myBean字段中。在应用程序中使用myBean对象时，实际上是使用FactoryBean创建的MyBean实例。</p>\n\n<p>通过使用FactoryBean，你可以实现更加灵活和复杂的Bean实例化和配置过程，包括条件创建、动态参数等。</p>\n\n<p>当一个Bean实现了FactoryBean接口后，Spring会先实例化这个工厂，然后调用getObject()创建真正的Bean。getObjectType()可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p>\n\n<p>因此，如果定义了一个FactoryBean，要注意Spring创建的Bean实际上是这个FactoryBean的getObject()方法返回的Bean。为了和普通Bean区分，我们通常都以XxxFactoryBean命名。</p>\n\n<h2 id=\"五-使用resource\">五. 使用Resource</h2>\n<p>在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。</p>\n\n<p>可以使用Resource接口来处理资源文件的加载和访问。Resource提供了一种抽象的方式来表示不同类型的资源，例如文件、类路径资源、URL等。你可以使用Resource来读取和操作这些资源。</p>\n\n<p>以下是使用Resource的几种常见方式：</p>\n\n<p><strong>方式一：</strong>使用ClassPathResource加载类路径下的资源：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Resource resource = new ClassPathResource(\"myFile.txt\");\n</code></pre>  </div></div>\n<p>在上述示例中，使用ClassPathResource加载名为myFile.txt的类路径资源。</p>\n\n<p><strong>方式二：</strong>使用FileSystemResource加载文件系统中的资源：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Resource resource = new FileSystemResource(\"path/to/myFile.txt\");\n</code></pre>  </div></div>\n\n<p>在上述示例中，使用FileSystemResource加载文件系统中指定路径下的资源文件。</p>\n\n<p><strong>方式三：</strong>使用UrlResource加载URL资源：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Resource resource = new UrlResource(\"http://www.example.com/myFile.txt\");\n</code></pre>  </div></div>\n\n<p>在上述示例中，使用UrlResource加载指定URL的资源文件。</p>\n\n<p>一旦获得Resource对象，你可以使用它进行各种操作，如读取文件内容、检查文件是否存在、获取资源的URL等。下面是一些常用的Resource方法：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>exists()：检查资源是否存在。\nisOpen()：检查资源是否被打开。\ngetFile()：获取资源文件的File对象。\ngetInputStream()：获取资源的输入流。\ngetURL()：获取资源的URL。\n</code></pre>  </div></div>\n\n<p>示例：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Resource resource = new ClassPathResource(\"myFile.txt\");\nif (resource.exists()) {\n    InputStream inputStream = resource.getInputStream();\n    // 读取和处理资源文件的内容\n} else {\n    // 资源文件不存在的处理逻辑\n}\n</code></pre>  </div></div>\n<p>在上述示例中，首先使用ClassPathResource加载名为myFile.txt的类路径资源，然后通过exists()方法检查资源是否存在，如果存在，则可以通过getInputStream()方法获取资源的输入流，并进行读取和处理。</p>\n\n<p>使用Resource接口，你可以方便地加载和操作不同类型的资源文件，使得应用程序能够更加灵活地处理资源。</p>\n\n<h2 id=\"六-注入配置\">六. 注入配置</h2>\n<p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以key=value的形式写在.properties文件中。</p>\n\n<p>要读取配置文件，我们可以使用上一节讲到的Resource来读取位于classpath下的一个.properties文件。但是，这样仍然比较繁琐。Spring容器还提供更简单的方式来自动读取配置文件。</p>\n\n<p>定义配置文件：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>my.property=value1\nmy.other.property=value2\n</code></pre>  </div></div>\n<p>使用@PropertySource注解指定配置文件的位置：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Configuration\n@PropertySource(\"classpath:application.properties\")\npublic class MyConfig {\n    // ...\n}\n\n</code></pre>  </div></div>\n<p>使用@Value注解将配置属性值注入到字段或方法参数中：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\npublic class MyBean {\n    @Value(\"${my.property}\")\n    private String myProperty;\n\n    @Value(\"${my.other.property}\")\n    private String myOtherProperty;\n\n    // ...\n}\n</code></pre>  </div></div>\n<p>在上述示例中，使用@Value注解将配置文件中的 my.property 和 my.other.property 属性值分别注入到 myProperty 和 myOtherProperty 字段中。</p>\n\n<h2 id=\"七-使用条件装配\">七. 使用条件装配</h2>\n<p>开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p>\n\n<h3 id=\"1-profile\">1. Profile</h3>\n\n<p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>native\ntest\nproduction\n</code></pre>  </div></div>\n<p>创建某个Bean时，Spring容器可以根据注解@Profile来决定是否创建。例如，以下配置：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Component\n@Profile(\"test\")\npublic class MyBean {\n    // ...\n}\n</code></pre>  </div></div>\n<p>在运行程序时，加上JVM参数-Dspring.profiles.active=test就可以指定以test环境启动。</p>\n\n<p>实际上，Spring允许指定多个Profile，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-Dspring.profiles.active=test,master\n</code></pre>  </div></div>\n<p>可以表示test环境，并使用master分支代码。</p>\n\n<h3 id=\"2-conditional\">2. Conditional</h3>\n<p>在Java Spring中，你可以使用@Conditional注解来创建具有条件的Bean。通过@Conditional注解，你可以根据特定的条件来决定是否创建Bean。</p>\n\n<p>以下是使用@Conditional注解创建具有条件的Bean的示例：</p>\n\n<p>创建一个自定义的条件类，实现Condition接口，并重写matches()方法：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class MyCondition implements Condition {\n    @Override\n    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n        // 根据特定条件进行判断，返回true或false\n        // ...\n    }\n}\n</code></pre>  </div></div>\n<p>在上述示例中，你可以根据自定义的条件在matches()方法中进行判断，并返回相应的结果。</p>\n\n<p>在配置类中，使用@Conditional注解来应用条件，只有当条件满足时才创建Bean：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Configuration\npublic class MyConfig {\n    @Bean\n    @Conditional(MyCondition.class)\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n</code></pre>  </div></div>\n<p>在上述示例中，使用@Conditional注解将myBean()方法的创建条件设置为MyCondition类。只有当MyCondition类的条件满足时，才会创建MyBean。</p>\n\n<p>通过使用@Conditional注解，你可以根据自定义的条件来决定是否创建特定的Bean。这使得你可以根据应用程序的需要，在特定条件下有选择地创建和使用Bean，增强了应用程序的灵活性和可配置性。</p>\n","dir":"/blog/development/java/framework/spring/","name":"2023-05-18_1.md","path":"blog/development/java/framework/spring/2023-05-18_1.md","url":"/blog/development/java/framework/spring/2023-05-18_1.html"},{"sort":1,"layout":"default","title":"Java学习大纲路径","content":"<h1 id=\"java学习大纲路径\">Java学习大纲路径</h1>\n\n<p>本文介绍了Java的学习路径大纲，喜欢的朋友可以根据大纲去学习</p>\n\n<p>如果你是完全没有编程基础的新手，建议你先从基础的编程概念入手，比如变量、循环、条件语句、函数等，可以先学习 Python 或者 JavaScript 这样的入门语言，然后再转向 Java。</p>\n\n<p>以下是一个比较完整的 Java 学习路径：</p>\n\n<h2 id=\"一java-基础语法\">一.Java 基础语法</h2>\n<p>学习 Java 的基础语法，包括数据类型、变量、运算符、流程控制、循环语句等等。\n数据类型：包括整数类型、浮点数类型、布尔类型、字符类型等等。以下是 Java 基础语法的学习大纲：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.变量：定义变量的方式、变量的命名规则、变量的作用域等等。\n2.运算符：包括算术运算符、比较运算符、逻辑运算符等等。\n3.流程控制：包括 if 语句、switch 语句、for 循环、while 循环、do-while 循环等等。\n4.数组：定义数组的方式、数组的遍历、数组的排序等等。\n5.方法：定义方法的方式、方法的参数传递、方法的返回值等等。\n6.字符串：定义字符串的方式、字符串的常用方法、字符串的比较等等。\n7.输入输出：使用 Scanner 类读取控制台输入、使用 System.out.println() 输出等等。\n8.包和导入：将类组织成包、使用 import 语句导入类等等。\n9.注释：单行注释、多行注释、文档注释等等。\n</code></pre>  </div></div>\n\n<p>以上是 Java 基础语法的大纲，这些内容是 Java 编程的基础，掌握好这些内容可以让你写出简单的 Java 程序。</p>\n\n<h2 id=\"二面向对象编程\">二.面向对象编程</h2>\n<p>Java 是一门面向对象的语言，所以要学习面向对象编程的基本概念，包括类、对象、封装、继承、多态等等。\n以下是 Java 面向对象编程的学习大纲：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.类和对象：定义类、创建对象、类的构造方法、对象的属性和方法等等。\n2.封装：控制对象的属性访问权限、getter 和 setter 方法、访问修饰符等等。\n3.继承：子类和父类、super 关键字、方法重载和方法覆盖等等。\n4.多态：方法的重载和方法的覆盖、向上转型和向下转型、抽象类和接口等等。\n5.枚举类型：定义枚举类型、枚举类型的属性和方法等等。\n6.内部类：定义内部类、匿名内部类、静态内部类等等。\n7.泛型：定义泛型类、泛型方法、通配符等等。\n8.异常处理：try-catch-finally 语句、抛出异常、自定义异常等等。\n</code></pre>  </div></div>\n\n<p>以上是 Java 面向对象编程的大纲，这些内容是 Java 编程的核心，掌握好这些内容可以让你写出更加复杂的 Java 程序，并且使你的程序更加易于维护和扩展。</p>\n\n<h2 id=\"三异常处理\">三.异常处理</h2>\n<p>Java 中有很多异常类型，了解异常处理机制可以帮助你写出更健壮的代码。\n以下是 Java 异常处理的学习大纲：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.异常概述：异常的定义、异常分类、异常处理机制等等。\n2.try-catch-finally 语句：try 块、catch 块、finally 块的使用方法、多个 catch 块的顺序、异常的重新抛出等等。\n3.异常类和处理程序：自定义异常类、异常处理程序的编写方法等等。\n4.抛出异常：throw 关键字的使用方法、抛出自定义异常等等。\n5.异常处理的最佳实践：异常的记录和日志、避免空指针异常等等。\n</code></pre>  </div></div>\n\n<p>以上是 Java 异常处理的大纲，异常处理是 Java 程序开发的重要部分，合理的异常处理能够增强程序的健壮性和可靠性，减少程序出错的风险，使程序更加稳定。</p>\n\n<h2 id=\"四集合框架\">四.集合框架</h2>\n<p>Java 中的集合框架包括 List、Set、Map 等等，学习这些集合的用法可以帮助你更好地处理数据。\nJava集合框架是Java中的一个核心概念，用于管理和操作不同类型的数据。在学习Java集合框架时，可以按照以下大纲进行学习</p>\n\n<p>1.集合框架概述：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>了解Java集合框架的基本概念和架构\n了解Java集合框架中的接口和类\n学习Java集合框架中的常用数据结构 2.List集合：\n\n学习List集合的概念和特点\n学习ArrayList和LinkedList的使用方法和区别\n学习List集合的常用操作方法\n</code></pre>  </div></div>\n\n<p>3.Set集合：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习Set集合的概念和特点\n学习HashSet和TreeSet的使用方法和区别\n学习Set集合的常用操作方法\n</code></pre>  </div></div>\n\n<p>4.Map集合：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习Map集合的概念和特点\n学习HashMap和TreeMap的使用方法和区别\n学习Map集合的常用操作方法\n</code></pre>  </div></div>\n\n<p>5.Queue集合：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习Queue集合的概念和特点\n学习LinkedList和PriorityQueue的使用方法和区别\n学习Queue集合的常用操作方法\n</code></pre>  </div></div>\n\n<p>6.Collections工具类：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习Collections工具类的常用方法\n学习Collections工具类中的排序算法\n</code></pre>  </div></div>\n\n<p>7.Iterator迭代器：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习Iterator迭代器的概念和作用\n学习如何使用Iterator迭代器遍历集合\n</code></pre>  </div></div>\n\n<p>8.泛型；</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习泛型的概念和作用；\n学习如何使用泛型来增加代码的可读性和可维护性；\n</code></pre>  </div></div>\n\n<p>以上是Java集合框架的学习大纲，通过系统学习可以更好地掌握Java集合框架的使用和应用。</p>\n\n<h2 id=\"五io-流操作\">五.IO 流操作</h2>\n<p>Java 中有很多 IO 流，包括字节流和字符流，学习 IO 流可以帮助你更好地读写文件和网络数据。\nJava IO 流操作可以分为以下几个部分：</p>\n\n<p>1.Java IO 流概述：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Java IO 流的分类\n字节流和字符流的区别\n输入流和输出流的概念\n</code></pre>  </div></div>\n\n<p>2.字节流：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>InputStream 和 OutputStream\nFileInputStream 和 FileOutputStream\nByteArrayInputStream 和 ByteArrayOutputStream\nBufferedInputStream 和 BufferedOutputStream\nDataInputStream 和 DataOutputStream\nObjectInputStream 和 ObjectOutputStream\n</code></pre>  </div></div>\n\n<p>3.字符流：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Reader 和 Writer\nFileReader 和 FileWriter\nCharArrayReader 和 CharArrayWriter\nBufferedReader 和 BufferedWriter\nInputStreamReader 和 OutputStreamWriter\n</code></pre>  </div></div>\n\n<p>4.NIO：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NIO 的概念和使用\nChannel 和 Buffer 的概念和使用\nSelector 的概念和使用\n</code></pre>  </div></div>\n\n<p>5.文件操作：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>File 类的概念和使用\nFile 相关的输入输出流的使用\n文件的读写和复制\n</code></pre>  </div></div>\n\n<p>6.序列化和反序列化：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Serializable 接口和 Externalizable 接口\nObjectOutputStream 和 ObjectInputStream 的使用\ntransient 关键字的使用\n</code></pre>  </div></div>\n\n<p>7.其他：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>PipedInputStream 和 PipedOutputStream\nPrintStream 和 PrintWriter\nRandomAccessFile\n</code></pre>  </div></div>\n\n<p>以上是一个比较完整的 Java IO 流操作的学习大纲，可以按照这个大纲系统地学习 Java IO 流的相关知识点。在学习过程中，可以结合实际的项目需求和练习来加深理解和熟练掌握。</p>\n\n<h2 id=\"六多线程编程\">六.多线程编程</h2>\n<p>Java 支持多线程编程，学习多线程编程可以让你写出更高效的程序。以下是Java多线程编程的学习大纲：</p>\n\n<p>1.多线程基础：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>理解线程和进程的概念\n创建线程的方式：继承Thread类和实现Runnable接口\n线程的状态和状态转换：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED\n线程的优先级\n线程的同步与协作：synchronized关键字、wait()、notify()、notifyAll()方法\n线程池的使用\n</code></pre>  </div></div>\n\n<p>2.线程安全：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>理解线程安全的概念\n线程安全的实现方法：synchronized关键字、Lock对象、原子类、volatile关键字\n线程安全的集合类\n</code></pre>  </div></div>\n\n<p>3.高级多线程编程：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>线程的中断和停止：interrupt()、Thread.currentThread().isInterrupted()、Thread.interrupted()方法\n等待多个线程完成：CountDownLatch、CyclicBarrier、Semaphore\n线程间通信：Pipe、BlockingQueue、Exchanger\n同步器：ReentrantLock、ReadWriteLock、Condition\n</code></pre>  </div></div>\n\n<p>4.并发编程实践：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>原子性操作：AtomicInteger、AtomicBoolean、AtomicReference等\n死锁的解决方法\n线程的性能调优\n</code></pre>  </div></div>\n\n<p>5.Java 8的并发编程特性：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>并行流和并发流\nCompletableFuture类\n新的原子类\n</code></pre>  </div></div>\n\n<p>在学习的过程中，可以通过实践来巩固知识。例如，编写多线程的程序来实现一些并发任务，可以通过调试和测试来加深对多线程编程的理解。同时，也可以参考一些经典的多线程编程案例，例如生产者消费者问题、哲学家就餐问题等。</p>\n\n<h2 id=\"七数据库编程\">七.数据库编程</h2>\n<p>Java 中有很多数据库连接方式，比如 JDBC，学习数据库编程可以帮助你处理数据存储和查询的问题。\n以下是Java数据库编程的学习大纲：</p>\n\n<p>1.数据库基础知识</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>数据库的概念\n关系型数据库和非关系型数据库的区别\nSQL语言的基本语法和常用操作\n数据库事务的概念和特性\n</code></pre>  </div></div>\n\n<p>2.JDBC编程</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>JDBC的基本概念和原理\nJDBC的四大对象：Connection、Statement、ResultSet、PreparedStatement\nJDBC的数据类型映射\nJDBC的事务处理\nJDBC的元数据和批量处理\n</code></pre>  </div></div>\n\n<p>3.数据库连接池</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>连接池的概念和作用\n数据库连接池的实现原理\n常用的数据库连接池框架：C3P0、DBCP、HikariCP等\n连接池的配置和性能调优\n</code></pre>  </div></div>\n\n<p>4.ORM框架</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ORM的概念和作用\n常用的ORM框架：Hibernate、MyBatis等\nORM框架的配置和使用\nORM框架的性能调优\n</code></pre>  </div></div>\n\n<p>5.NoSQL数据库</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NoSQL数据库的概念和特点\n常用的NoSQL数据库：MongoDB、Redis、Cassandra等\nNoSQL数据库的Java编程实现\n</code></pre>  </div></div>\n\n<p>在学习的过程中，可以通过实践来巩固知识。例如，通过编写Java程序来连接数据库，进行增删改查等操作。同时，也可以参考一些经典的数据库案例，例如图书管理系统、学生成绩管理系统等，来加深对数据库编程的理解。</p>\n\n<h2 id=\"八web-开发\">八.Web 开发</h2>\n<p>Java 在 Web 开发方面也有很多优秀的框架，比如 Spring、Struts、Hibernate 等等，学习这些框架可以帮助你开发高效的 Web 应用。\n以下是JavaWeb开发的学习大纲：</p>\n\n<p>1.Web基础知识</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Web应用的概念和特点\nHTTP协议的基本原理和常用方法\nHTML、CSS、JavaScript等Web前端技术\n</code></pre>  </div></div>\n\n<p>2.Servlet编程</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Servlet的概念和生命周期\nServlet的请求处理和响应处理\nServlet的会话管理和Cookie技术\nServlet的过滤器和监听器\n</code></pre>  </div></div>\n\n<p>3.JSP编程</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>JSP的概念和原理\nJSP的标签和指令\nJSP的EL表达式和JSTL标签库\nJSP和Servlet的协作\n</code></pre>  </div></div>\n\n<p>4.MVC框架</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>MVC框架的概念和作用\n常用的MVC框架：Struts、Spring MVC等\nMVC框架的配置和使用\nMVC框架的性能调优\n</code></pre>  </div></div>\n\n<p>5.Web服务开发</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Web服务的概念和特点\nSOAP和RESTful两种Web服务架构\n常用的Web服务开发框架：CXF、Axis等\nWeb服务的安全性和性能优化\n</code></pre>  </div></div>\n\n<p>6.前后端分离开发</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>前后端分离开发的概念和特点\n常用的前端框架：Vue.js、React等\n常用的后端框架：Spring Boot、Spring Cloud等\n前后端数据交互方式：JSON、XML等\n</code></pre>  </div></div>\n\n<p>在学习的过程中，可以通过实践来巩固知识。例如，编写一个简单的Web应用程序，包括前端页面、后端服务和数据库的交互等。同时，也可以参考一些经典的Web开发案例，例如电商网站、博客系统等，来加深对JavaWeb开发的理解。\n以上是一个比较完整的 Java 学习路径，当然如果你只是想学习 Java 的一部分，可以根据自己的需求选择学习内容。</p>\n","dir":"/blog/development/java/jottings/","name":"2023-04-23_1.md","path":"blog/development/java/jottings/2023-04-23_1.md","url":"/blog/development/java/jottings/2023-04-23_1.html"},{"sort":1,"permalink":"/blog/development/java/framework/spring/","layout":"default","title":"Spring Framework","content":"<h1 id=\"spring-framework\">Spring Framework</h1>\n\n<p>Spring是一个轻量级的开发框架，用于构建Java企业级应用程序。它提供了一个全面的编程和配置模型，用于开发各种类型的应用，包括Web应用、RESTful服务、批处理应用、消息传递应用等。</p>\n\n<p>它提供的一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。</p>\n\n<h2 id=\"一-介绍\">一. 介绍</h2>\n<p>Spring最早是由Rod Johnson这哥们在他的《Expert One-on-One J2EE Development without EJB》一书中提出的用来取代EJB的轻量级框架。随后这哥们又开始专心开发这个基础框架，并起名为Spring Framework。</p>\n\n<p>随着Spring越来越受欢迎，在Spring Framework基础上，又诞生了Spring Boot、Spring Cloud、Spring Data、Spring Security等一系列基于Spring Framework的项目。本章我们只介绍Spring Framework，即最核心的Spring框架。后续章节我们还会涉及Spring Boot、Spring Cloud等其他框架。</p>\n\n<h3 id=\"一-主要特点\">(一). 主要特点</h3>\n\n<p><strong>IOC（Inverse of Control，控制反转）容器：</strong>Spring的核心是IOC容器，它负责管理和组织应用程序中的对象及其依赖关系。通过IOC容器，开发者可以将对象的创建、依赖注入、生命周期管理等交给Spring框架处理，实现松耦合和可维护的应用。</p>\n\n<p><strong>AOP（Aspect Oriented Programming，面向切面编程）支持：</strong>Spring提供了AOP机制，用于将横切关注点（如日志、事务管理、安全性等）与业务逻辑分离。通过定义切面和切点，可以在运行时动态地将切面织入到应用程序中。</p>\n\n<p><strong>声明式事务管理：</strong>Spring框架提供了声明式事务管理的支持，通过简单的配置即可管理事务，无需显式编写大量的事务管理代码。可以使用注解或XML进行事务配置，同时支持多种事务管理器。</p>\n\n<p><strong>MVC（Model-View-Controller）框架：</strong>Spring MVC是Spring框架的一个模块，用于开发Web应用程序。它采用经典的MVC设计模式，将应用程序分为模型（Model）、视图（View）和控制器（Controller）三个组件，提供了灵活的请求处理和视图渲染机制。</p>\n\n<p><strong>集成支持：</strong>Spring提供了丰富的集成支持，可以与各种第三方库和框架进行无缝集成，如Hibernate、MyBatis、JPA、JMS、RESTful服务等。这使得开发者可以利用Spring的功能和特性，与其他技术组件进行整合。</p>\n\n<p><strong>安全性：</strong>Spring框架提供了多种安全性功能和扩展点，用于保护应用程序的数据和资源。它支持基于角色的访问控制、身份验证和授权，同时提供了集成常见安全框架（如Spring Security）的能力。</p>\n\n<p><strong>测试支持：</strong>Spring框架提供了丰富的测试支持，包括单元测试和集成测试。它提供了各种测试工具和模拟对象，用于编写可靠的自动化测试，帮助开发者确保应用程序的质量和稳定性。</p>\n\n<p>Spring框架简化了企业级Java应用程序的开发，提供了一种灵活、可扩展和可维护的编程模型。它的模块化设计和丰富的功能使得开发者能够更加专注于业务逻辑的实现，提高开发效率和代码质量。</p>\n\n<h3 id=\"二-包含模块\">(二). 包含模块</h3>\n<p>Spring Framework主要包括几个模块：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>支持IoC和AOP的容器；\n支持JDBC和ORM的数据访问模块；\n支持声明式事务的模块；\n支持基于Servlet的MVC开发；\n支持基于Reactive的Web开发；\n以及集成JMS、JavaMail、JMX、缓存等其他模块。\n</code></pre>  </div></div>\n\n<ul>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_1.html\">Spring IOC 容器</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_2.html\">Spring AOP使用</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_3.html\">Spring 访问数据库</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_4.html\">Spring 开发Web应用</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_5.html\">Spring 集成第三方组件</a></li>\n</ul>\n","dir":"/blog/development/java/framework/spring/","name":"README.md","path":"blog/development/java/framework/spring/README.md","url":"/blog/development/java/framework/spring/"},{"sort":2,"layout":"default","title":"最新主流搜索引擎提交sitemap大全（网站地图）","content":"<h1 id=\"最新主流搜索引擎提交sitemap大全网站地图\">最新主流搜索引擎提交sitemap大全（网站地图）</h1>\n\n<p>做网站优化我们除了要做好站内和站外优化之外，还需要关注各大搜索引擎提交的入口，因为有的时候网站太多，蜘蛛一时间无法抓取过来，这时候我们需要采取主动出击，而不是被动的接受蜘蛛自己来抓取。</p>\n\n<p>搜索引擎提交sitemap大全（网站地图）,各个站长管理平台.</p>\n\n<p>  对于SEO优化人员来说，都有那些可以提交的入口呢？今天就为大家汇总一下提交sitemap大全。</p>\n\n<h2 id=\"一百度\">一.百度</h2>\n<p>百度sitemap提交：老地址是：<a href=\"http://sitemap.baidu.com/\">http://sitemap.baidu.com/</a> 百度站长平台，我相信这是很多站长都非常熟悉的。</p>\n\n<p>最新地址：<a href=\"https://ziyuan.baidu.com/\">https://ziyuan.baidu.com/</a>，注册登录账号。在站点管理中进行新增网址验证。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230427145844min.png\" alt=\"百度sitemap提交地址\" />\n注意：gitpage网站无法正常被百度收录，需要其他处理方法。</p>\n\n<h2 id=\"二google\">二.Google</h2>\n<p>  Google：<a href=\"https://www.google.com/webmasters/tools/\">https://www.google.com/webmasters/tools/</a> 可谓最强大的网站管理员工具，提交sitemap当然是最基本的。</p>\n\n<p>进行站点验证后，可刷新页面，点击左上角网站进行提交sitemap.xml提交</p>\n\n<h2 id=\"三360\">三.360</h2>\n<p>  360sitemap提交：<a href=\"http://zhanzhang.so.com/?m=Sitemap&amp;a=listSite\">http://zhanzhang.so.com/?m=Sitemap&amp;a=listSite</a> 有助于360更全面、更快速地对网站进行抓取。</p>\n\n<p>注：gitpage网站验证失败</p>\n<h2 id=\"四搜狗\">四.搜狗</h2>\n<p>  搜狗sitemap提交：<a href=\"http://zhanzhang.sogou.com/index.php/sitemap/index/type/sitemap\">http://zhanzhang.sogou.com/index.php/sitemap/index/type/sitemap</a> 可帮助sogou爬虫抓取你的网站，目前采用邀请制,目前不支持sitemap批量方式.</p>\n\n<p>注：验证时需要备案过的域名</p>\n\n<h2 id=\"五bing\">五.Bing</h2>\n<p>  Bing：<a href=\"http://www.bing.com/toolbox/webmaster/\">http://www.bing.com/toolbox/webmaster/</a> 微软的强力产品，在美国市场占有一定搜索份额。管理员工具功能也很强大。</p>\n\n<h2 id=\"六yandex\">六.Yandex</h2>\n<p>  Yandex：<a href=\"http://webmaster.yandex.com/\">http://webmaster.yandex.com/</a> Yandex是俄罗斯最大的搜索引擎，相对于俄罗斯的百度。管理员工具提供了类似Google Webmaster的功能，非常强大。</p>\n\n<h2 id=\"七让头条搜索收录网站\">七.让头条搜索收录网站</h2>\n\n<p>注册头条站长平台：https://zhanzhang.toutiao.com/</p>\n\n<h2 id=\"七让神马搜索收录网站\">七.让神马搜索收录网站</h2>\n\n<p>神马平台：https://zhanzhang.sm.cn/open/webcheck/web/14787346</p>\n\n<p>两种方式都验证失败，放弃神马收录</p>\n\n<p>除了上述距离比较近的主流搜索引擎.另外雅虎中国已经关闭,神马搜索设置了下,无法验证网站成功,其他Ask等可以选择性提交.</p>\n\n<p>  最后，在robots.txt文件中添加sitemap，搜索引擎抓取robots.txt的时候就可以获取sitemap。方法非常简单，只要在robots.txt的第一行或者最后一行按以下格式加入sitemap地址即可。即：Sitemap: http://www.example.com/sitemap.xml当发现蜘蛛已经很久没有来我们网站的时候，可以适当地提交网站地图，这样可以让蜘蛛优先抓取和收录。</p>\n","dir":"/blog/development/html/seo/","name":"2023-04-27_2.md","path":"blog/development/html/seo/2023-04-27_2.md","url":"/blog/development/html/seo/2023-04-27_2.html"},{"sort":2,"permalink":"/blog/development/tool/maven/","layout":"default","title":"Maven","content":"<h1 id=\"maven\">Maven</h1>\n\n<ul>\n <li><a href=\"/blog/development/tool/maven/2023-04-27_1.html\">Maven推送本地jar包到仓库</a></li>\n</ul>\n","dir":"/blog/development/tool/maven/","name":"README.md","path":"blog/development/tool/maven/README.md","url":"/blog/development/tool/maven/"},{"sort":2,"layout":"default","title":"Java面试宝典二(2023最新Java面试题)","content":"<h1 id=\"java面试宝典二2023最新java面试题\">Java面试宝典二(2023最新Java面试题)</h1>\n\n<h2 id=\"一-java-web\">一. Java Web</h2>\n\n<h3 id=\"1-jsp-和-servlet-有什么区别\"><strong>1. JSP 和 servlet 有什么区别？</strong></h3>\n\n<p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p>\n\n<h3 id=\"2-jsp-有哪些内置对象作用分别是什么\"><strong>2. JSP 有哪些内置对象？作用分别是什么？</strong></h3>\n\n<p>JSP 有 9 大内置对象：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；\nresponse：封装服务器对客户端的响应；\npageContext：通过该对象可以获取其他对象；\nsession：封装用户会话的对象；\napplication：封装服务器运行环境的对象；\nout：输出服务器响应的输出流对象；\nconfig：Web 应用的配置对象；\npage：JSP 页面本身（相当于 Java 程序中的 this）；\nexception：封装页面抛出异常的对象。\n</code></pre>  </div></div>\n\n<h3 id=\"3-说一下-jsp-的-4-种作用域\"><strong>3. 说一下 JSP 的 4 种作用域？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>page：代表与一个页面相关的对象和属性。\nrequest：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。\nsession：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。\napplication：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。\n</code></pre>  </div></div>\n\n<h3 id=\"4-session-和-cookie-有什么区别\"><strong>4. session 和 cookie 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。\n安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。\n容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。\n存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。\n</code></pre>  </div></div>\n\n<h3 id=\"5-说一下-session-的工作原理\"><strong>5. 说一下 session 的工作原理？</strong></h3>\n\n<p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。</p>\n\n<p>这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p>\n\n<h3 id=\"6-如果客户端禁止-cookie-能实现-session-还能用吗\"><strong>6. 如果客户端禁止 cookie 能实现 session 还能用吗？</strong></h3>\n\n<p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p>\n\n<h3 id=\"7-spring-mvc-和-struts-的区别是什么\"><strong>7. spring mvc 和 struts 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。\n数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。\n拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。\n对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。\n</code></pre>  </div></div>\n\n<h3 id=\"8-如何避免-sql-注入\"><strong>8. 如何避免 SQL 注入？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>使用预处理 PreparedStatement。\n使用正则表达式过滤掉字符中的特殊字符。\n</code></pre>  </div></div>\n\n<h3 id=\"9-什么是-xss-攻击如何避免\"><strong>9. 什么是 XSS 攻击，如何避免？</strong></h3>\n\n<p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p>\n\n<p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p>\n\n<h3 id=\"10-什么是-csrf-攻击如何避免\"><strong>10. 什么是 CSRF 攻击，如何避免？</strong></h3>\n\n<p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p>\n\n<p>防御手段：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>验证请求来源地址；\n关键操作添加验证码；\n在请求地址添加 token 并验证。\n</code></pre>  </div></div>\n\n<h2 id=\"二-异常\"><strong>二. 异常</strong></h2>\n\n<h3 id=\"1-throw-和-throws-的区别\"><strong>1. throw 和 throws 的区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>throw：是真实抛出一个异常。\nthrows：是声明可能会抛出一个异常。\n</code></pre>  </div></div>\n\n<h3 id=\"2-finalfinallyfinalize-有什么区别\"><strong>2. final、finally、finalize 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。\nfinally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。\nfinalize：是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。\n</code></pre>  </div></div>\n\n<h3 id=\"3-try-catch-finally-中哪个部分可以省略\"><strong>3. try-catch-finally 中哪个部分可以省略？</strong></h3>\n\n<p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>\n\n<h3 id=\"4-try-catch-finally-中如果-catch-中-return-了finally-还会执行吗\"><strong>4. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong></h3>\n\n<p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>\n\n<h3 id=\"5-常见的异常类有哪些\"><strong>5. 常见的异常类有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NullPointerException 空指针异常\nClassNotFoundException 指定类不存在\nNumberFormatException 字符串转换为数字异常\nIndexOutOfBoundsException 数组下标越界异常\nClassCastException 数据类型转换异常\nFileNotFoundException 文件未找到异常\nNoSuchMethodException 方法不存在异常\nIOException IO 异常\nSocketException Socket 异常\n</code></pre>  </div></div>\n\n<h2 id=\"三-网络\"><strong>三. 网络</strong></h2>\n\n<h3 id=\"1-http-响应码-301-和-302-代表的是什么有什么区别\"><strong>1. http 响应码 301 和 302 代表的是什么？有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>301：永久重定向。\n\n302：暂时重定向。\n</code></pre>  </div></div>\n\n<p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>\n\n<h3 id=\"2-forward-和-redirect-的区别\"><strong>2. forward 和 redirect 的区别？</strong></h3>\n\n<p>forward 是转发 和 redirect 是重定向：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；\n数据共享：forward 可以共享 request 里的数据，redirect 不能共享；\n效率：forward 比 redirect 效率高。\n</code></pre>  </div></div>\n\n<h3 id=\"3-简述-tcp-和-udp的区别\"><strong>3. 简述 tcp 和 udp的区别？</strong></h3>\n\n<p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>\n\n<p>两者的区别大致如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；\ntcp 提供可靠的服务（数据传输），udp 无法保证；\ntcp 面向字节流，udp 面向报文；\ntcp 数据传输慢，udp 数据传输快；\n</code></pre>  </div></div>\n\n<h3 id=\"4-tcp-为什么要三次握手两次不行吗为什么\"><strong>4. tcp 为什么要三次握手，两次不行吗？为什么？</strong></h3>\n\n<p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p>\n\n<h3 id=\"5-说一下-tcp-粘包是怎么产生的\"><strong>5. 说一下 tcp 粘包是怎么产生的？</strong></h3>\n\n<p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；\n接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。\n</code></pre>  </div></div>\n\n<h3 id=\"6-osi-的七层模型都有哪些\"><strong>6. OSI 的七层模型都有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。\n数据链路层：负责建立和管理节点间的链路。\n网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。\n传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。\n会话层：向两个实体的表示层提供建立和使用连接的方法。\n表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。\n应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。\n</code></pre>  </div></div>\n\n<h3 id=\"7-get-和-post-请求有哪些区别\"><strong>7. get 和 post 请求有哪些区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>get 请求会被浏览器主动缓存，而 post 不会。\nget 传递参数有大小限制，而 post 没有。\npost 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。\n</code></pre>  </div></div>\n\n<h3 id=\"8-如何实现跨域\"><strong>8. 如何实现跨域？</strong></h3>\n\n<p>实现跨域有以下几种方案：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>服务器端运行跨域 设置 CORS 等于 *；\n在单个接口使用注解 @CrossOrigin 运行跨域；\n使用 jsonp 跨域；\n</code></pre>  </div></div>\n\n<h3 id=\"9-说一下-jsonp-实现原理\"><strong>9. 说一下 JSONP 实现原理？</strong></h3>\n\n<p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p>\n\n<h2 id=\"四-设计模式\"><strong>四. 设计模式</strong></h2>\n\n<h3 id=\"1-说一下你熟悉的设计模式\"><strong>1. 说一下你熟悉的设计模式？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>单例模式：保证被创建一次，节省系统开销。\n工厂模式（简单工厂、抽象工厂）：解耦代码。\n观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。\n外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。\n模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。\n状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。\n</code></pre>  </div></div>\n\n<h3 id=\"2-简单工厂和抽象工厂有什么区别\"><strong>2. 简单工厂和抽象工厂有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。\n工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。\n抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。\n</code></pre>  </div></div>\n","dir":"/blog/development/interview/java/","name":"2023-04-23_2.md","path":"blog/development/interview/java/2023-04-23_2.md","url":"/blog/development/interview/java/2023-04-23_2.html"},{"sort":2,"layout":"default","title":"Spring AOP使用","content":"<h1 id=\"spring-aop使用\">Spring AOP使用</h1>\n","dir":"/blog/development/java/framework/spring/","name":"2023-05-18_2.md","path":"blog/development/java/framework/spring/2023-05-18_2.md","url":"/blog/development/java/framework/spring/2023-05-18_2.html"},{"sort":2,"layout":"default","title":"Spring中的事务回滚机制","content":"<h1 id=\"spring中的事务回滚机制\">Spring中的事务回滚机制</h1>\n\n<p>在Spring框架中，事务管理是一项重要的功能。事务是一组相关操作的逻辑单元，要么全部成功执行，要么全部回滚。事务的回滚机制是指在事务执行过程中发生异常或满足特定条件时，将之前执行的操作全部回滚到事务开始之前的状态。</p>\n\n<p>Spring框架提供了多种方式来管理事务，包括基于注解的声明式事务管理和编程式事务管理。无论使用哪种方式，Spring的事务回滚机制都是基于AOP（面向切面编程）和数据库的事务支持。</p>\n\n<h2 id=\"一-声明式事务管理\">一. 声明式事务管理</h2>\n\n<p>在Spring中，声明式事务管理是一种方便的方式来管理事务，它允许使用注解或XML配置来声明事务的行为，而无需在业务代码中显式处理事务操作。</p>\n\n<p>声明式事务管理的关键是使用@Transactional注解。通过在方法或类上添加@Transactional注解，可以指定事务的传播行为、回滚规则等属性。当方法被调用时，Spring会自动为该方法开启事务，并在方法执行结束后根据注解的配置自动提交或回滚事务。</p>\n\n<p>下面是声明式事务管理的一些重要概念和使用方式：</p>\n\n<p><strong>@Transactional注解：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Transactional注解可应用于方法或类级别。\n当应用于方法时，它指示该方法应在事务范围内执行。\n当应用于类时，它指示该类中的所有公共方法都应在事务范围内执行。\n@Transactional注解可以设置多个属性，例如传播行为、隔离级别、回滚规则等。\n</code></pre>  </div></div>\n\n<p><strong>事务传播行为：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>事务传播行为定义了事务方法如何与已经存在的事务进行交互。\n一些常见的传播行为包括REQUIRED、REQUIRES_NEW、SUPPORTS、NOT_SUPPORTED、NEVER、MANDATORY等。\nREQUIRED是默认的传播行为，它指示方法应该在已经存在的事务中执行，如果没有事务则创建一个新事务。\n</code></pre>  </div></div>\n\n<p><strong>事务回滚规则：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>事务回滚规则定义了哪些异常触发事务回滚。\n默认情况下，Spring仅在遇到RuntimeException及其子类异常时才会回滚事务。\n可以使用@Transactional注解的rollbackFor属性指定需要回滚的异常类型，或者使用noRollbackFor属性指定不需要回滚的异常类型。\n</code></pre>  </div></div>\n\n<p><strong>XML配置方式：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>除了使用注解方式外，还可以使用XML配置声明式事务管理。\n在XML配置中，可以定义事务管理器、切面和事务通知等元素来实现声明式事务管理。\n</code></pre>  </div></div>\n\n<p>下面的示例展示了如何在Spring中使用声明式事务管理：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)\npublic void performTransaction() {\n    // 业务逻辑代码\n}\n\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void performAnotherTransaction() {\n    // 业务逻辑代码\n}\n\n</code></pre>  </div></div>\n<p>在示例中，performTransaction()方法将在已存在的事务中执行，如果没有事务则创建一个新事务。该方法在遇到任何Exception及其子类异常时都会触发事务回滚。而performAnotherTransaction()方法使用REQUIRES_NEW传播行为，它总是创建一个新事务并在方法执行结束后提交。</p>\n\n<p>通过声明式事务管理，可以将事务相关的代码与业务逻辑代码分开。</p>\n\n<h2 id=\"二-编程式事务管理\">二. 编程式事务管理</h2>\n<p>在Spring中，编程式事务管理是一种手动管理事务的方式，通过编写代码来控制事务的开始、提交和回滚。相对于声明式事务管理，编程式事务管理提供了更细粒度的事务控制。</p>\n\n<p>编程式事务管理涉及以下几个重要的组件和操作：</p>\n\n<p><strong>PlatformTransactionManager：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>PlatformTransactionManager是Spring框架中的事务管理器接口。\n它定义了开始事务、提交事务和回滚事务等操作的方法。\n</code></pre>  </div></div>\n\n<p><strong>TransactionDefinition：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>TransactionDefinition是用于定义事务的接口，它包含了事务的传播行为、隔离级别、超时时间等属性。\n通过TransactionDefinition，可以指定事务的行为方式。\n</code></pre>  </div></div>\n\n<p><strong>TransactionStatus：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>TransactionStatus是表示事务状态的接口。\n它包含了事务的当前状态信息，例如是否是一个新事务、是否已经完成等。\n</code></pre>  </div></div>\n\n<p><strong>TransactionTemplate：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>TransactionTemplate是Spring提供的简化编程式事务管理的工具类。\n它封装了事务的启动、提交和回滚等操作，简化了事务管理的代码编写。\n</code></pre>  </div></div>\n\n<p>示例展示了如何在Spring中使用编程式事务管理：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Autowired\nprivate PlatformTransactionManager transactionManager;\n\npublic void performTransaction() {\n    TransactionDefinition definition = new DefaultTransactionDefinition();\n    TransactionStatus status = transactionManager.getTransaction(definition);\n    \n    try {\n        // 业务逻辑代码\n        \n        transactionManager.commit(status);\n    } catch (Exception e) {\n        transactionManager.rollback(status);\n    }\n}\n\n</code></pre>  </div></div>\n<p>在示例中，首先通过@Autowired注解注入了PlatformTransactionManager事务管理器。然后创建一个TransactionDefinition对象来定义事务的属性。接下来，通过调用transactionManager.getTransaction(definition)方法获取一个TransactionStatus对象来表示当前事务的状态。</p>\n\n<p>在try块中，编写了业务逻辑代码。如果业务逻辑执行成功，调用transactionManager.commit(status)方法提交事务。如果在try块中抛出了异常，会进入catch块，调用transactionManager.rollback(status)方法回滚事务。</p>\n\n<p>通过编程式事务管理，可以在需要的时候手动控制事务的开始、提交和回滚，以满足更复杂的事务场景。然而，相对于声明式事务管理，编程式事务管理需要更多的手动操作和代码编写。</p>\n\n<h2 id=\"三-异常触发事务回滚\">三. 异常触发事务回滚</h2>\n<p>在Spring中的事务回滚机制中，异常的抛出是触发事务回滚的重要因素之一。当在事务内部抛出特定类型的异常时，Spring会自动回滚事务，将所有已执行的数据库操作恢复到事务开始之前的状态。</p>\n\n<p>以下是关于异常触发事务回滚的几个要点：</p>\n\n<p><strong>默认回滚规则：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>默认情况下，Spring只有在遇到RuntimeException及其子类异常时才会触发事务回滚。\nRuntimeException是未检查异常，它的抛出通常表示程序运行时出现了严重错误。\nChecked异常（非RuntimeException的异常）不会触发事务回滚。\n</code></pre>  </div></div>\n\n<p><strong>异常回滚规则配置：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>可以通过@Transactional注解的rollbackFor属性来配置需要触发事务回滚的异常类型。\n例如，@Transactional(rollbackFor = {Exception.class})指示任何异常（包括RuntimeException和Checked异常）都将触发事务回滚。\n</code></pre>  </div></div>\n\n<p><strong>手动触发事务回滚：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>在某些情况下，可能希望手动触发事务回滚，而不是依赖异常的抛出。\n在方法中，可以使用TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()来手动将事务标记为回滚状态。\n调用该方法后，事务将在方法执行结束时回滚。\n</code></pre>  </div></div>\n\n<p>下面示例展示了异常触发事务回滚的情况：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Transactional\npublic void performTransaction() {\n    // 业务逻辑代码\n    if (someCondition) {\n        throw new RuntimeException(\"Something went wrong\");\n    }\n}\n\n</code></pre>  </div></div>\n<p>在上面的示例中，performTransaction()方法使用@Transactional注解来声明一个事务。如果在业务逻辑代码中满足了某个条件，会抛出RuntimeException，这将导致事务回滚。所有在抛出异常之前执行的数据库操作都将被回滚，保持数据的一致性。</p>\n\n<p>通过异常触发事务回滚，可以在遇到错误或异常情况时保证数据的完整性，避免数据不一致的问题。同时，也可以通过手动触发事务回滚来处理一些特殊情况，以满足更灵活的事务控制需求。</p>\n\n<h2 id=\"四-事务传播行为\">四. 事务传播行为</h2>\n\n<p>在Spring中，事务传播行为定义了事务方法与已经存在的事务之间的交互方式。事务传播行为决定了在方法调用链中如何处理事务边界，以及如何管理事务的隔离性、并发控制等方面的行为。</p>\n\n<p>以下是Spring中常见的事务传播行为：</p>\n\n<p><strong>REQUIRED（默认）：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>REQUIRED传播行为指示方法应该在已经存在的事务中执行。如果当前没有事务存在，则创建一个新事务。\n如果方法被嵌套调用，那么内部方法将使用外部方法的事务。\n</code></pre>  </div></div>\n\n<p><strong>REQUIRES_NEW：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>REQUIRES_NEW传播行为指示方法应该创建一个新的事务，并在执行期间挂起当前事务（如果存在）。\n如果方法被嵌套调用，内部方法将挂起外部方法的事务并创建一个新的事务。\n</code></pre>  </div></div>\n\n<p><strong>SUPPORTS：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>SUPPORTS传播行为指示方法应该在事务存在的情况下以事务方式执行。如果当前没有事务存在，那么方法将以非事务方式执行。\n</code></pre>  </div></div>\n\n<p><strong>NOT_SUPPORTED：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NOT_SUPPORTED传播行为指示方法应该以非事务方式执行。如果当前存在事务，那么该事务将被挂起。\n</code></pre>  </div></div>\n\n<p><strong>NEVER：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NEVER传播行为指示方法不应该在事务内部执行。如果当前存在事务，则抛出异常。\n</code></pre>  </div></div>\n\n<p><strong>MANDATORY：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>MANDATORY传播行为指示方法应该在已经存在的事务中执行。如果当前没有事务存在，则抛出异常。\n</code></pre>  </div></div>\n\n<p><strong>NESTED：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NESTED传播行为指示方法应该在一个已经存在的事务中执行，但是作为嵌套事务的一部分。\n如果当前没有事务存在，则创建一个新的事务。如果外部事务提交，嵌套事务也会被提交。如果外部事务回滚，嵌套事务会回滚到保存点。\n</code></pre>  </div></div>\n\n<p>在使用@Transactional注解或编程式事务管理时，可以指定适合需求的事务传播行为。通过选择正确的传播行为，可以确保事务在方法调用链中的正确传播和管理，以保证数据的一致性和完整性。</p>\n\n<p>以下示例展示了如何在Spring中使用事务传播行为：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Transactional(propagation = Propagation.REQUIRED)\npublic void outerMethod() {\n    // 业务逻辑代码\n    innerMethod();\n}\n\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void innerMethod() {\n    // 业务逻辑代码\n}\n\n</code></pre>  </div></div>\n<p>在上面的示例中，outerMethod()方法使用REQUIRED传播行为，默认情况下将参与到外部方法的事务中。而innerMethod()方法使用REQUIRES_NEW传播行为，它会创建一个新的事务并独立执行。无论outerMethod()方法的事务提交还是回滚，innerMethod()方法都创建一个新的事务。</p>\n\n<p><strong>总结：</strong>\nSpring的事务回滚机制通过注解或编程的方式提供了灵活的事务管理。它基于AOP和数据库的事务支持，允许开发人员在方法或类级别声明事务，并根据业务需求进行配置。通过合理使用事务的传播行为和异常处理，可以确保数据的一致性和完整性。</p>\n","dir":"/blog/development/java/jottings/","name":"2023-04-27_1.md","path":"blog/development/java/jottings/2023-04-27_1.md","url":"/blog/development/java/jottings/2023-04-27_1.html"},{"sort":2,"layout":"default","title":"redis如何设置密码","content":"<h1 id=\"redis如何设置密码\">redis如何设置密码</h1>\n\n<p>这里简单介绍一下redis如何设置密码，redis密码设置有三种种方式，<strong>一种在配置文件中设置密码，第二种在启动 Redis 时通过命令行参数设置密码，第三种使用 CONFIG 命令设置密码</strong></p>\n\n<h2 id=\"一-在配置文件中设置密码\">一. 在配置文件中设置密码</h2>\n\n<p><strong>第一步：</strong>打开 Redis 的配置文件。在大多数情况下，Redis 的配置文件名为 redis.conf，可以在 Redis 的安装目录中找到。</p>\n\n<p><strong>第二步：</strong>在配置文件中，找到 # requirepass 这一行。如果该行被注释掉了（以 # 开头），则需要取消注释。</p>\n\n<p><strong>第三步：</strong>在 # requirepass 后面的空格处，输入想要设置的密码。例如，requirepass YourPassword。</p>\n\n<p><strong>第四步：</strong>保存配置文件并重新启动 Redis 服务器，以使新的密码设置生效。</p>\n\n<h2 id=\"二-在启动-redis-时通过命令行参数设置密码\">二. 在启动 Redis 时通过命令行参数设置密码</h2>\n\n<p>可以在启动 Redis 服务器时通过命令行参数 -a 或 –requirepass 来设置密码。例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>redis-server --requirepass YourPassword\n</code></pre>  </div></div>\n\n<h2 id=\"三-使用-config-命令设置密码\">三. 使用 CONFIG 命令设置密码</h2>\n<p>在已经连接到 Redis 服务器的情况下，可以使用 CONFIG 命令来设置密码。使用命令来设置密码。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>config set requirepass 123456\n</code></pre>  </div></div>\n<p>无论使用哪种方式，设置密码后，连接到 Redis 服务器时都需要提供正确的密码才能进行操作。</p>\n\n<p><strong>注意事项：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>设置密码后，请妥善保存密码，并确保密码的安全性。\n如果使用 Redis 的集群模式，需要在每个节点上设置相同的密码。\n当密码设置后，通过 CONFIG 命令或修改配置文件来更改密码。 请注意，以上方式是基于 Redis 的标准配置。如果你使用的是 Redis 的特定版本或扩展，可能会有其他方式来设置密码。建议参考相应版本的文档或官方指南以了解更多详细信息。\n</code></pre>  </div></div>\n","dir":"/blog/development/tool/redis/","name":"2023-04-30_2.md","path":"blog/development/tool/redis/2023-04-30_2.md","url":"/blog/development/tool/redis/2023-04-30_2.html"},{"sort":2,"permalink":"/blog/frontier/new/","layout":"default","title":"新闻","content":"<h1 id=\"新闻\">新闻</h1>\n\n<ul>\n <li><a href=\"/blog/frontier/new/technology/\">科技</a>\n <ul>\n <li><a href=\"/blog/frontier/new/technology/2023-04-23_1.html\">ChatGpt</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/frontier/new/life/\">生活</a>\n <ul>\n <li><a href=\"/blog/frontier/new/life/2023-04-23_1.html\">2023年计划考试时间(全年)</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/frontier/new/","name":"README.md","path":"blog/frontier/new/README.md","url":"/blog/frontier/new/"},{"sort":2,"permalink":"/blog/development/","layout":"default","title":"开发技术","content":"<h1 id=\"开发技术\">开发技术</h1>\n\n<p>网站开发技术是网站的一个重要主题，笔者记录编程开发过程中的随笔和总结。</p>\n\n<!-- \n- [面试宝典](/blog/development/interview/)\n - [Java面试题](/blog/development/interview/java/)\n - [Java面试宝典一(2023最新Java面试题)](/blog/development/interview/java/2023-04-23_1.html)\n - [Java面试宝典二(2023最新Java面试题)](/blog/development/interview/java/2023-04-23_2.html)\n - [Java面试宝典三(2023最新Java面试题)](/blog/development/interview/java/2023-04-23_3.html)\n - [Java面试宝典四(2023最新Java面试题)](/blog/development/interview/java/2023-04-23_4.html)\n- [前端笔记](/blog/development/html/)\n - [随笔](/blog/development/html/jottings/)\n - [html页面如何设置适配移动端](/blog/development/html/jottings/2023-04-21_1.html)\n - [HTML页面中返回顶部的几种实现](/blog/development/html/jottings/2023-04-27_1.html)\n - [html表格导出excel有几种方式](/blog/development/html/jottings/2023-05-12_1.html)\n - [laydate渲染日期](/blog/development/html/jottings/2023-05-12_2.html)\n - [Html中CSS和JavaScript 文件添加版本号有哪些方式](/blog/development/html/jottings/2023-05-17_1.html)\n - [Jekyll网站开发](/blog/development/html/webdesign/)\n - [Jekyll安装配置和使用](/blog/development/html/webdesign/2023-04-24_1.html)\n - [七牛云对象存储(图床)免费使用](/blog/development/html/webdesign/2023-04-24_2.html)\n - [免费的Jekyll静态网站发布平台](/blog/development/html/webdesign/2023-05-12_1.html)\n - [SEO优化](/blog/development/html/seo/)\n - [NGINX强制使用https访问(http跳转到https)](/blog/development/html/seo/2023-04-27_1.html)\n - [最新主流搜索引擎提交sitemap大全（网站地图）](/blog/development/html/seo/2023-04-27_2.html)\n - [SEO实操小技巧关键字](/blog/development/html/seo/2023-04-27_3.html)\n- [Java语言](/blog/development/java/)\n - [随笔](/blog/development/java/jottings/)\n - [Java学习大纲路径](/blog/development/java/jottings/2023-04-23_1.html)\n - [Spring中的事务回滚机制](/blog/development/java/jottings/2023-04-27_1.html)\n - [Java开发环境安装配置JDK+Maven+Tomcat](/blog/development/java/jottings/2023-04-27_2.html)\n - [Restful风格开发方式](/blog/development/java/jottings/2023-05-12_1.html)\n - [Java8 新特性全面介绍](/blog/development/java/jottings/2023-05-18_1.html)\n - [Java基础](/blog/development/java/basics/)\n - [Java中map常见操作集合](/blog/development/java/basics/2023-04-24_1.html)\n - [Java中Json转换的常见操作方式](/blog/development/java/basics/2023-04-24_2.html)\n - [Java中计算List求和或List对象中某个字段的总和](/blog/development/java/basics/2023-04-24_3.html)\n - [Java中BigDecimal类型详解](/blog/development/java/basics/2023-04-27_1.html)\n - [Java框架](/blog/development/java/framework/)\n - [Spring Framework](/blog/development/java/framework/spring/)\n - [Spring IOC 容器](/blog/development/java/framework/spring/2023-05-18_1.html)\n - [Spring AOP使用](/blog/development/java/framework/spring/2023-05-18_2.html)\n - [Spring 访问数据库](/blog/development/java/framework/spring/2023-05-18_3.html)\n - [Spring 开发Web应用](/blog/development/java/framework/spring/2023-05-18_4.html)\n - [Spring 集成第三方组件](/blog/development/java/framework/spring/2023-05-18_5.html)\n - [工具包](/blog/development/java/tool/)\n - [EASYEXCEL使用详解](/blog/development/java/tool/2023-05-12_1.html)\n- [Python笔记](/blog/development/python/)\n - [随笔](/blog/development/python/jottings/)\n - [Django](/blog/development/python/django/)\n - [Django中url与path及re_path区别](/blog/development/python/django/2023-04-27_1.html)\n- [操作系统](/blog/development/os/)\n - [linux](/blog/development/os/linux/)\n - [Linux命令大全(Linux常用命令基础)](/blog/development/os/linux/2023-05-17_2.html)\n - [Linux命令大全(Linux常用命令进阶)](/blog/development/os/linux/2023-05-17_3.html)\n - [Linux的上传和下载功能](/blog/development/os/linux/2023-04-23_1.html)\n - [Centos防火墙配置](/blog/development/os/linux/2023-05-17_1.html)\n - [windows](/blog/development/os/windows/)\n - [Windows端口常见问题解决](/blog/development/os/windows/2023-04-27_1.html)\n - [Windows常用小技巧](/blog/development/os/windows/2023-05-17_1.html)\n- [工具](/blog/development/tool/)\n - [Redis](/blog/development/tool/redis/)\n - [Windows部署redis集群模式](/blog/development/tool/redis/2023-04-30_1.html)\n - [redis如何设置密码](/blog/development/tool/redis/2023-04-30_2.html)\n - [Git](/blog/development/tool/git/)\n - [最新Github创建仓库,将项目上传到GitHub](/blog/development/tool/git/2023-04-27_1.html)\n - [Git一份代码同时提交两个Git仓库](/blog/development/tool/git/2023-04-28_1.html)\n - [Git常用操作命令](/blog/development/tool/git/2023-05-12_1.html)\n - [Maven](/blog/development/tool/maven/)\n - [Maven推送本地jar包到仓库](/blog/development/tool/maven/2023-04-27_1.html)\n - [开发工具](/blog/development/tool/software/)\n - [软件开发者常用的工具有哪些(软件开发工具)？](/blog/development/tool/software/2023-05-17_1.html)\n - [Idea-Intellij IDEA常用功能及功能优化设置](/blog/development/tool/software/2023-05-17_2.html)\n - [Visual Studio Code常用功能及功能优化设置](/blog/development/tool/software/2023-05-17_3.html) -->\n","dir":"/blog/development/","name":"README.md","path":"blog/development/README.md","url":"/blog/development/"},{"sort":2,"permalink":"/blog/development/java/basics/","layout":"default","title":"Java基础","content":"<h1 id=\"java基础\">Java基础</h1>\n\n<ul>\n <li><a href=\"/blog/development/java/basics/2023-04-24_1.html\">Java中map常见操作集合</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_2.html\">Java中Json转换的常见操作方式</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_3.html\">Java中计算List求和或List对象中某个字段的总和</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-27_1.html\">Java中BigDecimal类型详解</a></li>\n</ul>\n","dir":"/blog/development/java/basics/","name":"README.md","path":"blog/development/java/basics/README.md","url":"/blog/development/java/basics/"},{"sort":2,"layout":"default","title":"Git一份代码同时提交两个Git仓库","content":"<h1 id=\"git一份代码同时提交两个git仓库\">Git一份代码同时提交两个Git仓库</h1>\n\n<h2 id=\"一-查看git仓库\">一. 查看Git仓库</h2>\n\n<p>首先查看Git代码绑定了哪些Git仓库</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git remote -v\n</code></pre>  </div></div>\n\n<p>如果当前代码没有绑定远端Git仓库，需要先确定Pull会从哪个仓库Pull，之后运行如下命令</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git remote add origin https://gitee.com/test/test123.git\n</code></pre>  </div></div>\n<h2 id=\"二-绑定多个远端仓库\">二. 绑定多个远端仓库</h2>\n\n<p>之后再绑定另外一个远端仓库，使Push的时候能同时Push两个仓库</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git remote set-url --add origin https://github.com/test/test123.git\n</code></pre>  </div></div>\n<p>这个时候查看远端仓库信息会有两个Push的远程仓库</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ git remote -v\norgin   https://github.com/test/test123.git (fetch)\norgin   https://github.com/test/test123.git (push)\norgin   https://gitee.com/test/test123.git (push)\n</code></pre>  </div></div>\n<p>之后再进行add commit push即可，会将代码同时Push到两个远程仓库中</p>\n\n<h2 id=\"三-移除指定远端仓库\">三. 移除指定远端仓库</h2>\n<p>git绑定多个远端仓库后，要移除 Git 中绑定的指定远程仓库，可以使用以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git remote remove &lt;remote-name&gt;\n</code></pre>  </div></div>\n<p>其中，<remote-name> 是要移除的远程仓库的名称。例如上一步用的分支是“orgin”，这块就填orgin。\n步骤如下：</remote-name></p>\n\n<p><strong>第一步：</strong>打开终端或命令行窗口，进入包含 Git 仓库的目录。</p>\n\n<p><strong>第二步：</strong>运行上述命令，将 <remote-name> 替换为要移除的远程仓库的名称。例如，如果要移除名为 \"origin\" 的远程仓库绑定，可以运行：</remote-name></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git remote remove origin\n</code></pre>  </div></div>\n<p><strong>第三步：</strong>运行命令后，Git 将会移除指定的远程仓库绑定。此时如果所有远程仓库的分支都是一个，那么得重新配置仓库了</p>\n\n<p><strong>注意：</strong>移除远程仓库绑定并不会删除远程仓库本身，它只是从本地 Git 仓库的配置中移除对应的远程仓库绑定信息。</p>\n","dir":"/blog/development/tool/git/","name":"2023-04-28_1.md","path":"blog/development/tool/git/2023-04-28_1.md","url":"/blog/development/tool/git/2023-04-28_1.html"},{"sort":2,"permalink":"/blog/development/html/","layout":"default","title":"前端笔记","content":"<h1 id=\"前端笔记\">前端笔记</h1>\n\n<ul>\n <li><a href=\"/blog/development/html/jottings/\">随笔</a>\n <ul>\n <li><a href=\"/blog/development/html/jottings/2023-04-21_1.html\">html页面如何设置适配移动端</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-04-27_1.html\">HTML页面中返回顶部的几种实现</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_1.html\">html表格导出excel有几种方式</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_2.html\">laydate渲染日期</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-17_1.html\">Html中CSS和JavaScript 文件添加版本号有哪些方式</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/html/webdesign/\">Jekyll网站开发</a>\n <ul>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_1.html\">Jekyll安装配置和使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_2.html\">七牛云对象存储(图床)免费使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-05-12_1.html\">免费的Jekyll静态网站发布平台</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/html/seo/\">SEO优化</a>\n <ul>\n <li><a href=\"/blog/development/html/seo/2023-04-27_1.html\">NGINX强制使用https访问(http跳转到https)</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_2.html\">最新主流搜索引擎提交sitemap大全（网站地图）</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_3.html\">SEO实操小技巧关键字</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/html/","name":"README.md","path":"blog/development/html/README.md","url":"/blog/development/html/"},{"sort":2,"layout":"default","title":"HTML页面中返回顶部的几种实现","content":"<h1 id=\"html页面中返回顶部的几种实现\">HTML页面中返回顶部的几种实现</h1>\n\n<p>最近在开发网站需要制作返回顶部按钮,但是我平时主要做后端开发,对前端不太熟练,经过网上资料查询,制作出了返回顶部的按钮,下面是两种简单的方式,记录一下.喜欢<a href=\"https://justmyfreedom.com/\">本网站</a>的朋友可以收藏下,会不定期更新学习资料.</p>\n\n<h2 id=\"一-引用外部jquery\">一. 引用外部jQuery</h2>\n\n<p>新建HTML页面,将下面代码复制保存,通过浏览器打开,即可看到效果.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;title&gt;doc&lt;/title&gt;\n&lt;style&gt;\n    .arrow{\n        border: 9px solid transparent;\n        border-bottom-color: #3DA0DB;\n        width: 0px;\n        height: 0px;\n        top:0px\n    }\n    .stick{\n        width: 8px;\n        height: 14px;\n        border-radius: 1px;\n        background-color: #3DA0DB;\n        top:15px;\n    }\n    #back_top div{\n        position: absolute;\n        margin: auto;\n        right: 0px;\n        left: 0px;\n    }\n    #back_top{\n        background-color: #dddddd;\n        height: 38px;\n        width: 38px;\n        border-radius: 3px;\n        display: block;\n        cursor: pointer;\n        position: fixed;\n        right: 50px;\n        bottom: 100px;\n        display: none;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div id=\"article\"&gt;&lt;/div&gt;\n&lt;div id=\"back_top\"&gt;\n&lt;div class=\"arrow\"&gt;&lt;/div&gt;\n&lt;div class=\"stick\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;script src=\"http://cdn.staticfile.org/jquery/1.11.1-rc2/jquery.min.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n$(function(){\n    for(var i =0 ;i &lt;100;i++){\n        $(\"#article\").append(\"&lt;p&gt;xxxxxxxxxx&lt;br&gt;&lt;/p&gt;\")\n    }\n\n})\n&lt;/script&gt;\n&lt;script&gt;\n$(function(){\n    $(window).scroll(function(){  //只要窗口滚动,就触发下面代码\n        var scrollt = document.documentElement.scrollTop + document.body.scrollTop; //获取滚动后的高度\n        if( scrollt &gt;200 ){  //判断滚动后高度超过200px,就显示\n            $(\"#back_top\").fadeIn(400); //淡入\n        }else{\n            $(\"#back_top\").stop().fadeOut(400); //如果返回或者没有超过,就淡出.必须加上stop()停止之前动画,否则会出现闪动\n        }\n    });\n    $(\"#back_top\").click(function(){ //当点击标签的时候,使用animate在200毫秒的时间内,滚到顶部\n        $(\"html,body\").animate({scrollTop:\"0px\"},200);\n    }); \n});\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>  </div></div>\n\n<h2 id=\"二-使用css及特殊图标进行设置\">二. 使用css及特殊图标进行设置</h2>\n<p>全代码打造简洁美观回到顶部按钮,同上,将代码复制进HTML文件中,打开即可看到效果.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;title&gt;doc&lt;/title&gt;\n&lt;style&gt;\n    #back_top{ \n\tdisplay:block;  \n\twidth:60px; \n\theight:60px;\n\tposition:fixed;  \n\tbottom:50px;  \n\tright:40px; \n\tborder-radius:10px 10px 10px 10px;   \n\ttext-decoration:none;  \n\tdisplay:none;  \n\tbackground-color:#999999;     \n\t}\n\t#back_top span{ \n\t\tdisplay:block; \n\t\twidth:60px; \n\t\tcolor:#dddddd; \n\t\tfont-size:40px; \n\t\ttext-align:center; \n\t\tmargin-top:4px;\n\t} \n\t#back_top span:hover{ \n\t\tcolor:#cccccc; \n\t} \n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div id=\"article\"&gt;&lt;/div&gt;\n&lt;a id=\"back_top\" href=\"script:;\"&gt;   \n  &lt;span&gt;⌆&lt;/span&gt; \n&lt;/a&gt;\n&lt;/div&gt;\n&lt;script&gt;\n$(function(){\n    for(var i =0 ;i &lt;100;i++){\n        $(\"#article\").append(\"&lt;p&gt;xxxxxxxxxx&lt;br&gt;&lt;/p&gt;\")\n    }\n})\n&lt;/script&gt;\n&lt;script&gt;\n$(function(){\n\t$(window).scroll(function(){  //只要窗口滚动,就触发下面代码 \n\t\tvar scrollt = document.documentElement.scrollTop + document.body.scrollTop; //获取滚动后的高度 \n\t\tif( scrollt &gt;200 ){  //判断滚动后高度超过200px,就显示  \n\t\t\t$(\"#back_top\").fadeIn(400); //淡出     \n\t\t}else{      \n\t\t\t$(\"#back_top\").stop().fadeOut(400); //如果返回或者没有超过,就淡入.必须加上stop()停止之前动画,否则会出现闪动   \n\t\t}\n\t});\n\t$(\"#back_top\").click(function(){ //当点击标签的时候,使用animate在200毫秒的时间内,滚到顶部\n\t\t\t$(\"html,body\").animate({scrollTop:\"0px\"},200);\n\t});\n});\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>  </div></div>\n<h2 id=\"三-使用锚点链接\">三. 使用锚点链接</h2>\n\n<p>在页面的底部或任意位置添加一个返回顶部的锚点链接，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;a href=\"#top\"&gt;返回顶部&lt;/a&gt;\n</code></pre>  </div></div>\n<p>然后在页面的顶部添加一个带有id属性为”top”的元素，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;div id=\"top\"&gt;&lt;/div&gt;\n</code></pre>  </div></div>\n<p>当用户点击返回顶部的链接时，页面将滚动到带有相应id的顶部元素。</p>\n\n<h2 id=\"第四种使用javascript滚动效果\">第四种：使用JavaScript滚动效果</h2>\n\n<p>可以使用JavaScript来实现平滑滚动到页面顶部的效果。例如，通过添加以下代码实现：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;button onclick=\"scrollToTop()\"&gt;返回顶部&lt;/button&gt;\n&lt;script&gt;\nfunction scrollToTop() {\n  window.scrollTo({\n    top: 0,\n    behavior: \"smooth\"\n  });\n}\n&lt;/script&gt;\n\n</code></pre>  </div></div>\n\n<p>当用户点击返回顶部的按钮时，页面将平滑滚动回顶部位置。</p>\n\n<p>以上是几种常见的实现返回顶部功能的方法。可以根据项目需求和个人喜好选择其中一种或结合使用。</p>\n","dir":"/blog/development/html/jottings/","name":"2023-04-27_1.md","path":"blog/development/html/jottings/2023-04-27_1.md","url":"/blog/development/html/jottings/2023-04-27_1.html"},{"sort":2,"layout":"default","title":"七牛云对象存储(图床)免费使用","content":"<h1 id=\"七牛云对象存储图床免费使用\">七牛云对象存储(图床)免费使用</h1>\n\n<h2 id=\"一-使用七牛云空间对象存储并设置自定义域名\">一. 使用七牛云空间对象存储并设置自定义域名</h2>\n<p>相信很多人都有搭建个人技术博客。但是在写博客时遇到的一个普遍问题是：在用 MarkDown格式语法写文章时，图片的上传和引用让人头疼，想要在文章里面插图片，但不知道放哪。</p>\n\n<p>这里给大家介绍一个存储图片的好地方，七牛云。</p>\n\n<p>七牛云是一家提供对象存储服务的云计算公司，其对象存储服务可以用来存储各种类型的文件，包括图片、视频、文档等等。其中，七牛云的对象存储服务还可以用来搭建图床，为博客、社交媒体等网站提供图片存储和分享服务。本文将介绍七牛云对象存储图床的使用方式和注意事项。</p>\n\n<p>最关键的是，注册就会有10G标准存储免费空间。下来介绍下使用方式。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424200055min.png\" alt=\"七牛云对象存储\" /></p>\n<h3 id=\"1注册七牛云账号\">1.注册七牛云账号</h3>\n<p>首先需要注册一个七牛云账号，注册后可以获得AccessKey和SecretKey，这两个密钥是使用七牛云对象存储服务的关键。</p>\n\n<p>注册后从右上角进入个人中心\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424200351min.png\" alt=\"注册七牛云账号\" /></p>\n\n<h3 id=\"2创建存储空间\">2.创建存储空间</h3>\n<p>登录七牛云控制台后，可以创建一个存储空间，用于存储图片等文件。在创建存储空间时，需要选择存储区域和存储类型等参数，根据自己的需求进行设置。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424200638min.png\" alt=\"七牛云创建存储空间\" /></p>\n\n<h3 id=\"3上传图片\">3.上传图片</h3>\n<p>在存储空间中上传图片，可以通过七牛云控制台、SDK、API等方式进行上传。上传成功后，会获得一个图片的URL地址。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424200850min.png\" alt=\"七牛云上传图片\" /></p>\n\n<h3 id=\"4使用图片\">4.使用图片</h3>\n<p>点击复制外链即可获得的图片URL地址，在需要的地方引用图片。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424201021min.png\" alt=\"七牛云使用图片\" /></p>\n\n<h2 id=\"二-七牛云自定义域名配置\">二. 七牛云自定义域名配置</h2>\n<p>注意：七牛云提供的外链域名会在30天内过期，如果想要长期使用，需要绑定自己域名，示例中用到的域名是在阿里服务商申请的</p>\n\n<h3 id=\"1配置自定义域名\">1.配置自定义域名</h3>\n<h4 id=\"七牛云空间新增自定义域名\">七牛云空间新增自定义域名</h4>\n<p>点击域名管理，绑定域名\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424201600min.png\" alt=\"七牛云空间新增自定义域名\" /></p>\n\n<p>在圈红的地方填写自己申请的域名即可，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>image.justmyfreedom.com/\n</code></pre>  </div></div>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424201709min.png\" alt=\"七牛云空间新增自定义域名\" /></p>\n\n<p>获取获取CNAME值\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424202414min.png\" alt=\"七牛云空间新增自定义域名\" /></p>\n\n<h4 id=\"配置域名映射\">配置域名映射</h4>\n<p>取域名服务商即域名申请网站配置，这里是在阿里云申请的，因此去阿里云配置。</p>\n\n<p>在阿里云的域名控制台中在域名的后面点击解析（七牛云的空间配置的哪个域名点击哪个域名的解析）</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424202917min.png\" alt=\"配置域名映射\" /></p>\n\n<p>添加记录的主机记录中请注意，如果你在绑定七牛云域名时直接用的域名，比如你注册的域名为</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>aaa.com\n</code></pre>  </div></div>\n\n<p>然后你在七牛云绑定域名时也是用的 aaa.com，那么在主机记录这里直接选择 @ 即可。如果在 aaa.com 的前面加了二级域名，比如是这样</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>bbb.aaa.com\n</code></pre>  </div></div>\n\n<p>那么主机记录这里添加 bbb 即可。\n @ 符代表直接解析主域名（不过一般不推荐直接使用 @，因为域名本身有一个A记录值，这样的话CNAME会和A记录值冲突）\n 主机记录添加 bbb，域名解析后就是 bbb.aaa.com</p>\n\n<p>按照圈起来的那条进行配置即可，因为我给域名增加了前缀，因此主机记录这里是image\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424203050min.png\" alt=\"配置域名映射\" /></p>\n\n<h4 id=\"查看配置cname是否成功\">查看配置CNAME是否成功</h4>\n<p>返回七牛云的域名管理，如图状态那里显示成功即可，然后在文件管理中复制一个图片外链，在浏览器中打开看是否成功。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424201600min.png\" alt=\"查看配置CNAME是否成功\" /></p>\n\n<h3 id=\"2-七牛云自定义域名配置阿里云ssl证书\">2. 七牛云自定义域名配置阿里云SSL证书</h3>\n\n<p> 配置证书前需要在七牛云的空间管理中配置了一个使用阿里云域名进行访问的空间。</p>\n\n<h4 id=\"获取阿里云域名证书\">获取阿里云域名证书</h4>\n\n<p>1、直接在阿里云的SSL证书中创建一个免费的证书即可<br />\n2、然后下载pem格式的证书文件（我下载的是pem的证书，其它的证书格式的没有试过，感兴趣的可以试试）<br />\n3、下载完证书之后然后解压，会出现两个文件，一个是<code class=\"language-plaintext highlighter-rouge\">.pem</code>结尾的文件，另一个是<code class=\"language-plaintext highlighter-rouge\">.key</code>结尾的文件</p>\n\n<h4 id=\"七牛云配置证书提升https访问\">七牛云配置证书（提升HTTPS访问）</h4>\n\n<p>1、在域名管理中找到HTTPS配置<br />\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424204122min.png\" alt=\"1、在域名管理中找到HTTPS配置\" />\n2、配置证书</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>证书的备注名填写你需要配置的域名；例如：img.image.com（我是用的是二级域名）\n证书内容直接将`.pem`文件中的内容全部复制粘贴进去即可\n证书私钥也是直接将`.key`文件中的内容全部复制粘贴进去\n填好之后点击确定输入你账号的密码即可，之后会有几小时等待审核的时间，快的话十几分钟。 点击配置后，根据以上步骤配置即可 ![1、在域名管理中找到HTTPS配置](https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424204156min.png)\n</code></pre>  </div></div>\n\n<h2 id=\"三-注意事项\">三. 注意事项：</h2>\n\n<p>1.安全问题：由于七牛云存储的是公开的文件，因此需要注意保护图片的安全性。可以通过设置存储空间的访问权限、使用图片防盗链等方式来加强图片的安全性。</p>\n\n<p>2.存储空间的容量和使用限制：七牛云的对象存储服务有一定的容量和使用限制，需要根据自己的需求进行选择和设置。</p>\n\n<p>3.文件命名和管理：在上传文件时，需要注意文件的命名和管理，以便于后续的使用和维护。建议使用有意义的文件名，并且对于大量的图片需要进行分类和整理。</p>\n\n<p>4.数据备份：由于存储在云端的数据可能会受到各种因素的影响，因此需要进行数据备份，以保障数据的安全性和可靠性。</p>\n\n","dir":"/blog/development/html/webdesign/","name":"2023-04-24_2.md","path":"blog/development/html/webdesign/2023-04-24_2.md","url":"/blog/development/html/webdesign/2023-04-24_2.html"},{"sort":2,"layout":"default","title":"Idea-Intellij IDEA常用功能及功能优化设置","content":"<h1 id=\"idea-intellij-idea常用功能及功能优化设置\">Idea-Intellij IDEA常用功能及功能优化设置</h1>\n\n<p>intellij idea是一款智能，功能强大的ide，对比eclipse或myeclipse，这里介绍下它的常用功能。</p>\n<h2 id=\"全局搜索介绍\">全局搜索介绍</h2>\n<p>它的搜索功能速度要快得多。它有多种搜索方式，</p>\n\n<h3 id=\"1-按照类名搜索快捷键ctrln\">1. 按照类名搜索快捷键(Ctrl+N)</h3>\n<p>按照类名搜索快捷键(Ctrl+N)，其中可以配置为Eclipse的类似风格(ctrl+shift+R) 输入类名可以定位到这个类文件</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517152020min.png\" alt=\"IDEA按照类名搜索快捷键\" /></p>\n\n<p>Idea在搜索过程之中可以使用类似百度的 用空格分隔 搜索多个词语 如下图所示：</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517152141min.png\" alt=\"IDEA按照类名搜索快捷键\" /></p>\n\n<p>可以搜索非本工程源码的类，如第三方Jar包或者JDK之中的类 但是需要选中下图的复选框，如果能匹配的自己写的类，优先匹配自己写的类\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517152432min.png\" alt=\"IDEA按照类名搜索快捷键\" /></p>\n\n<h3 id=\"2-按文件名搜索文件快捷键ctrlshiftn\">2. 按文件名搜索文件快捷键(Ctrl+Shift+N)</h3>\n<p>按文件名搜索文件快捷键(Ctrl+Shift+N)(搜索类类同，可以匹配所有类型的文件)</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517152725min.png\" alt=\"IDEA按文件名搜索文件快捷键\" /></p>\n\n<h3 id=\"3-查看类的继承关系快捷键ctrlh\">3. 查看类的继承关系快捷键(Ctrl+H)</h3>\n<p>查看类的继承关系(Ctrl+H) 例如TreeMap的父类是AbstractMap，子类则有一大堆</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517152958min.png\" alt=\"IDEA查看类的继承关系快捷键\" /></p>\n\n<h3 id=\"4-查看子类方法实现快捷键ctrlaltb\">4. 查看子类方法实现快捷键(Ctrl+Alt+B)</h3>\n<p>Ctrl+B可以查看父类或父方法定义，但是不如ctrl+鼠标左键方便。但是在这里，</p>\n\n<p>Ctrl+B或ctrl+鼠标左键只能看见Map接口的抽象方法put的定义，不是我们想要的，</p>\n\n<p>这时候Ctrl+Alt+B就可以查看HashMap的put方法</p>\n\n<h3 id=\"5-查找类或方法在哪些地方使用快捷键altf7\">5. 查找类或方法在哪些地方使用快捷键(Alt+F7)</h3>\n<p>查找类或方法在哪些地方使用,光标放在类名上，快捷键(Alt+F7) ,类似于eclipse 的ctrl+shif+H</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517153227min.png\" alt=\"IDEA查找类或方法在哪些地方使用快捷键\" /></p>\n\n<h3 id=\"6-按照文本的内容查找ctrlfctrlshiftf\">6. 按照文本的内容查找(Ctrl+F/Ctrl+Shift+F)</h3>\n\n<p>类似于eclipse的ctrl+H。其中Ctrl+F是在本页查找，Ctrl+Shift+F是全局查找</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517153415min.png\" alt=\"IDEA按照文本的内容查找\" /></p>\n\n<h3 id=\"7-搜索任何东西shift双击两次\">7. 搜索任何东西Shift(双击两次)</h3>\n\n<p>可搜索类、资源、配置项、方法等，还能搜索路径。其中搜索路径非常实用，例如你写了一个功能叫BaseContr，在java，js，css，jsp中都有hello的文件夹，那我们可以搜索”BaseContr/”找到路径中包含hello的文件夹</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517153531min.png\" alt=\"IDEA搜索任何东西Shift(双击两次)\" /></p>\n\n<h2 id=\"安装和使用lombok\">安装和使用Lombok</h2>\n\n<p>在项目中使用Lombok可以减少很多重复代码的书写。比如说getter/setter/toString等方法的编写。</p>\n\n<h3 id=\"1-在线安装方式\">1. 在线安装方式</h3>\n<p>IDEA中的安装，打开IDEA的Setting –&gt; 选择Plugins选项 –&gt; 选择Browse repositories –&gt; 搜索lombok –&gt; 点击安装 –&gt; 安装完成重启IDEA –&gt; 安装成功</p>\n\n<h3 id=\"2-下载本地安装方式\">2. 下载本地安装方式</h3>\n<p>可能有时候在线安装不了。内网可通过插件的方式安装。插件下载地址：https://github.com/mplushnikov/lombok-intellij-plugin</p>\n\n<p>Plugins -&gt; Install plugin from disk… 选择下载的zip包安装，重启idea即可。</p>\n\n<h3 id=\"3-lombok有哪些注解\">3. Lombok有哪些注解</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Setter\n@Getter\n@Data\n@Log(这是一个泛型注解，具体有很多种形式)\n@AllArgsConstructor\n@NoArgsConstructor\n@EqualsAndHashCode\n@NonNull\n@Cleanup\n@ToString\n@RequiredArgsConstructor\n@Value\n@SneakyThrows\n@Synchronized\n</code></pre>  </div></div>\n\n<h2 id=\"功能优化\">功能优化</h2>\n\n<h3 id=\"设置提示词忽略大小写\">设置提示词忽略大小写</h3>\n<p>把这个勾去掉，（有的idea版本是选择选项 选择none即可），例如String 输入string 、String 都可以提示</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517154656min.png\" alt=\"IDEA设置提示词忽略大小写\" /></p>\n\n<h3 id=\"关闭代码检查\">关闭代码检查</h3>\n<p>与eclipse类似，idea也可以自己关闭代码检查 减少资源使用，但不推荐全部关闭，（是大佬当我没说），把我们项目中不会使用到的关闭就好了</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517154858min.png\" alt=\"IDEA关闭代码检查\" /></p>\n\n<h3 id=\"设置多行tab\">设置多行tab</h3>\n<p>idea默认是选择显示单行的，我们把这个去掉，就可以显示多行tab了，在打开tab过多时的场景非常方便！\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517155115min.png\" alt=\"IDEA设置多行tab\" /></p>\n\n<h3 id=\"自动导包自动移除没用的包\">自动导包、自动移除没用的包</h3>\n<h4 id=\"自动\">自动</h4>\n<p>自动导包、自动移除没用的包</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517155402min.png\" alt=\"IDEA自动导包自动移除没用的包\" /></p>\n\n<h4 id=\"手动\">手动</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>手动导包快捷键 :alt+enter \n手动移除未使用包快捷键: crtl+alt+o\n</code></pre>  </div></div>\n\n<h3 id=\"微服务项目中-将不同项目添加到同一个启动窗口\">微服务项目中 将不同项目添加到同一个启动窗口</h3>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517155720min.png\" alt=\"Java微服务项目中将不同项目添加到同一个启动窗口\" /></p>\n\n<p>步骤：View ——&gt;Tool Windows ——&gt; services ——&gt;add services</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517155749min.png\" alt=\"Java微服务项目中将不同项目添加到同一个启动窗口\" /></p>\n\n<h3 id=\"javampper层代码文件和mapperxml文件相互跳转\">javaMpper层代码文件和mapper.xml文件相互跳转</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>FreeMyBatisplugin 插件\n</code></pre>  </div></div>\n\n<p>点击绿色箭头可以直接跳转 非常方便\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517160127min.png\" alt=\"javaMpper层代码文件和mapper.xml文件相互跳转\" /></p>\n","dir":"/blog/development/tool/software/","name":"2023-05-17_2.md","path":"blog/development/tool/software/2023-05-17_2.md","url":"/blog/development/tool/software/2023-05-17_2.html"},{"sort":2,"permalink":"/blog/development/os/windows/","layout":"default","title":"windows","content":"<h1 id=\"windows\">windows</h1>\n\n<ul>\n <li><a href=\"/blog/development/os/windows/2023-04-27_1.html\">Windows端口常见问题解决</a></li>\n <li><a href=\"/blog/development/os/windows/2023-05-17_1.html\">Windows常用小技巧</a></li>\n</ul>\n","dir":"/blog/development/os/windows/","name":"README.md","path":"blog/development/os/windows/README.md","url":"/blog/development/os/windows/"},{"sort":2,"layout":"default","title":"Linux命令大全(Linux常用命令进阶)","content":"<h1 id=\"linux命令大全linux常用命令进阶\">Linux命令大全(Linux常用命令进阶)</h1>\n\n<p>这篇是基于上篇的进阶版</p>\n\n<h2 id=\"一-文本操作\">一. 文本操作</h2>\n\n<h3 id=\"1-grep\">1. grep</h3>\n\n<p>全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。</p>\n\n<h4 id=\"基础语法\">基础语法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>grep text file # text代表要搜索的文本，file代表供搜索的文件\n \n# 实例\n[root@lion ~]# grep path /etc/profile\npathmunge () {\n    pathmunge /usr/sbin\n    pathmunge /usr/local/sbin\n    pathmunge /usr/local/sbin after\n    pathmunge /usr/sbin after\nunset -f pathmunge\n</code></pre>  </div></div>\n\n<h4 id=\"常用参数\">常用参数</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-i</code> 忽略大小写， <code class=\"language-plaintext highlighter-rouge\">grep -i path /etc/profile</code></li>\n <li><code class=\"language-plaintext highlighter-rouge\">-n</code> 显示行号，<code class=\"language-plaintext highlighter-rouge\">grep -n path /etc/profile</code></li>\n <li><code class=\"language-plaintext highlighter-rouge\">-v</code> 只显示搜索文本不在的那些行，<code class=\"language-plaintext highlighter-rouge\">grep -v path /etc/profile</code></li>\n <li><code class=\"language-plaintext highlighter-rouge\">-r</code> 递归查找， <code class=\"language-plaintext highlighter-rouge\">grep -r hello /etc</code> ，Linux 中还有一个 rgrep 命令，作用相当于 <code class=\"language-plaintext highlighter-rouge\">grep -r</code></li>\n</ul>\n\n<h4 id=\"高级用法\">高级用法</h4>\n\n<p><code class=\"language-plaintext highlighter-rouge\">grep</code> 可以配合正则表达式使用。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>grep -E path /etc/profile --&gt; 完全匹配path\ngrep -E ^path /etc/profile --&gt; 匹配path开头的字符串\ngrep -E [Pp]ath /etc/profile --&gt; 匹配path或Path\n</code></pre>  </div></div>\n\n<h3 id=\"2-sort\">2. sort</h3>\n\n<p>对文件的行进行排序。</p>\n\n<h4 id=\"基础语法-1\">基础语法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sort name.txt # 对name.txt文件进行排序\n</code></pre>  </div></div>\n\n<h4 id=\"实例用法\">实例用法</h4>\n\n<p>为了演示方便，我们首先创建一个文件 <code class=\"language-plaintext highlighter-rouge\">name.txt</code> ，放入以下内容：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Christopher\nShawn\nTed\nRock\nNoah\nZachary\nBella\n</code></pre>  </div></div>\n\n<p>执行 <code class=\"language-plaintext highlighter-rouge\">sort name.txt</code> 命令，会对文本内容进行排序。</p>\n\n<h4 id=\"常用参数-1\">常用参数</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-o</code> 将排序后的文件写入新文件， <code class=\"language-plaintext highlighter-rouge\">sort -o name_sorted.txt name.txt</code> ；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-r</code> 倒序排序， <code class=\"language-plaintext highlighter-rouge\">sort -r name.txt</code> ；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-R</code> 随机排序， <code class=\"language-plaintext highlighter-rouge\">sort -R name.txt</code> ；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-n</code> 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 <code class=\"language-plaintext highlighter-rouge\">-n</code> 数字排序的话，则 25 会在 138 前面。</li>\n</ul>\n\n<h3 id=\"3-wc\">3. wc</h3>\n\n<p><code class=\"language-plaintext highlighter-rouge\">word count</code> 的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。</p>\n\n<h4 id=\"基础语法-2\">基础语法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>wc name.txt # 统计name.txt\n</code></pre>  </div></div>\n\n<h4 id=\"实例用法-1\">实例用法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[root@lion ~]# wc name.txt \n13 13 91 name.txt\n</code></pre>  </div></div>\n\n<ul>\n <li>第一个13，表示行数；</li>\n <li>第二个13，表示单词数；</li>\n <li>第三个91，表示字节数。</li>\n</ul>\n\n<h4 id=\"常用参数-2\">常用参数</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-l</code> 只统计行数， <code class=\"language-plaintext highlighter-rouge\">wc -l name.txt</code> ；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-w</code> 只统计单词数， <code class=\"language-plaintext highlighter-rouge\">wc -w name.txt</code> ；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-c</code> 只统计字节数， <code class=\"language-plaintext highlighter-rouge\">wc -c name.txt</code> ；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-m</code> 只统计字符数， <code class=\"language-plaintext highlighter-rouge\">wc -m name.txt</code> 。</li>\n</ul>\n\n<h3 id=\"4-uniq\">4. uniq</h3>\n\n<p>删除文件中的重复内容。</p>\n\n<h4 id=\"基础语法-3\">基础语法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>uniq name.txt # 去除name.txt重复的行数，并打印到屏幕上\nuniq name.txt uniq_name.txt # 把去除重复后的文件保存为 uniq_name.txt\n</code></pre>  </div></div>\n\n<p>【注意】它只能去除连续重复的行数。</p>\n\n<h4 id=\"常用参数-3\">常用参数</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-c</code> 统计重复行数， <code class=\"language-plaintext highlighter-rouge\">uniq -c name.txt</code> ；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-d</code> 只显示重复的行数， <code class=\"language-plaintext highlighter-rouge\">uniq -d name.txt</code> 。</li>\n</ul>\n\n<h3 id=\"5-cut\">5. cut</h3>\n\n<p>剪切文件的一部分内容。</p>\n\n<h4 id=\"基础语法-4\">基础语法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cut -c 2-4 name.txt # 剪切每一行第二到第四个字符\n</code></pre>  </div></div>\n\n<h4 id=\"常用参数-4\">常用参数</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-d</code> 用于指定用什么分隔符（比如逗号、分号、双引号等等） <code class=\"language-plaintext highlighter-rouge\">cut -d , name.txt</code> ；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-f</code> 表示剪切下用分隔符分割的哪一块或哪几块区域， <code class=\"language-plaintext highlighter-rouge\">cut -d , -f 1 name.txt</code> 。</li>\n</ul>\n\n<h2 id=\"二-重定向-管道-流\">二. 重定向 管道 流</h2>\n\n<p>在 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 中一个命令的去向可以有3个地方：终端、文件、作为另外一个命令的入参。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517104932min.png\" alt=\"重定向 管道 流\" /></p>\n\n<p>命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 <code class=\"language-plaintext highlighter-rouge\">stdin</code> 、 <code class=\"language-plaintext highlighter-rouge\">stdout</code> 以及 <code class=\"language-plaintext highlighter-rouge\">stderr</code> 。</p>\n\n<ul>\n <li>标准输入 <code class=\"language-plaintext highlighter-rouge\">stdin</code> ，终端接收键盘输入的命令，会产生两种输出；</li>\n <li>标准输出 <code class=\"language-plaintext highlighter-rouge\">stdout</code> ，终端输出的信息（不包含错误信息）；</li>\n <li>标准错误输出 <code class=\"language-plaintext highlighter-rouge\">stderr</code> ，终端输出的错误信息。</li>\n</ul>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517105138min.png\" alt=\"重定向 管道 流\" /></p>\n\n<h3 id=\"1-重定向\">1. 重定向</h3>\n\n<p>把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。</p>\n\n<h4 id=\"输出重定向-\">输出重定向 <code class=\"language-plaintext highlighter-rouge\">&gt;</code></h4>\n\n<p><code class=\"language-plaintext highlighter-rouge\">&gt;</code> 表示重定向到新的文件， <code class=\"language-plaintext highlighter-rouge\">cut -d , -f 1 notes.csv &gt; name.csv</code> ，它表示通过逗号剪切 <code class=\"language-plaintext highlighter-rouge\">notes.csv</code> 文件（剪切完有3个部分）获取第一个部分，重定向到 <code class=\"language-plaintext highlighter-rouge\">name.csv</code> 文件。</p>\n\n<p>我们来看一个具体示例，学习它的使用，假设我们有一个文件 <code class=\"language-plaintext highlighter-rouge\">notes.csv</code> ，文件内容如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Mark1,951/100,很不错1\nMark2,952/100,很不错2\nMark3,953/100,很不错3\nMark4,954/100,很不错4\nMark5,955/100,很不错5\nMark6,956/100,很不错6\n</code></pre>  </div></div>\n\n<p>执行命令： <code class=\"language-plaintext highlighter-rouge\">cut -d , -f 1 notes.csv &gt; name.csv</code> 最后输出如下内容：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Mark1\nMark2\nMark3\nMark4\nMark5\nMark6\n</code></pre>  </div></div>\n\n<p>【注意】使用 <code class=\"language-plaintext highlighter-rouge\">&gt;</code> 要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。</p>\n\n<h4 id=\"输出重定向--1\">输出重定向 <code class=\"language-plaintext highlighter-rouge\">&gt;&gt;</code></h4>\n\n<p>表示重定向到文件末尾，因此它不会像 <code class=\"language-plaintext highlighter-rouge\">&gt;</code> 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。</p>\n\n<p>再次执行 <code class=\"language-plaintext highlighter-rouge\">cut -d , -f 1 notes.csv &gt;&gt; name.csv</code> ，则会把名字追加到 <code class=\"language-plaintext highlighter-rouge\">name.csv</code> 里面。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Mark1\nMark2\nMark3\nMark4\nMark5\nMark6\nMark1\nMark2\nMark3\nMark4\nMark5\nMark6\n</code></pre>  </div></div>\n\n<p>我们平时读的 <code class=\"language-plaintext highlighter-rouge\">log</code> 日志文件其实都是用这个命令输出的。</p>\n\n<h4 id=\"输出重定向-2\">输出重定向 <code class=\"language-plaintext highlighter-rouge\">2&gt;</code></h4>\n\n<p>标准错误输出</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cat not_exist_file.csv &gt; res.txt 2&gt; errors.log\n</code></pre>  </div></div>\n\n<ul>\n <li>当我们 <code class=\"language-plaintext highlighter-rouge\">cat</code> 一个文件时，会把文件内容打印到屏幕上，这个是标准输出；</li>\n <li>当使用了 <code class=\"language-plaintext highlighter-rouge\">&gt; res.txt</code> 时，则不会打印到屏幕，会把标准输出写入文件 <code class=\"language-plaintext highlighter-rouge\">res.txt</code> 文件中；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">2&gt; errors.log</code> 当发生错误时会写入 <code class=\"language-plaintext highlighter-rouge\">errors.log</code> 文件中。</li>\n</ul>\n\n<h4 id=\"输出重定向-2-1\">输出重定向 <code class=\"language-plaintext highlighter-rouge\">2&gt;&gt;</code></h4>\n\n<p>标准错误输出（追加到文件末尾）同 <code class=\"language-plaintext highlighter-rouge\">&gt;&gt;</code> 相似。</p>\n\n<h4 id=\"输出重定向-21\">输出重定向 <code class=\"language-plaintext highlighter-rouge\">2&gt;&amp;1</code></h4>\n\n<p>标准输出和标准错误输出都重定向都一个地方</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cat not_exist_file.csv &gt; res.txt 2&gt;&amp;1  # 覆盖输出\ncat not_exist_file.csv &gt;&gt; res.txt 2&gt;&amp;1 # 追加输出\n</code></pre>  </div></div>\n\n<p>目前为止，我们接触的命令的输入都来自命令的参数，其实命令的输入还可以来自文件或者键盘的输入。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517105321min.png\" alt=\"输出重定向\" /></p>\n\n<h4 id=\"输入重定向-\">输入重定向 <code class=\"language-plaintext highlighter-rouge\">&lt;</code></h4>\n\n<p><code class=\"language-plaintext highlighter-rouge\">&lt;</code> 符号用于指定命令的输入。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cat &lt; name.csv # 指定命令的输入为 name.csv\n</code></pre>  </div></div>\n\n<p>虽然它的运行结果与 <code class=\"language-plaintext highlighter-rouge\">cat name.csv</code> 一样，但是它们的原理却完全不同。</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">cat name.csv</code> 表示 <code class=\"language-plaintext highlighter-rouge\">cat</code> 命令接收的输入是 <code class=\"language-plaintext highlighter-rouge\">notes.csv</code> 文件名，那么要先打开这个文件，然后打印出文件内容。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">cat &lt; name.csv</code> 表示 <code class=\"language-plaintext highlighter-rouge\">cat</code> 命令接收的输入直接是 <code class=\"language-plaintext highlighter-rouge\">notes.csv</code> 这个文件的内容， <code class=\"language-plaintext highlighter-rouge\">cat</code> 命令只负责将其内容打印，打开文件并将文件内容传递给 <code class=\"language-plaintext highlighter-rouge\">cat</code> 命令的工作则交给终端完成。</li>\n</ul>\n\n<h4 id=\"输入重定向--1\">输入重定向 <code class=\"language-plaintext highlighter-rouge\">&lt;&lt;</code></h4>\n\n<p>将键盘的输入重定向为某个命令的输入。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sort -n &lt;&lt; END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）\nwc -m &lt;&lt; END # 统计输入的单词\n</code></pre>  </div></div>\n\n<h3 id=\"2-管道-\">2. 管道 <code class=\"language-plaintext highlighter-rouge\">|</code></h3>\n\n<p>把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 <code class=\"language-plaintext highlighter-rouge\">pipeline</code> ，可以想象一个个水管连接起来，管道算是重定向流的一种。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517105425min.png\" alt=\"管道\" /></p>\n\n<p>举几个实际用法案例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cut -d , -f 1 name.csv | sort &gt; sorted_name.txt \n# 第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt\n \ndu | sort -nr | head \n# du 表示列举目录大小信息\n# sort 进行排序,-n 表示按数字排序，-r 表示倒序\n# head 前10行文件\n \ngrep log -Ir /var/log | cut -d : -f 1 | sort | uniq\n# grep log -Ir /var/log 表示在log文件夹下搜索 /var/log 文本，-r 表示递归，-I 用于排除二进制文件\n# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分\n# sort 进行排序\n# uniq 进行去重\n</code></pre>  </div></div>\n\n<h3 id=\"3-流\">3. 流</h3>\n\n<p>流并非一个命令，在计算机科学中，流 <code class=\"language-plaintext highlighter-rouge\">stream</code> 的含义是比较难理解的，记住一点即可：<strong>「流就是读一点数据, 处理一点点数据。其中数据一般就是二进制格式。」</strong> 上面提及的重定向或管道，就是把数据当做流去运转的。</p>\n\n<p>到此我们就接触了，流、重定向、管道等 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 高级概念及指令。其实你会发现关于流和管道在其它语言中也有广泛的应用。 <code class=\"language-plaintext highlighter-rouge\">Angular</code> 中的模板语法中可以使用管道。 <code class=\"language-plaintext highlighter-rouge\">Node.js</code> 中也有 <code class=\"language-plaintext highlighter-rouge\">stream</code> 流的概念。</p>\n\n<h2 id=\"三-查看进程\">三. 查看进程</h2>\n\n<p>在 <code class=\"language-plaintext highlighter-rouge\">Windows</code> 中通过 <code class=\"language-plaintext highlighter-rouge\">Ctrl + Alt + Delete</code> 快捷键查看软件进程。</p>\n\n<h3 id=\"1-w\">1. w</h3>\n\n<p>帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[root@lion ~]# w\n 06:31:53 up 25 days,  9:53,  1 user,  load average: 0.00, 0.01, 0.05\nUSER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT\nroot     pts/0    118.31.243.53    05:56    1.00s  0.02s  0.00s w\n \n06:31:53：表示当前时间\nup 25 days, 9:53：表示系统已经正常运行了“25天9小时53分钟”\n1 user：表示一个用户\nload average: 0.00, 0.01, 0.05：表示系统的负载，3个值分别表示“1分钟的平均负载”，“5分钟的平均负载”，“15分钟的平均负载”\n \n USER：表示登录的用于\n TTY：登录的终端名称为pts/0\n FROM：连接到服务器的ip地址\n LOGIN@：登录时间\n IDLE：用户有多久没有活跃了\n JCPU：该终端所有相关的进程使用的 CPU 时间，每当进程结束就停止计时，开始新的进程则会重新计时\n PCPU：表示 CPU 执行当前程序所消耗的时间，当前进程就是在 WHAT 列里显示的程序\n WHAT：表示当下用户正运行的程序是什么，这里我运行的是 w\n</code></pre>  </div></div>\n\n<h3 id=\"2-ps\">2. ps</h3>\n\n<p>用于显示当前系统中的进程， <code class=\"language-plaintext highlighter-rouge\">ps</code> 命令显示的进程列表不会随时间而更新，是静态的，是运行 <code class=\"language-plaintext highlighter-rouge\">ps</code> 命令那个时刻的状态或者说是一个进程快照。</p>\n\n<h4 id=\"基础语法-5\">基础语法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[root@lion ~]# ps\n  PID TTY          TIME CMD\n 1793 pts/0    00:00:00 bash\n 4756 pts/0    00:00:00 ps\n \n PID：进程号，每个进程都有唯一的进程号\n TTY：进程运行所在的终端\n TIME：进程运行时间\n CMD：产生这个进程的程序名，如果在进程列表中看到有好几行都是同样的程序名，那么就是同样的程序产生了不止一个进程\n</code></pre>  </div></div>\n\n<h4 id=\"常用参数-5\">常用参数</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-ef</code> 列出所有进程;</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-efH</code> 以乔木状列举出所有进程;</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-u</code> 列出此用户运行的进程;</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-aux</code> 通过 <code class=\"language-plaintext highlighter-rouge\">CPU</code> 和内存使用来过滤进程 <code class=\"language-plaintext highlighter-rouge\">ps -aux | less</code> ;</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-aux --sort -pcpu</code> 按 <code class=\"language-plaintext highlighter-rouge\">CPU</code> 使用降序排列， <code class=\"language-plaintext highlighter-rouge\">-aux --sort -pmem</code> 表示按内存使用降序排列;</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-axjf</code> 以树形结构显示进程， <code class=\"language-plaintext highlighter-rouge\">ps -axjf</code> 它和 <code class=\"language-plaintext highlighter-rouge\">pstree</code> 效果类似。</li>\n</ul>\n\n<h3 id=\"3-top\">3. top</h3>\n\n<p>获取进程的动态列表。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>top - 07:20:07 up 25 days, 10:41,  1 user,  load average: 0.30, 0.10, 0.07\nTasks:  67 total,   1 running,  66 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  1882072 total,   552148 free,   101048 used,  1228876 buff/cache\nKiB Swap:        0 total,        0 free,        0 used.  1594080 avail Mem \n \n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                                       \n  956 root      10 -10  133964  15848  10240 S  0.7  0.8 263:13.01 AliYunDun                                                                                                     \n    1 root      20   0   51644   3664   2400 S  0.0  0.2   3:23.63 systemd                                                                                                       \n    2 root      20   0       0      0      0 S  0.0  0.0   0:00.05 kthreadd                                                                                                      \n    4 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H\n</code></pre>  </div></div>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">top - 07:20:07 up 25 days, 10:41, 1 user, load average: 0.30, 0.10, 0.07</code> 相当 <code class=\"language-plaintext highlighter-rouge\">w</code> 命令的第一行的信息。</li>\n <li>展示的这些进程是按照使用处理器 <code class=\"language-plaintext highlighter-rouge\">%CPU</code> 的使用率来排序的。</li>\n</ul>\n\n<h3 id=\"4-kill\">4. kill</h3>\n\n<p>结束一个进程， <code class=\"language-plaintext highlighter-rouge\">kill + PID</code> 。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>kill 956 # 结束进程号为956的进程\nkill 956 957 # 结束多个进程\nkill -9 7291 # 强制结束进程\n</code></pre>  </div></div>\n\n<h2 id=\"四-管理进程\">四. 管理进程</h2>\n\n<h3 id=\"1-进程状态\">1. 进程状态</h3>\n\n<p>主要是切换进程的状态。我们先了解下 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 下进程的五种状态：</p>\n\n<ol>\n <li>状态码 <code class=\"language-plaintext highlighter-rouge\">R</code> ：表示正在运行的状态；</li>\n <li>状态码 <code class=\"language-plaintext highlighter-rouge\">S</code> ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；</li>\n <li>状态码 <code class=\"language-plaintext highlighter-rouge\">D</code> ：表示不可中断（进程不响应系统异步信号，即使用kill命令也不能使其中断）；</li>\n <li>状态码 <code class=\"language-plaintext highlighter-rouge\">Z</code> ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 <code class=\"language-plaintext highlighter-rouge\">wait4()</code> 系统函数后将进程释放）；</li>\n <li>状态码 <code class=\"language-plaintext highlighter-rouge\">T</code> ：表示停止（进程收到 <code class=\"language-plaintext highlighter-rouge\">SIGSTOP</code> 、 <code class=\"language-plaintext highlighter-rouge\">SIGSTP</code> 、 <code class=\"language-plaintext highlighter-rouge\">SIGTIN</code> 、 <code class=\"language-plaintext highlighter-rouge\">SIGTOU</code> 等停止信号后停止运行）。</li>\n</ol>\n\n<h3 id=\"2-前台进程--后台进程\">2. 前台进程 &amp; 后台进程</h3>\n\n<p>默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行 <code class=\"language-plaintext highlighter-rouge\">top</code> 命令，这就是一个一直运行的前台进程。</p>\n\n<p>后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加 <code class=\"language-plaintext highlighter-rouge\">&amp;</code> 符号，就表示启动一个后台进程。</p>\n\n<h3 id=\"3-\">3. &amp;</h3>\n\n<p>启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cp name.csv name-copy.csv &amp;\n</code></pre>  </div></div>\n\n<h3 id=\"4-nohup\">4. nohup</h3>\n\n<p>使进程不受挂断（关闭终端等动作）的影响。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>nohup cp name.csv name-copy.csv\n</code></pre>  </div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">nohup</code> 命令也可以和 <code class=\"language-plaintext highlighter-rouge\">&amp;</code> 结合使用。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>nohup cp name.csv name-copy.csv &amp;\n</code></pre>  </div></div>\n\n<h3 id=\"5-bg\">5. bg</h3>\n\n<p>使一个“后台暂停运行”的进程，状态改为“后台运行”。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>bg %1 # 不加任何参数的情况下，bg命令会默认作用于最近的一个后台进程，如果添加参数则会作用于指定标号的进程\n</code></pre>  </div></div>\n\n<p>实际案例1：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. 执行 grep -r \"log\" / &gt; grep_log 2&gt;&amp;1 命令启动一个前台进程，并且忘记添加 &amp; 符号\n2. ctrl + z 使进程状态转为后台暂停\n3. 执行 bg 将命令转为后台运行\n</code></pre>  </div></div>\n\n<p>实际案例2：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>前端开发时我们经常会执行 yarn start 启动项目\n此时我们执行 ctrl + z 先使其暂停\n然后执行 bg 使其转为后台运行\n这样当前终端就空闲出来可以干其它事情了，如果想要唤醒它就使用 fg 命令即可（后面会讲）\n</code></pre>  </div></div>\n\n<h3 id=\"6-jobs\">6. jobs</h3>\n\n<p>显示当前终端后台进程状态。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[root@lion ~]# jobs\n[1]+  Stopped                 top\n[2]-  Running                 grep --color=auto -r \"log\" / &gt; grep_log 2&gt;&amp;1 &amp;\n</code></pre>  </div></div>\n\n<h3 id=\"7-fg\">7. fg</h3>\n\n<p><code class=\"language-plaintext highlighter-rouge\">fg</code> 使进程转为前台运行，用法和 <code class=\"language-plaintext highlighter-rouge\">bg</code> 命令类似。</p>\n\n<p>我们用一张图来表示前后台进程切换：</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517105713min.png\" alt=\"fg\" /></p>\n\n<p>我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结束。</p>\n\n<h2 id=\"五-守护进程\">五. 守护进程</h2>\n\n<p>一个运行起来的程序被称为进程。在 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 中有些进程是特殊的，它不与任何进程关联，不论用户的身份如何，都在后台运行，这些进程的父进程是 <code class=\"language-plaintext highlighter-rouge\">PID</code> 为1的进程， <code class=\"language-plaintext highlighter-rouge\">PID</code> 为1的进程只在系统关闭时才会被销毁。它们会在后台一直运行等待分配工作。我们将这类进程称之为守护进程 <code class=\"language-plaintext highlighter-rouge\">daemon</code> 。</p>\n\n<p>守护进程的名字通常会在最后有一个 <code class=\"language-plaintext highlighter-rouge\">d</code> ，表示 <code class=\"language-plaintext highlighter-rouge\">daemon</code> 守护的意思，例如 <code class=\"language-plaintext highlighter-rouge\">systemd</code> 、<code class=\"language-plaintext highlighter-rouge\">httpd</code> 。</p>\n\n<h3 id=\"1-systemd\">1. systemd</h3>\n\n<p><code class=\"language-plaintext highlighter-rouge\">systemd</code> 是一个 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 系统基础组件的集合，提供了一个系统和服务管理器，运行为 <code class=\"language-plaintext highlighter-rouge\">PID 1</code> 并负责启动其它程序。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[root@lion ~]# ps -aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\n\nroot         1  0.0  0.2  51648  3852 ?        Ss   Feb01   1:50 /usr/lib/systemd/systemd --switched-root --system --deserialize 22\n</code></pre>  </div></div>\n\n<p>通过命令也可以看到 <code class=\"language-plaintext highlighter-rouge\">PID</code> 为1的进程就是 <code class=\"language-plaintext highlighter-rouge\">systemd</code> 的系统进程。</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">systemd</code> 常用命令（它是一组命令的集合）：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>systemctl start nginx # 启动服务\nsystemctl stop nginx # 停止服务\nsystemctl restart nginx # 重启服务\nsystemctl status nginx # 查看服务状态\nsystemctl reload nginx # 重载配置文件(不停止服务的情况)\nsystemctl enable nginx # 开机自动启动服务\nsystemctl disable nginx # 开机不自动启动服务\nsystemctl is-enabled nginx # 查看服务是否开机自动启动\nsystemctl list-unit-files --type=service # 查看各个级别下服务的启动和禁用情况\n</code></pre>  </div></div>\n\n<h2 id=\"六-文件压缩解压\">六. 文件压缩解压</h2>\n\n<ul>\n <li>打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。</li>\n <li>压缩：是将一个大文件（通常指归档）压缩变成一个小文件。</li>\n</ul>\n\n<p>我们常常使用 <code class=\"language-plaintext highlighter-rouge\">tar</code> 将多个文件归档为一个总的文件，称为 <code class=\"language-plaintext highlighter-rouge\">archive</code> 。 然后用 <code class=\"language-plaintext highlighter-rouge\">gzip</code> 或 <code class=\"language-plaintext highlighter-rouge\">bzip2</code> 命令将 <code class=\"language-plaintext highlighter-rouge\">archive</code> 压缩为更小的文件。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517110548min.png\" alt=\"文件压缩解压命令\" /></p>\n\n<h3 id=\"1-tar\">1. tar</h3>\n\n<p>创建一个 <code class=\"language-plaintext highlighter-rouge\">tar</code> 归档。</p>\n\n<h4 id=\"基础用法\">基础用法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>tar -cvf sort.tar sort/ # 将sort文件夹归档为sort.tar\ntar -cvf archive.tar file1 file2 file3 # 将 file1 file2 file3 归档为archive.tar\n</code></pre>  </div></div>\n\n<h4 id=\"常用参数-6\">常用参数</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-cvf</code> 表示 <code class=\"language-plaintext highlighter-rouge\">create</code>（创建）+ <code class=\"language-plaintext highlighter-rouge\">verbose</code>（细节）+ <code class=\"language-plaintext highlighter-rouge\">file</code>（文件），创建归档文件并显示操作细节；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-tf</code> 显示归档里的内容，并不解开归档；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-rvf</code> 追加文件到归档， <code class=\"language-plaintext highlighter-rouge\">tar -rvf archive.tar file.txt</code> ；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-xvf</code> 解开归档， <code class=\"language-plaintext highlighter-rouge\">tar -xvf archive.tar</code> 。</li>\n</ul>\n\n<h3 id=\"2-gzip--gunzip\">2. gzip / gunzip</h3>\n\n<p>“压缩/解压”归档，默认用 <code class=\"language-plaintext highlighter-rouge\">gzip</code> 命令，压缩后的文件后缀名为 <code class=\"language-plaintext highlighter-rouge\">.tar.gz</code> 。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>gzip archive.tar # 压缩\ngunzip archive.tar.gz # 解压\n</code></pre>  </div></div>\n\n<h3 id=\"3-tar-归档压缩\">3. tar 归档+压缩</h3>\n\n<p>可以用 <code class=\"language-plaintext highlighter-rouge\">tar</code> 命令同时完成归档和压缩的操作，就是给 <code class=\"language-plaintext highlighter-rouge\">tar</code> 命令多加一个选项参数，使之完成归档操作后，还是调用 <code class=\"language-plaintext highlighter-rouge\">gzip</code> 或 <code class=\"language-plaintext highlighter-rouge\">bzip2</code> 命令来完成压缩操作。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>tar -zcvf archive.tar.gz archive/ # 将archive文件夹归档并压缩\ntar -zxvf archive.tar.gz # 将archive.tar.gz归档压缩文件解压\n</code></pre>  </div></div>\n\n<h3 id=\"4-zcatzlesszmore\">4. zcat、zless、zmore</h3>\n\n<p>之前讲过使用 <code class=\"language-plaintext highlighter-rouge\">cat less more</code> 可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用 <code class=\"language-plaintext highlighter-rouge\">zcat、zless、zmore</code> 进行查看。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>zcat archive.tar.gz\n</code></pre>  </div></div>\n\n<h3 id=\"5-zipunzip\">5. zip/unzip</h3>\n\n<p>“压缩/解压” <code class=\"language-plaintext highlighter-rouge\">zip</code> 文件（ <code class=\"language-plaintext highlighter-rouge\">zip</code> 压缩文件一般来自 <code class=\"language-plaintext highlighter-rouge\">windows</code> 操作系统）。</p>\n\n<h4 id=\"命令安装\">命令安装</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># Red Hat 一族中的安装方式\nyum install zip \nyum install unzip\n</code></pre>  </div></div>\n\n<h4 id=\"基础用法-1\">基础用法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>unzip archive.zip # 解压 .zip 文件\nunzip -l archive.zip # 不解开 .zip 文件，只看其中内容\nzip -r sort.zip sort/ # 将sort文件夹压缩为 sort.zip，其中-r表示递归\n</code></pre>  </div></div>\n\n<h2 id=\"七-编译安装软件\">七. 编译安装软件</h2>\n\n<p>之前我们学会了使用 <code class=\"language-plaintext highlighter-rouge\">yum</code> 命令进行软件安装，如果碰到 <code class=\"language-plaintext highlighter-rouge\">yum</code> 仓库中没有的软件，我们就需要会更高级的软件安装“源码编译安装”。</p>\n\n<h3 id=\"编译安装\">编译安装</h3>\n\n<p>简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。</p>\n\n<p>基本步骤如下：</p>\n\n<ol>\n <li>下载源代码</li>\n <li>解压压缩包</li>\n <li>配置</li>\n <li>编译</li>\n <li>安装</li>\n</ol>\n\n<h4 id=\"实际案例\">实际案例</h4>\n\n<h5 id=\"1下载\">1、下载</h5>\n\n<p>我们来编译安装 <code class=\"language-plaintext highlighter-rouge\">htop</code> 软件，首先在它的官网下载源码：</p>\n\n<blockquote>\n <p>https://bintray.com/htop/source/htop#files</p>\n</blockquote>\n\n<p>下载好的源码在本机电脑上使用如下命令同步到服务器上：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>scp 文件名 用户名@服务器ip:目标路径\nscp ~/Desktop/htop-3.0.0.tar.gz root@121.42.11.34:.\n</code></pre>  </div></div>\n\n<p>也可以使用 <code class=\"language-plaintext highlighter-rouge\">wegt</code> 进行下载：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>wegt+下载地址\nwegt https://bintray.com/htop/source/download_file?file_path=htop-3.0.0.tar.gz\n</code></pre>  </div></div>\n\n<h5 id=\"2解压文件\">2、解压文件</h5>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>tar -zxvf htop-3.0.0.tar.gz # 解压\ncd htop-3.0.0 # 进入目录\n</code></pre>  </div></div>\n\n<h5 id=\"3配置\">3、配置</h5>\n\n<p>执行 <code class=\"language-plaintext highlighter-rouge\">./configure</code> ，它会分析你的电脑去确认编译所需的工具是否都已经安装了。</p>\n\n<h5 id=\"4编译\">4、编译</h5>\n\n<p>执行 <code class=\"language-plaintext highlighter-rouge\">make</code> 命令</p>\n\n<h5 id=\"5安装\">5、安装</h5>\n\n<p>执行 <code class=\"language-plaintext highlighter-rouge\">make install</code> 命令，安装完成后执行 <code class=\"language-plaintext highlighter-rouge\">ls /usr/local/bin/</code> 查看是否有 <code class=\"language-plaintext highlighter-rouge\">htop</code> 命令。如果有就可以执行 <code class=\"language-plaintext highlighter-rouge\">htop</code> 命令查看系统进程了。</p>\n\n<h2 id=\"八-网络\">八. 网络</h2>\n\n<h3 id=\"1-ifconfig\">1. ifconfig</h3>\n\n<p>查看 <code class=\"language-plaintext highlighter-rouge\">ip</code> 网络相关信息，如果命令不存在的话， 执行命令 <code class=\"language-plaintext highlighter-rouge\">yum install net-tools</code> 安装。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[root@lion ~]# ifconfig\n \neth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500\n        inet 172.31.24.78  netmask 255.255.240.0  broadcast 172.31.31.255\n        ether 00:16:3e:04:9c:cd  txqueuelen 1000  (Ethernet)\n        RX packets 1592318  bytes 183722250 (175.2 MiB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1539361  bytes 154044090 (146.9 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n \nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre>  </div></div>\n\n<p>参数解析：</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">eth0</code> 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。 <code class=\"language-plaintext highlighter-rouge\">eth</code> 是 <code class=\"language-plaintext highlighter-rouge\">Ethernet</code> 的缩写，表示“以太网”。有些电脑可能同时有好几条网线连着，例如服务器，那么除了 <code class=\"language-plaintext highlighter-rouge\">eht0</code> ，你还会看到 <code class=\"language-plaintext highlighter-rouge\">eth1</code> 、 <code class=\"language-plaintext highlighter-rouge\">eth2</code> 等。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">lo</code> 表示本地回环（ <code class=\"language-plaintext highlighter-rouge\">Local Loopback</code> 的缩写，对应一个虚拟网卡）可以看到它的 <code class=\"language-plaintext highlighter-rouge\">ip</code> 地址是 <code class=\"language-plaintext highlighter-rouge\">127.0.0.1</code> 。每台电脑都应该有这个接口，因为它对应着“连向自己的链接”。这也是被称之为“本地回环”的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 <code class=\"language-plaintext highlighter-rouge\">127.0.0.1:3000</code> 启动项目就能查看到自己的 <code class=\"language-plaintext highlighter-rouge\">web</code> 网站，并且它只有你能看到。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">wlan0</code> 表示无线局域网（上面案例并未展示）。</li>\n</ul>\n\n<h3 id=\"2-host\">2. host</h3>\n\n<p><code class=\"language-plaintext highlighter-rouge\">ip</code> 地址和主机名的互相转换。</p>\n\n<h4 id=\"软件安装\">软件安装</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>yum install bind-utils\n</code></pre>  </div></div>\n\n<h4 id=\"基础用法-2\">基础用法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[root@lion ~]# host github.com\nbaidu.com has address 13.229.188.59\n \n[root@lion ~]# host 13.229.188.59\n59.188.229.13.in-addr.arpa domain name pointer ec2-13-229-188-59.ap-southeast-1.compute.amazonaws.com.\n</code></pre>  </div></div>\n\n<h3 id=\"3-ssh-连接远程服务器\">3. ssh 连接远程服务器</h3>\n\n<p>通过非对称加密以及对称加密的方式（同 <code class=\"language-plaintext highlighter-rouge\">HTTPS</code> 安全连接原理相似）连接到远端服务器。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ssh 用户@ip:port\n \n1、ssh root@172.20.10.1:22 # 端口号可以省略不写，默认是22端口\n2、输入连接密码后就可以操作远端服务器了\n</code></pre>  </div></div>\n\n<h4 id=\"配置-ssh\">配置 ssh</h4>\n\n<p><code class=\"language-plaintext highlighter-rouge\">config</code> 文件可以配置 <code class=\"language-plaintext highlighter-rouge\">ssh</code> ，方便批量管理多个 <code class=\"language-plaintext highlighter-rouge\">ssh</code> 连接。</p>\n\n<p>配置文件分为以下几种：</p>\n\n<ul>\n <li>全局 <code class=\"language-plaintext highlighter-rouge\">ssh</code> 服务端的配置： <code class=\"language-plaintext highlighter-rouge\">/etc/ssh/sshd_config</code> ；</li>\n <li>全局 <code class=\"language-plaintext highlighter-rouge\">ssh</code> 客户端的配置： <code class=\"language-plaintext highlighter-rouge\">/etc/ssh/ssh_config</code>（很少修改）；</li>\n <li>当前用户 <code class=\"language-plaintext highlighter-rouge\">ssh</code> 客户端的配置： <code class=\"language-plaintext highlighter-rouge\">~/.ssh/config</code> 。</li>\n</ul>\n\n<p>【服务端 <code class=\"language-plaintext highlighter-rouge\">config</code> 文件的常用配置参数】</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517110935min.png\" alt=\"服务端config文件的常用配置参数\" /></p>\n\n<blockquote>\n <p>[注意] 修改完服务端配置文件需要重启服务 <code class=\"language-plaintext highlighter-rouge\">systemctl restart sshd</code></p>\n</blockquote>\n\n<p>【客户端 <code class=\"language-plaintext highlighter-rouge\">config</code> 文件的常用配置参数】</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517111038min.png\" alt=\"客户端config文件的常用配置参数\" /></p>\n\n<p>配置当前用户的 <code class=\"language-plaintext highlighter-rouge\">config</code> ：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 创建config\nvim ~/.ssh/config\n \n# 填写一下内容\nHost lion # 别名\n HostName 172.x.x.x # ip 地址\n  Port 22 # 端口\n  User root # 用户\n</code></pre>  </div></div>\n\n<p>这样配置完成后，下次登录时，可以这样登录 <code class=\"language-plaintext highlighter-rouge\">ssh lion</code> 会自动识别为 <code class=\"language-plaintext highlighter-rouge\">root</code> 用户。</p>\n\n<blockquote>\n <p>[注意] 这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。</p>\n</blockquote>\n\n<h4 id=\"免密登录\">免密登录</h4>\n\n<p><code class=\"language-plaintext highlighter-rouge\">ssh</code> 登录分两种，一种是基于口令（账号密码），另外一种是基于密钥的方式。</p>\n\n<p>基于口令，就是每次登录输入账号和密码，显然这样做是比较麻烦的，今天主要学习如何基于密钥实现免密登录。</p>\n\n<h5 id=\"基于密钥验证原理\">基于密钥验证原理</h5>\n\n<p>客户机生成密钥对（公钥和私钥），把公钥上传到服务器，每次登录会与服务器的公钥进行比较，这种验证登录的方法更加安全，也被称为“公钥验证登录”。</p>\n\n<h5 id=\"具体实现步骤\">具体实现步骤</h5>\n\n<p>1、在客户机中生成密钥对（公钥和私钥） <code class=\"language-plaintext highlighter-rouge\">ssh-keygen</code>（默认使用 RSA 非对称加密算法）</p>\n\n<p>运行完 <code class=\"language-plaintext highlighter-rouge\">ssh-keygen</code> 会在 <code class=\"language-plaintext highlighter-rouge\">~/.ssh/</code> 目录下，生成两个文件：</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">id_rsa.pub</code> ：公钥</li>\n <li><code class=\"language-plaintext highlighter-rouge\">id_rsa</code> ：私钥</li>\n</ul>\n\n<p>2、把客户机的公钥传送到服务</p>\n\n<p>执行 <code class=\"language-plaintext highlighter-rouge\">ssh-copy-id root@172.x.x.x</code>（<code class=\"language-plaintext highlighter-rouge\">ssh-copy-id</code> 它会把客户机的公钥追加到服务器 <code class=\"language-plaintext highlighter-rouge\">~/.ssh/authorized_keys</code> 的文件中）。</p>\n\n<p>执行完成后，运行 <code class=\"language-plaintext highlighter-rouge\">ssh root@172.x.x.x</code> 就可以实现免密登录服务器了。</p>\n\n<p>配合上面设置好的别名，直接执行 <code class=\"language-plaintext highlighter-rouge\">ssh lion</code> 就可以登录，是不是非常方便。</p>\n\n<h3 id=\"3-wget\">3. wget</h3>\n\n<p>可以使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>wget [参数][URL地址]\nwget http://www.minjieren.com/wordpress-3.1-zh_CN.zip\n</code></pre>  </div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">wget</code> 非常稳定，如果是由于网络原因下载失败， <code class=\"language-plaintext highlighter-rouge\">wget</code> 会不断尝试，直到整个文件下载完毕。</p>\n\n<h4 id=\"常用参数-7\">常用参数</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-c</code> 继续中断的下载。</li>\n</ul>\n\n<h2 id=\"九-备份\">九. 备份</h2>\n\n<h3 id=\"1-scp\">1. scp</h3>\n\n<p>它是 <code class=\"language-plaintext highlighter-rouge\">Secure Copy</code> 的缩写，表示安全拷贝。 <code class=\"language-plaintext highlighter-rouge\">scp</code> 可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">scp</code> 是基于 <code class=\"language-plaintext highlighter-rouge\">ssh</code> 的原理来运作的， <code class=\"language-plaintext highlighter-rouge\">ssh</code> 会在两台通过网络连接的电脑之间创建一条安全通信的管道， <code class=\"language-plaintext highlighter-rouge\">scp</code> 就利用这条管道安全地拷贝文件。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>scp source_file destination_file # source_file 表示源文件，destination_file 表示目标文件\n</code></pre>  </div></div>\n\n<p>其中 <code class=\"language-plaintext highlighter-rouge\">source_file</code> 和 <code class=\"language-plaintext highlighter-rouge\">destination_file</code> 都可以这样表示： <code class=\"language-plaintext highlighter-rouge\">user@ip:file_name</code> ， <code class=\"language-plaintext highlighter-rouge\">user</code> 是登录名， <code class=\"language-plaintext highlighter-rouge\">ip</code> 是域名或 <code class=\"language-plaintext highlighter-rouge\">ip</code> 地址。 <code class=\"language-plaintext highlighter-rouge\">file_name</code> 是文件路径。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>scp file.txt root@192.168.1.5:/root # 表示把我的电脑中当前文件夹下的 file.txt 文件拷贝到远程电脑\nscp root@192.168.1.5:/root/file.txt file.txt # 表示把远程电脑上的 file.txt 文件拷贝到本机\n</code></pre>  </div></div>\n\n<h3 id=\"2-rsync\">2. rsync</h3>\n\n<p><code class=\"language-plaintext highlighter-rouge\">rsync</code> 命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于“增量备份”的命令了。它就是智能版的 <code class=\"language-plaintext highlighter-rouge\">scp</code> 命令。</p>\n\n<h4 id=\"软件安装-1\">软件安装</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>yum install rsync\n</code></pre>  </div></div>\n\n<h4 id=\"基础用法-3\">基础用法</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>rsync -arv Images/ backups/ # 将Images 目录下的所有文件备份到 backups 目录下\nrsync -arv Images/ root@192.x.x.x:backups/ # 同步到服务器的backups目录下\n</code></pre>  </div></div>\n\n<h4 id=\"常用参数-8\">常用参数</h4>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">-a</code> 保留文件的所有信息，包括权限，修改日期等；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-r</code> 递归调用，表示子目录的所有文件也都包括；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">-v</code> 冗余模式，输出详细操作信息。</li>\n</ul>\n\n<p>默认地， <code class=\"language-plaintext highlighter-rouge\">rsync</code> 在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用 <code class=\"language-plaintext highlighter-rouge\">rsync</code> 同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做： <code class=\"language-plaintext highlighter-rouge\">rsync -arv --delete Images/ backups/</code> 。</p>\n\n<h2 id=\"十-系统\">十. 系统</h2>\n\n<h3 id=\"1-halt\">1. halt</h3>\n\n<p>关闭系统，需要 <code class=\"language-plaintext highlighter-rouge\">root</code> 身份。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>halt\n</code></pre>  </div></div>\n\n<h3 id=\"2-reboot\">2. reboot</h3>\n\n<p>重启系统，需要 <code class=\"language-plaintext highlighter-rouge\">root</code> 身份。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>reboot\n</code></pre>  </div></div>\n\n<h3 id=\"3-poweroff\">3. poweroff</h3>\n\n<p>直接运行即可关机，不需要 <code class=\"language-plaintext highlighter-rouge\">root</code> 身份。</p>\n\n<h2 id=\"十一-vim-编辑器\">十一. Vim 编辑器</h2>\n\n<h3 id=\"1-vim-是什么\">1. Vim 是什么？</h3>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Vim</code> 是从 <code class=\"language-plaintext highlighter-rouge\">vi</code> 发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和 <code class=\"language-plaintext highlighter-rouge\">Emacs</code> 并列成为类 <code class=\"language-plaintext highlighter-rouge\">Unix</code> 系统用户最喜欢的编辑器。</p>\n\n<h3 id=\"2-vim-常用模式\">2. Vim 常用模式</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>交互模式\n插入模式\n命令模式\n可视模式\n</code></pre>  </div></div>\n\n<h4 id=\"交互模式\">交互模式</h4>\n\n<p>也成为正常模式，这是 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 的默认模式，每次运行 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 程序的时候，就会进入这个模式。</p>\n\n<p>例如执行 <code class=\"language-plaintext highlighter-rouge\">vim name.txt</code> 则会进入交互模式。</p>\n\n<p>交互模式特征：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>在这个模式下，你不能输入文本；\n它可以让我们在文本间移动，删除一行文本，复制黏贴文本，跳转到指定行，撤销操作，等等。\n</code></pre>  </div></div>\n\n<h4 id=\"插入模式\">插入模式</h4>\n\n<p>这个模式是我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容。进入这个模式有几种方法，最常用的方法是按字母键 <code class=\"language-plaintext highlighter-rouge\">i</code> （ <code class=\"language-plaintext highlighter-rouge\">i、I、a、A、o、O</code> 都可以进入插入模式，只是所处的位置不同），退出这种模式，只需要按下 <code class=\"language-plaintext highlighter-rouge\">Esc</code> 键。</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">i, I</code> 进入输入模式 <code class=\"language-plaintext highlighter-rouge\">Insert mode</code> ： <code class=\"language-plaintext highlighter-rouge\">i</code> 为“从目前光标所在处输入”， <code class=\"language-plaintext highlighter-rouge\">I</code> 为“在目前所在行的第一个非空格符处开始输入”；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">a, A</code> 进入输入模式 <code class=\"language-plaintext highlighter-rouge\">Insert mode</code> ： <code class=\"language-plaintext highlighter-rouge\">a</code> 为“从目前光标所在的下一个字符处开始输入”， <code class=\"language-plaintext highlighter-rouge\">A</code> 为“从光标所在行的最后一个字符处开始输入”；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">o, O</code> 进入输入模式 <code class=\"language-plaintext highlighter-rouge\">Insert mode</code> ： <code class=\"language-plaintext highlighter-rouge\">o</code> 为“在目前光标所在的下一行处输入新的一行”； <code class=\"language-plaintext highlighter-rouge\">O</code> 为在目前光标所在处的上一行输入新的一行。</li>\n</ul>\n\n<h4 id=\"命令模式\">命令模式</h4>\n\n<p>命令模式也称为底线命令模式，这个模式下可以运行一些命令例如“退出”，“保存”，等动作。</p>\n\n<p>也可以用这个模式来激活一些 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 配置，例如语法高亮，显示行号，等。甚至还可以发送一些命令给终端命令行，例如 <code class=\"language-plaintext highlighter-rouge\">ls、cp</code> 。</p>\n\n<p>为了进入命令模式，首先要进入交互模式，再按下冒号键。</p>\n\n<p>用一张图表示三种模式如何切换：</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517111440min.png\" alt=\"命令模式\" /></p>\n\n<h4 id=\"基本操作\">基本操作</h4>\n\n<h5 id=\"打开-vim\">打开 Vim</h5>\n\n<p>在终端命令行中输入 <code class=\"language-plaintext highlighter-rouge\">vim</code> 回车后 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 就会被运行起来，也可以用 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 来打开一个文件，只需要在 <code class=\"language-plaintext highlighter-rouge\">vim</code> 后面再加文件名。如 <code class=\"language-plaintext highlighter-rouge\">vim file.name</code> ，如果文件不存在，那么会被创建。</p>\n\n<h5 id=\"插入\">插入</h5>\n\n<p>进入文件之后，此时处于交互模式，可以通过输入 <code class=\"language-plaintext highlighter-rouge\">i</code> 进入插入模式。</p>\n\n<h5 id=\"移动\">移动</h5>\n\n<p>在 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 的交互模式下，我们可以在文本中移动光标。</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">h</code> 向左移动一个字符</li>\n <li><code class=\"language-plaintext highlighter-rouge\">j</code> 向下移动一个字符</li>\n <li><code class=\"language-plaintext highlighter-rouge\">k</code> 向上移动一个字符</li>\n <li><code class=\"language-plaintext highlighter-rouge\">i</code> 向右移动一个字符</li>\n</ul>\n\n<p>当然也可以使用四个方向键进行移动，效果是一样的。</p>\n\n<h5 id=\"跳至行首和行末\">跳至行首和行末</h5>\n\n<ul>\n <li><strong>「行首：」</strong> 在交互模式下，为了将光标定位到一行的开始位置，只需要按下数字键 <code class=\"language-plaintext highlighter-rouge\">0</code> 即可，键盘上的 <code class=\"language-plaintext highlighter-rouge\">Home</code> 键也有相同效果。</li>\n <li><strong>「行末：」</strong> 在交互模式下，为了将光标定位到一行的末尾，只需要按下美元符号键 <code class=\"language-plaintext highlighter-rouge\">$</code> 即可，键盘上的 <code class=\"language-plaintext highlighter-rouge\">End</code> 键也有相同效果。</li>\n</ul>\n\n<h4 id=\"按单词移动\">按单词移动</h4>\n\n<p>在交互模式下，按字母键 <code class=\"language-plaintext highlighter-rouge\">w</code> 可以一个单词一个单词的移动。</p>\n\n<h5 id=\"退出文件\">退出文件</h5>\n\n<p>在交互模式下，按下冒号键 <code class=\"language-plaintext highlighter-rouge\">:</code> 进入命令模式，再按下 <code class=\"language-plaintext highlighter-rouge\">q</code> 键，就可以退出了。</p>\n\n<p>如果在退出之前又修改了文件，就直接想用 <code class=\"language-plaintext highlighter-rouge\">:q</code> 退出 <code class=\"language-plaintext highlighter-rouge\">Vim</code> ，那么 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 会显示一个红字标明错误信息。此时我们有两个选择：</p>\n\n<ol>\n <li>保存并退出 <code class=\"language-plaintext highlighter-rouge\">:wq</code> 或 <code class=\"language-plaintext highlighter-rouge\">:x</code> ；</li>\n <li>不保存且退出 <code class=\"language-plaintext highlighter-rouge\">:q!</code> 。</li>\n</ol>\n\n<h4 id=\"标准操作\">标准操作</h4>\n\n<h5 id=\"删除字符\">删除字符</h5>\n\n<p>在交互模式下，将光标定位到一个你想要删除的字符上，按下字母键 <code class=\"language-plaintext highlighter-rouge\">x</code> 你会发现这个字符被删除了。</p>\n\n<p>也可以一次性删除多个字符，只需要在按 <code class=\"language-plaintext highlighter-rouge\">x</code> 键之前输入数字即可。</p>\n\n<h5 id=\"删除剪切单词行\">删除（剪切）单词，行</h5>\n\n<ul>\n <li><strong>「删除一行」</strong>：连按两次 <code class=\"language-plaintext highlighter-rouge\">d</code> 来删除光标所在的那一行。</li>\n <li><strong>「删除多行」</strong>：例如先输入数字 <code class=\"language-plaintext highlighter-rouge\">2</code> ，再按下 <code class=\"language-plaintext highlighter-rouge\">dd</code> ，就会删除从光标所在行开始的两行。</li>\n <li><strong>「删除一个单词」</strong>：将光标置于一个单词的首字母处，然后按下 <code class=\"language-plaintext highlighter-rouge\">dw</code> 。</li>\n <li><strong>「删除多个单词」</strong>：例如先按数字键 <code class=\"language-plaintext highlighter-rouge\">2</code> 再按 <code class=\"language-plaintext highlighter-rouge\">dw</code> 就可以删除两个单词了。</li>\n <li><strong>「从光标所在位置删除至行首」</strong>： <code class=\"language-plaintext highlighter-rouge\">d0</code> 。</li>\n <li><strong>「从光标所在位置删除至行末」</strong>： <code class=\"language-plaintext highlighter-rouge\">d$</code> 。</li>\n</ul>\n\n<h5 id=\"复制单词行\">复制单词，行</h5>\n\n<ul>\n <li><strong>「复制行」</strong>：按两次 <code class=\"language-plaintext highlighter-rouge\">y</code> 会把光标所在行复制到内存中，和 <code class=\"language-plaintext highlighter-rouge\">dd</code> 类似， <code class=\"language-plaintext highlighter-rouge\">dd</code> 用于“剪切”光标所在行。</li>\n <li><strong>「复制单词」</strong>： <code class=\"language-plaintext highlighter-rouge\">yw</code> 会复制一个单词。</li>\n <li><strong>「复制到行末」</strong>： <code class=\"language-plaintext highlighter-rouge\">y$</code> 是复制从光标所在处到行末的所有字符。</li>\n <li><strong>「复制到行首」</strong>： <code class=\"language-plaintext highlighter-rouge\">y0</code> 是复制光标所在处到行首的所有字符。</li>\n</ul>\n\n<h5 id=\"粘贴\">粘贴</h5>\n\n<p>如果之前用 <code class=\"language-plaintext highlighter-rouge\">dd</code> 或者 <code class=\"language-plaintext highlighter-rouge\">yy</code> 剪切复制过来的，可以使用 <code class=\"language-plaintext highlighter-rouge\">p</code> 来粘贴。同样也可以使用 <code class=\"language-plaintext highlighter-rouge\">数字+p</code> 来表示复制多次。</p>\n\n<h5 id=\"替换一个字符\">替换一个字符</h5>\n\n<p>在交互模式下，将光标置于想要替换的字符上。按下 <code class=\"language-plaintext highlighter-rouge\">r</code> 键，接着输入你要替换的字符即可。</p>\n\n<h5 id=\"撤销操作\">撤销操作</h5>\n\n<p>如果要撤销最近的修改，只需要按下 <code class=\"language-plaintext highlighter-rouge\">u</code> 键，如果想要撤销最近四次修改，可以按下4，再按下 <code class=\"language-plaintext highlighter-rouge\">u</code> 。</p>\n\n<h5 id=\"重做\">重做</h5>\n\n<p>取消撤销，也就是重做之前的修改使用 <code class=\"language-plaintext highlighter-rouge\">ctrl + r</code> 。</p>\n\n<h5 id=\"跳转到指定行\">跳转到指定行</h5>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Vim</code> 编辑的文件中，每一行都有一个行号，行号从1开始，逐一递增。</p>\n\n<p>行号默认是不显示，如果需要它显示的话，可以进入命令模式，然后输入 <code class=\"language-plaintext highlighter-rouge\">set nu</code> ，如果要隐藏行号的话，使用 <code class=\"language-plaintext highlighter-rouge\">set nonu</code> 。</p>\n\n<ul>\n <li>跳转到指定行： <code class=\"language-plaintext highlighter-rouge\">数字+gg</code> ，例如 <code class=\"language-plaintext highlighter-rouge\">7gg</code> ，表示跳转到第7行。</li>\n <li>要跳转到最后一行，按下 <code class=\"language-plaintext highlighter-rouge\">G</code> 。</li>\n <li>要跳转到第一行，按下 <code class=\"language-plaintext highlighter-rouge\">gg</code> 。</li>\n</ul>\n\n<h4 id=\"高级操作\">高级操作</h4>\n\n<h5 id=\"查找\">查找</h5>\n\n<p>处于交互模式下，按下 <code class=\"language-plaintext highlighter-rouge\">/</code> 键，那么就进入查找模式，输入你要查找的字符串，然后按下回车。光标就会跳转到文件中下一个查找到的匹配处。如果字符串不存在，那么会显示 <code class=\"language-plaintext highlighter-rouge\">\"pattern not found\"</code> 。</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">n</code> 跳转到下一个匹配项；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">N</code> 跳转到上一个匹配项。</li>\n</ul>\n\n<blockquote>\n <p>?</p>\n\n <p>[注意] 用斜杠来进行的查找是从当前光标处开始向文件尾搜索，如果你要从当前光标处开始，向文件头搜索则使用 <code class=\"language-plaintext highlighter-rouge\">?</code> ，当然也可以先按下 <code class=\"language-plaintext highlighter-rouge\">gg</code> 跳转到第一行在进行全文搜索。</p>\n\n <p>?</p>\n</blockquote>\n\n<h5 id=\"查找并替换\">查找并替换</h5>\n\n<p>替换光标所在行第一个匹配的字符串：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 语法\n:s/旧字符串/新字符串\n# 实例\n:s/one/two\n</code></pre>  </div></div>\n\n<p>替换光标所在行所有旧字符串为新字符串：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 语法\n:s/旧字符串/新字符串/g\n</code></pre>  </div></div>\n\n<p>替换第几行到第几行中所有字符串：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 语法\n:n,m s/旧字符串/新字符串/g\n# 实例\n:2,4 s/one/two/g\n</code></pre>  </div></div>\n\n<p>最常用的就是全文替换了：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 语法\n:%s/旧字符串/新字符串/g\n</code></pre>  </div></div>\n\n<h5 id=\"合并文件\">合并文件</h5>\n\n<p>可以用冒号 <code class=\"language-plaintext highlighter-rouge\">+r</code> ( <code class=\"language-plaintext highlighter-rouge\">:r</code> ) 实现在光标处插入一个文件的内容。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>:r filename # 可以用Tab键来自动补全另外一个文件的路径\n</code></pre>  </div></div>\n\n<h5 id=\"分屏\">分屏</h5>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Vim</code> 有一个特别便捷的功能那就是分屏，可以同时打开好几个文件，分屏之后，屏幕每一块被称为一个 <code class=\"language-plaintext highlighter-rouge\">viewport</code> ，表示“视口”。</p>\n\n<ul>\n <li>横向分屏 <code class=\"language-plaintext highlighter-rouge\">:sp 文件名</code></li>\n <li>垂直分屏 <code class=\"language-plaintext highlighter-rouge\">:vsp 文件名</code></li>\n</ul>\n\n<h6 id=\"分屏模式下的快捷键\">分屏模式下的快捷键</h6>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">Ctrl + w</code> 再加 <code class=\"language-plaintext highlighter-rouge\">Ctrl + w</code> ，表示从一个 <code class=\"language-plaintext highlighter-rouge\">viewport</code> 移动光标到另外一个 <code class=\"language-plaintext highlighter-rouge\">viewport</code> ；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Ctrl + w</code> 再加 “方向键”，就可以移动到这个方向所处的下一个视口了；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Ctrl + w</code> 再加 <code class=\"language-plaintext highlighter-rouge\">+</code> 号，表示扩大当前视口；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Ctrl + w</code> 再加 <code class=\"language-plaintext highlighter-rouge\">-</code> 号，表示缩小当前视口；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Ctrl + w</code> 再加 <code class=\"language-plaintext highlighter-rouge\">=</code> 号，表示平均当前视口；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Ctrl + w</code> 再加 <code class=\"language-plaintext highlighter-rouge\">r</code> 键，会反向调换视口位置；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Ctrl + w</code> 再加 <code class=\"language-plaintext highlighter-rouge\">q</code> 键，会关闭当前视口；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Ctrl + w</code> 再加 <code class=\"language-plaintext highlighter-rouge\">o</code> 键，会关闭除当前视口以外的所有视口；</li>\n</ul>\n\n<h5 id=\"运行外部命令-\">运行外部命令 <code class=\"language-plaintext highlighter-rouge\">:!</code></h5>\n\n<p>在 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 中可以运行一些终端命令，只要先输入 <code class=\"language-plaintext highlighter-rouge\">:!</code> ，然后接命令名称。</p>\n\n<p>例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>:!ls # 在Vim中打开的文件所在的目录运行ls命令\n</code></pre>  </div></div>\n\n<h4 id=\"可视模式\">可视模式</h4>\n\n<p>前面只讲了 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 的三种模式，其实还有一种模式叫做可视模式。</p>\n\n<p>进入它的三种方式（都是从交互模式开始）：</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">v</code> 字符可视模式，进入后配合方向键选中字符后，然后再按 <code class=\"language-plaintext highlighter-rouge\">d</code> 键可以删除选中。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">V</code> 行可视模式，进入后光标所在行默认被选中，然后再按 <code class=\"language-plaintext highlighter-rouge\">d</code> 键可以删除所在行。</li>\n <li><code class=\"language-plaintext highlighter-rouge\">Ctrl + v</code> 块可视模式，它是可视模式最有用的功能了，配合 <code class=\"language-plaintext highlighter-rouge\">d</code> 和 <code class=\"language-plaintext highlighter-rouge\">I</code> 键可以实现删除选中的内容和插入内容。</li>\n</ul>\n\n<p>同时选中多行，并在选中行头部插入内容的具体操作步骤：</p>\n\n<ol>\n <li><code class=\"language-plaintext highlighter-rouge\">ctrl + v</code> 进入块可视模式</li>\n <li>使用方向键进行选中（上下左右）假设选中5行</li>\n <li>输入 <code class=\"language-plaintext highlighter-rouge\">I</code> 键进行多行同时插入操作</li>\n <li>插入完成后连续按两下 <code class=\"language-plaintext highlighter-rouge\">esc</code> 键，实现多行同时插入相同字符</li>\n</ol>\n\n<p>进入可视模式之后的操作键：</p>\n\n<ul>\n <li><code class=\"language-plaintext highlighter-rouge\">d</code> 键，表示删除选中；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">I</code> 键，表示在选中之前插入；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">u</code> 键，表示选中变为小写；</li>\n <li><code class=\"language-plaintext highlighter-rouge\">U</code> 键，表示选中变为大写；</li>\n</ul>\n\n<h3 id=\"3-vim-配置\">3. Vim 配置</h3>\n\n<h4 id=\"选项参数\">选项参数</h4>\n\n<p>在 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 被启动后，可以运行一些指令来激活一些选项参数，但是这些选项参数的配置在退出 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 时会被忘记，例如前面讲解的激活行号。如果希望所在的配置是永久性的，那么需要在家目录（ <code class=\"language-plaintext highlighter-rouge\">cd ~</code> ）创建一个 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 的配置文件 <code class=\"language-plaintext highlighter-rouge\">.vimrc</code> 。</p>\n\n<h4 id=\"vimrc\">.vimrc</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>set number \" 显示行号\nsyntax on \" 激活语法高亮\nset showcmd \" 实时看到输入的命令\nset ignorecase \" 搜索时不区分大小写\nset mouse=a \" 激活鼠标，用鼠标选中时相当于进入可视模式\n</code></pre>  </div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">Vim</code> 配置非常丰富，我们可以通过个性化配置把 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 打造成属于自己的 <code class=\"language-plaintext highlighter-rouge\">IDE</code> 等等。在 <code class=\"language-plaintext highlighter-rouge\">github</code> 上也可以搜索到一些强大的 <code class=\"language-plaintext highlighter-rouge\">Vim</code> 配置文件。</p>\n\n<h3 id=\"总结\">总结</h3>\n\n<p>相信通过本文的学习，你应该会对 <code class=\"language-plaintext highlighter-rouge\">Linux</code> 有一个更加全面的认识。</p>\n\n<p>最后，实现Linux 命令自由。</p>\n","dir":"/blog/development/os/linux/","name":"2023-05-17_3.md","path":"blog/development/os/linux/2023-05-17_3.md","url":"/blog/development/os/linux/2023-05-17_3.html"},{"sort":2,"layout":"default","title":"Java中Json转换的常见操作方式","content":"<h1 id=\"java中json转换的常见操作方式\">Java中Json转换的常见操作方式</h1>\n\n<h2 id=\"一-利用阿里巴巴封装的fastjson来转换json字符串\">一. 利用阿里巴巴封装的FastJSON来转换json字符串</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>package com.zkn.newlearn.json;\n \nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport java.util.Map;\n \n/**\n * JSON字符串自动转换\n * Created by zkn on 2016/8/22.\n */\npublic class JsonToMapTest01 {\n \n    public static void main(String[] args){\n \n        String str = \"{\\\"0\\\":\\\"zhangsan\\\",\\\"1\\\":\\\"lisi\\\",\\\"2\\\":\\\"wangwu\\\",\\\"3\\\":\\\"maliu\\\"}\";\n        //第一种方式\n        Map maps = (Map)JSON.parse(str);\n        System.out.println(\"这个是用JSON类来解析JSON字符串!!!\");\n        for (Object map : maps.entrySet()){\n            System.out.println(((Map.Entry)map).getKey()+\"     \" + ((Map.Entry)map).getValue());\n        }\n        //第二种方式\n        Map mapTypes = JSON.parseObject(str);\n        System.out.println(\"这个是用JSON类的parseObject来解析JSON字符串!!!\");\n        for (Object obj : mapTypes.keySet()){\n            System.out.println(\"key为：\"+obj+\"值为：\"+mapTypes.get(obj));\n        }\n        //第三种方式\n        Map mapType = JSON.parseObject(str,Map.class);\n        System.out.println(\"这个是用JSON类,指定解析类型，来解析JSON字符串!!!\");\n        for (Object obj : mapType.keySet()){\n            System.out.println(\"key为：\"+obj+\"值为：\"+mapType.get(obj));\n        }\n        //第四种方式\n        /**\n         * JSONObject是Map接口的一个实现类\n         */\n        Map json = (Map) JSONObject.parse(str);\n        System.out.println(\"这个是用JSONObject类的parse方法来解析JSON字符串!!!\");\n        for (Object map : json.entrySet()){\n            System.out.println(((Map.Entry)map).getKey()+\"  \"+((Map.Entry)map).getValue());\n        }\n        //第五种方式\n        /**\n         * JSONObject是Map接口的一个实现类\n         */\n        JSONObject jsonObject = JSONObject.parseObject(str);\n        System.out.println(\"这个是用JSONObject的parseObject方法来解析JSON字符串!!!\");\n        for (Object map : json.entrySet()){\n            System.out.println(((Map.Entry)map).getKey()+\"  \"+((Map.Entry)map).getValue());\n        }\n        //第六种方式\n        /**\n         * JSONObject是Map接口的一个实现类\n         */\n        Map mapObj = JSONObject.parseObject(str,Map.class);\n        System.out.println(\"这个是用JSONObject的parseObject方法并执行返回类型来解析JSON字符串!!!\");\n        for (Object map: json.entrySet()){\n            System.out.println(((Map.Entry)map).getKey()+\"  \"+((Map.Entry)map).getValue());\n        }\n        System.out.println(json);\n    }\n}\n</code></pre>  </div></div>\n","dir":"/blog/development/java/basics/","name":"2023-04-24_2.md","path":"blog/development/java/basics/2023-04-24_2.md","url":"/blog/development/java/basics/2023-04-24_2.html"},{"sort":2,"layout":"default","title":"Windows常用小技巧","content":"<h1 id=\"windows常用小技巧\">Windows常用小技巧</h1>\n\n<h2 id=\"一-生成文件目录结构\">一. 生成文件目录结构</h2>\n<p>windows下生成文件目录结构树状图</p>\n\n<p>看别人写博客的时候，发下如下结构：</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517092857min.png\" alt=\"windows下生成文件目录结构树状图\" /></p>\n\n<p>这就是文件夹的目录结构，可以帮助理解。所以很有必要自己学一下。</p>\n\n<ol>\n <li>按住shift键，右击你要生成目录的文件夹data，选择“在此处打开命令窗口”。（或者win+R，输入cmd打开命令窗口后通过cd命令进入你要生成目录的文件夹路径下）</li>\n</ol>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517093215min.png\" alt=\"windows下生成文件目录结构树状图\" /></p>\n\n<p>2、在命令窗口里输入命令“tree”，按回车。就会显示出文件的目录结构。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517093410min.png\" alt=\"windows下生成文件目录结构树状图\" />\n如果想显示所有文件夹及文件夹下的所有文件的目录，可以用命令“tree /f”；\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517093608min.png\" alt=\"windows下生成文件目录结构树状图\" /></p>\n\n<p>3.发现现实的格式有重叠，截图也不好看。通过输入tree&gt;url.txt , 可以把目录结构保存下来. \n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517093838min.png\" alt=\"windows下生成文件目录结构树状图\" /></p>\n\n<p>当前路径下就生成了url.txt文件，打开后就可以把url.txt中的内容复制到需要的文件中，然后调整格式了。</p>\n","dir":"/blog/development/os/windows/","name":"2023-05-17_1.md","path":"blog/development/os/windows/2023-05-17_1.md","url":"/blog/development/os/windows/2023-05-17_1.html"},{"sort":2,"layout":"default","title":"推荐几款好用的自用软件","content":"<h1 id=\"推荐几款好用的自用软件\">推荐几款好用的自用软件</h1>\n\n<p>安利几款好用的自用软件,每一个都找了,好久,有需要的可以下载,各位有好的软件也可以在留言中分享,文章会不定期更新!</p>\n\n<h2 id=\"推荐几款好用的orc截屏识字软件\">推荐几款好用的ORC截屏识字软件</h2>\n<p>其中包含好几软ORC软件,网站找了好久,很多都是有毒的,终于找到后分享给大家,特别安利天若ORC软件,体积小,无毒.纯绿色软件.需要的可以使用百度云下载</p>\n\n<p><a href=\"https://pan.baidu.com/s/1_v-Lgc6Txp630avQlZCvNA\">百度分享地址</a>提取码：prwv</p>\n","dir":"/blog/frontier/recommend/","name":"2023-04-27_1.md","path":"blog/frontier/recommend/2023-04-27_1.md","url":"/blog/frontier/recommend/2023-04-27_1.html"},{"sort":3,"layout":"default","title":"Java中计算List求和或List对象中某个字段的总和","content":"<h1 id=\"java中计算list求和或list对象中某个字段的总和\">Java中计算List求和或List对象中某个字段的总和</h1>\n\n<h2 id=\"一-使用循环遍历list对象累加求和\">一. 使用循环遍历List对象，累加求和</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nint sum = 0;\nfor (int number : numbers) {\n    sum += number;\n}\nSystem.out.println(\"List总和：\" + sum);\n\n</code></pre>  </div></div>\n<p>如果要计算List中某个字段的总和，假设有一个包含Person对象的List，每个Person对象有一个age字段：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Person&gt; persons = Arrays.asList(\n    new Person(\"John\", 25),\n    new Person(\"Jane\", 30),\n    new Person(\"Mike\", 35)\n);\nint sum = 0;\nfor (Person person : persons) {\n    sum += person.getAge();\n}\nSystem.out.println(\"年龄总和：\" + sum);\n\n</code></pre>  </div></div>\n\n<h2 id=\"二-java-8的stream-apilist-stream计算对象list中某个字段的总和\">二. Java 8的Stream API，list stream:计算对象List中某个字段的总和</h2>\n\n<h3 id=\"1-计算一个number类型的list对象总和\">1. 计算一个number类型的List对象总和</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nint sum = numbers.stream().mapToInt(Integer::intValue).sum();\nSystem.out.println(\"List总和：\" + sum);\n</code></pre>  </div></div>\n<p>或者</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Integer[] integerArray = {1, 3, 5, 10, 18};\n\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(integerArray));\n\nIntSummaryStatistics summaryStatistics = list.stream().mapToInt((s) -&gt; s).summaryStatistics();\nSystem.out.println(\"总和：\" + summaryStatistics.getSum());\nSystem.out.println(\"平均数：\" + summaryStatistics.getAverage());\nSystem.out.println(\"总个数：\" + summaryStatistics.getCount());\nSystem.out.println(\"最大值：\" + summaryStatistics.getMax());\nSystem.out.println(\"最小值：\" + summaryStatistics.getMin());\n</code></pre>  </div></div>\n\n<h3 id=\"2-计算一个list对象中某个字段总和\">2. 计算一个List对象中某个字段总和</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Person&gt; persons = Arrays.asList(\n    new Person(\"John\", 25),\n    new Person(\"Jane\", 30),\n    new Person(\"Mike\", 35)\n);\nint sum = persons.stream().mapToInt(Person::getAge).sum();\nSystem.out.println(\"年龄总和：\" + sum);\n</code></pre>  </div></div>\n<p>或者</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;User&gt; userList = new ArrayList&lt;&gt;();\nUser user1 = new User();\nuser1.setAge(10);\nuserList.add(user1);\nUser user2 = new User();\nuser2.setAge(20);\nuserList.add(user2);\nUser user3 = new User();\nuser3.setAge(25);\nuserList.add(user3);\n\nint ageSum = userList.stream().collect(Collectors.summingInt(User::getAge));\nSystem.out.println(\"年龄总和 ：\" + ageSum);\n</code></pre>  </div></div>\n\n<h3 id=\"3-java-stream-计算总和-stream聚合函数对bigdecimal求和\">3. Java Stream 计算总和 Stream聚合函数对BigDecimal求和</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> BigDecimal sum = selectList.stream().map(SxLoss::getLossAmount).reduce(BigDecimal.ZERO, BigDecimal::add);\n</code></pre>  </div></div>\n<p>注意：有可能会报错，因为对象中某个值为空，因此需要增加判断</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> BigDecimal sum = selectList.stream().map(SxLoss::getLossAmount).filter(lossAmount -&gt; lossAmount != null).reduce(BigDecimal.ZERO, BigDecimal::add);\n</code></pre>  </div></div>\n\n<p><strong>注：</strong>以上几种方法都可以计算List的总和或List对象中某个字段的总和。选择使用哪种方法取决于具体的需求和使用的Java版本。</p>\n","dir":"/blog/development/java/basics/","name":"2023-04-24_3.md","path":"blog/development/java/basics/2023-04-24_3.md","url":"/blog/development/java/basics/2023-04-24_3.html"},{"sort":3,"layout":"default","title":"Visual Studio Code常用功能及功能优化设置","content":"<h1 id=\"visual-studio-code常用功能及功能优化设置\">Visual Studio Code常用功能及功能优化设置</h1>\n\n<p>官方定义Visual Studio Code是一个轻量级但功能强大的源代码编辑器。笔者觉得是众多扩展性极高的插件支撑VS Code的功能，免费的总是最好的，VS Code 无心中成为一个全尺寸的集成开发环境IDE。</p>\n\n<h2 id=\"vscode常用快捷键\">VSCode常用快捷键</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. 打开命令面板\t\tF1 或者“Cmd+Shift+P ”(Windows 上是 “Ctrl+Shift+P”) \n2. 打开VS Code\t    命令行中使用 code 或者 code-insiders（Windows）                                \n3. 移动光标\t\t\tCtrl+方向键\n4. 行头行尾\t\t\tHome/End键\n5. 代码块移动\t\t \tCtrl + Shift + \\\n6. 文本选择\t\t\tOption + 左方向键+ Shift 键\n7. 删除代码行\t\t\tCtrl + Shift + K\n8. 新开一行代码\t\tCtrl + Enter（当前行下方）\n\t\t\t\t\tCtrl + Shift + Enter（当前行上方）\n9. 移动代码\t\t\tAlt + 上下方向键\n\t向上复制一行\t\tShift + Alt + Up\n\t在下方复制一行\t\tShift + Alt + Down\n10. 回退光标\t\t\tCtrl + U\n11. 合并代码行\t \tCtrl + j（Windows没有）\n12. 调换字符位置\t\tCtrl + t（Windows没有）\n13. 代码缩进\t\t\tCmd + Shift + P\n14. 代码格式化\t\tAlt + Shift + F\n15. 代码注释\t\t\tCtrl + /或者Option + Shift + A\n16. 建议列表\t\t\tCtrl + 空格键\n17. 参数预览\t \t\tCtrl + Shift + Space\n18. 快速修复\t\t\tCtrl + .\n19. 重构\t\t\t\t光标放在上方按F12\n20. 代码跳转和链接\t\tCtrl + 鼠标左键\n21. 全面代码界面\t\tCtrl+ B进入\n22. 自定义快捷键\t\t打开命令面板，打开键盘快捷方式，然后Cmd + Shift + ]+回车绑定快捷键\n</code></pre>  </div></div>\n<h2 id=\"好用的插件及其相关设置\">好用的插件及其相关设置</h2>\n\n<h3 id=\"通用\">通用</h3>\n\n<h4 id=\"简体中文\">简体中文</h4>\n<p>Chinese (Simplified) (简体中文) Language Pack for Visual Studio Code</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230517161424min.png\" alt=\"VSCode设置简体中文\" /></p>\n\n<p>汉化你的vscode！让界面、设置等都变成中文！无需配置，即装即用，记得装完后重启vscode。</p>\n\n","dir":"/blog/development/tool/software/","name":"2023-05-17_3.md","path":"blog/development/tool/software/2023-05-17_3.md","url":"/blog/development/tool/software/2023-05-17_3.html"},{"sort":3,"permalink":"/blog/development/interview/java/","layout":"default","title":"Java面试题","content":"<h1 id=\"java面试题\">Java面试题</h1>\n\n<ul>\n <li><a href=\"/blog/development/interview/java/2023-04-23_1.html\">Java面试宝典一(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_2.html\">Java面试宝典二(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_3.html\">Java面试宝典三(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_4.html\">Java面试宝典四(2023最新Java面试题)</a></li>\n</ul>\n","dir":"/blog/development/interview/java/","name":"README.md","path":"blog/development/interview/java/README.md","url":"/blog/development/interview/java/"},{"sort":3,"layout":"default","title":"html表格导出excel有几种方式","content":"<h1 id=\"html表格导出excel有几种方式\">html表格导出excel有几种方式</h1>\n\n<h2 id=\"一-前后端结合\">一. 前后端结合</h2>\n<p>利用 JavaScript 将表格内容转换为 Excel 文件格式，然后通过 Ajax 请求将文件数据发送给后台，再由后台返回该文件数据流，前端再通过浏览器下载功能将其下载。这种方式可以使用第三方 JavaScript 库如 SheetJS、xlsx-populate、Export-Excel 等来简化操作。</p>\n\n<h2 id=\"二-后台解析返回前端下载\">二. 后台解析，返回前端下载</h2>\n<p>使用服务端技术如 Java、Python、PHP 等，读取前端提交的表格数据，将其转换为 Excel 文件并返回给前端进行下载。</p>\n\n<h2 id=\"三-前端插件解析\">三. 前端插件解析</h2>\n<p>使用前端插件如 jQuery Export Table Plugin、Bootstrap Table Export、TableExport 等，直接将表格导出为 Excel 文件并在浏览器中下载。这种方式通常需要在页面中引入插件相关的 JavaScript 库。</p>\n\n<h3 id=\"1-使用js-xlsx插件导出excel\">1. 使用js-xlsx插件导出excel</h3>\n<p>官方github：https://github.com/SheetJS/js-xlsx</p>\n\n<h4 id=\"11-将html页面中一个table导出excel\">1.1 将html页面中一个table导出excel</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>function exportToExcel(tableId, fileName) {\n  var wb = XLSX.utils.table_to_book(document.getElementById(tableId));\n  var wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'binary' });\n\n  function s2ab(s) {\n    var buf = new ArrayBuffer(s.length);\n    var view = new Uint8Array(buf);\n    for (var i = 0; i &lt; s.length; i++) {\n      view[i] = s.charCodeAt(i) &amp; 0xff;\n    }\n    return buf;\n  }\n\n  saveAs(new Blob([s2ab(wbout)], { type: 'application/octet-stream' }), fileName);\n}\n</code></pre>  </div></div>\n\n<p>saveAs() 函数是由 FileSaver.js 库提供的，它可以将一个 Blob 或者 File 对象保存到本地文件系统。在示例中，我们将该函数挂载到了 window 对象上，可以在任何地方调用。如果需要使用该函数，需要先引入 FileSaver.js 库，可以通过以下方式获取：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js\"&gt;&lt;/script&gt;\n</code></pre>  </div></div>\n\n<p>使用示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!-- html表格 --&gt;\n&lt;table id=\"myTable\"&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Name&lt;/th&gt;\n      &lt;th&gt;Age&lt;/th&gt;\n      &lt;th&gt;Country&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;td&gt;John&lt;/td&gt;\n      &lt;td&gt;25&lt;/td&gt;\n      &lt;td&gt;USA&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Jane&lt;/td&gt;\n      &lt;td&gt;30&lt;/td&gt;\n      &lt;td&gt;Canada&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Bob&lt;/td&gt;\n      &lt;td&gt;35&lt;/td&gt;\n      &lt;td&gt;Australia&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n\n&lt;!-- 导出按钮 --&gt;\n&lt;button onclick=\"exportToExcel('myTable', 'myFile.xlsx')\"&gt;Export to Excel&lt;/button&gt;\n</code></pre>  </div></div>\n\n<p>在上面的示例中，exportToExcel函数接受两个参数：表格的ID和导出的文件名。该函数使用js-xlsx插件将表格转换为Excel文件，并使用FileSaver.js库将生成的文件下载到本地计算机。</p>\n\n<h4 id=\"12-将html页面中两个table导出到一个excel\">1.2 将html页面中两个table导出到一个excel</h4>\n<p>将js代码修改为</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>FleetCost.export = function () {\n    var wb1 = XLSX.utils.table_to_book(document.getElementById(\"table1\"));\n    var wb2 = XLSX.utils.table_to_book(document.getElementById(\"table2\"));\n    var workbook = XLSX.utils.book_new();\n    XLSX.utils.book_append_sheet(workbook, wb1.Sheets[wb1.SheetNames[0]], \"Table1\");\n    XLSX.utils.book_append_sheet(workbook, wb2.Sheets[wb2.SheetNames[0]], \"Table2\");\n    var wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'binary' });\n\n    function s2ab(s) {\n        var buf = new ArrayBuffer(s.length);\n        var view = new Uint8Array(buf);\n        for (var i = 0; i &lt; s.length; i++) {\n            view[i] = s.charCodeAt(i) &amp; 0xff;\n        }\n        return buf;\n    }\n    saveAs(new Blob([s2ab(wbout)], { type: 'application/octet-stream' }), \"myFile.xlsx\");\n}\n\n</code></pre>  </div></div>\n<p>其中，table1和table2是两个html中的table元素。这里先分别将它们转化为workbook，再使用XLSX.utils.book_new()创建一个新的workbook，然后使用XLSX.utils.book_append_sheet()将两个表格分别添加到workbook中，最后使用XLSX.write()将workbook转换为二进制数据，保存为excel文件即可。</p>\n","dir":"/blog/development/html/jottings/","name":"2023-05-12_1.md","path":"blog/development/html/jottings/2023-05-12_1.md","url":"/blog/development/html/jottings/2023-05-12_1.html"},{"sort":3,"layout":"default","title":"Linux的上传和下载功能","content":"<h1 id=\"linux的上传和下载功能\">Linux的上传和下载功能</h1>\n\n<h2 id=\"linux-rz上传与sz下载\">linux rz上传与sz下载</h2>\n\n<p>对于经常使用Linux系统的人员来说，少不了将本地的文件上传到服务器或者从服务器上下载文件到本地，rz / sz命令很方便的帮我们实现了这个功能</p>\n\n<h3 id=\"1-sz命令发送文件到本地\">1. sz命令发送文件到本地</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. 在终端中进入要上传文件的目录。\n2. 运行 rz 命令。\n3. 选择要上传的文件，并在终端仿真软件的文件传输对话框中点击发送（或等效操作）。\n4. 文件将被传输到当前目录中。\n</code></pre>  </div></div>\n\n<p>代码如下:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#下载一个文件  \nsz filename  \n#下载多个文件  \nsz filename1 filename2  \n#下载dir目录下的所有文件，不包含dir下的文件夹  \nsz dir/*\n</code></pre>  </div></div>\n<h3 id=\"2-rz命令本地上传文件到服务器\">2. rz命令本地上传文件到服务器</h3>\n\n<p> 在命令终端输入rz回车后，就会出现文件选择对话框，选择需要上传文件，一次可以指定多个文件，上传到服务器的路径为当前执行rz命令的目录。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. 在终端中进入要保存下载文件的目录。\n2. 运行 sz 命令，指定要下载的文件路径作为参数。例如：sz filename。\n3. 在终端仿真软件的文件传输对话框中选择保存文件的位置，并点击接收（或等效操作）。\n4. 文件将被下载到指定的目录中。\n</code></pre>  </div></div>\n\n<p><strong>注意：</strong>单独用rz会有两个问题：</p>\n\n<p>上传中断、上传文件变化（md5不同），解决办法是上传是用rz -be，并且去掉弹出的对话框中“Upload files as ASCII”前的勾选。<br />\n-b binary 用binary的方式上传下载，不解释字符为ascii<br />\n-e 强制escape 所有控制字符，比如Ctrl+x，DEL等。</p>\n\n<h3 id=\"3-目录说明\">3. 目录说明：</h3>\n\n<p>   打开SecureCRT软件 -&gt; Options -&gt; session options -&gt; X/Y/Zmodem 下可以设置上传和下载的目录</p>\n\n<p><strong>注意：</strong>为了能够使用 rz 和 sz 命令进行文件传输，需要在 Linux 系统中安装支持 Zmodem 协议的终端仿真软件，并且终端仿真软件与你的终端连接的另一端（例如远程服务器）支持相应的文件传输功能。</p>\n\n<p>此外，还可以使用其他工具和方法进行文件传输，例如 scp 命令、sftp 命令、FTP 客户端等，这些方法可能更常用和更灵活，特别是在与远程服务器进行文件传输时。</p>\n\n","dir":"/blog/development/os/linux/","name":"2023-04-23_1.md","path":"blog/development/os/linux/2023-04-23_1.md","url":"/blog/development/os/linux/2023-04-23_1.html"},{"sort":3,"permalink":"/blog/life/","layout":"default","title":"人生","content":"<h1 id=\"人生\">人生</h1>\n\n<ul>\n <li><a href=\"/blog/life/travel/\">趣事小记</a></li>\n</ul>\n","dir":"/blog/life/","name":"README.md","path":"blog/life/README.md","url":"/blog/life/"},{"sort":3,"layout":"default","title":"免费的Jekyll静态网站发布平台","content":"<h1 id=\"免费的jekyll静态网站发布平台\">免费的Jekyll静态网站发布平台</h1>\n<p>Jekyll是一款基于Ruby的静态网站生成器，可以将纯文本文件转化为静态网页，不需要数据库和服务器端脚本。以下是一些免费的Jekyll静态网站发布平台</p>\n\n<h2 id=\"github-pages\">GitHub Pages</h2>\n<p><a href=\"https://pages.github.com/\">GitHub Pages</a>是一个由GitHub提供的免费托管静态网站的服务，支持使用Jekyll作为网站生成器，可以在自己的GitHub仓库中发布Jekyll网站。</p>\n\n<h2 id=\"vercel\">Vercel</h2>\n<p><a href=\"https://vercel.com/\">Vercel</a> 是一个云端 Serverless 部署平台，它允许开发者在没有服务器的情况下部署和扩展应用程序。它支持多种编程语言和框架，包括 Next.js、Nuxt.js、React、Angular、Vue 等，提供高性能和可扩展性，可以轻松扩展应用程序。</p>\n\n<p>Vercel 提供了一个简单易用的用户界面和 CLI 工具，使得开发者可以轻松地在几分钟内部署他们的应用程序。它还提供了强大的自动化工具，如持续集成、自动部署和自动缩放，使得开发者可以专注于编写代码而不用担心基础设施的维护和管理。</p>\n\n<p>Vercel 的优点包括快速、易用、高性能、自动化和弹性扩展，它是构建现代 Web 应用程序的一种优秀选择。</p>\n\n<h2 id=\"netlify\">Netlify</h2>\n<p><a href=\"https://app.netlify.com/\">Netlify</a>是一款功能强大的静态网站发布平台，支持Jekyll和其他静态网站生成器，可以将网站发布到自定义域名或Netlify提供的子域名上。</p>\n\n<h2 id=\"gitlab-pages\">GitLab Pages</h2>\n<p><a href=\"https://gitlab.com/\">GitLab Pages</a>是一个由GitLab提供的类似GitHub Pages的静态网站托管服务，支持使用Jekyll作为网站生成器。</p>\n\n<h2 id=\"surge\">Surge</h2>\n<p><a href=\"https://surge.sh/\">Surge</a>是一款快速、简单的静态网站托管服务，支持使用Jekyll作为网站生成器，并提供快速的网站部署和更新功能。</p>\n\n<p>这些平台都提供了免费的静态网站托管服务，并且都支持使用Jekyll作为网站生成器。用户可以根据自己的需求和喜好选择合适的平台。</p>\n","dir":"/blog/development/html/webdesign/","name":"2023-05-12_1.md","path":"blog/development/html/webdesign/2023-05-12_1.md","url":"/blog/development/html/webdesign/2023-05-12_1.html"},{"sort":3,"layout":"default","title":"Java中BigDecimal类型详解","content":"<h1 id=\"java中bigdecimal类型详解\">Java中BigDecimal类型详解</h1>\n\n<p>在使用BigDecimal类型时,非常容易用错,Java中的简单浮点数类型float和double直接运算，精度不准，推荐使用 BigDecimal 计算。</p>\n\n<p>BigDecimal 是 Java 中用于高精度计算的类，它提供了精确的数值运算，避免了浮点数计算时的精度丢失问题。</p>\n\n<h2 id=\"一-bigdecimal构造\">一. BigDecimal构造</h2>\n<h3 id=\"构造方法\">构造方法</h3>\n<p>BigDecimal 可以通过多种方式进行实例化，包括使用整数、浮点数、字符串或字符数组等作为参数。例如：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>BigDecimal value = new BigDecimal(10); 使用整数实例化 BigDecimal。\nBigDecimal value = new BigDecimal(\"3.14159\"); 使用字符串实例化 BigDecimal。\n</code></pre>  </div></div>\n<p><strong>不可变性：</strong>BigDecimal 对象是不可变的，一旦创建就不能修改其值。每次运算操作都会返回一个新的 BigDecimal 对象，保证了线程安全性。</p>\n\n<h2 id=\"二-bigdecimal类型的加减乘除bigdecimal高精度计算\">二. BigDecimal类型的加减乘除(BigDecimal高精度计算)</h2>\n<p>高精度计算：BigDecimal 可以处理任意位数的整数和小数，因此可以进行高精度的数值计算，避免了浮点数运算的精度损失问题。</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>BigDecimal bignum1 = new BigDecimal(10.0);  \nBigDecimal bignum2 = new BigDecimal(10.0);\n</code></pre>  </div></div>\n<h3 id=\"加法\">加法</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>add =  bignum1.add(bignum2);\n</code></pre>  </div></div>\n<h3 id=\"减法\">减法</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>subtract = bignum1.subtract(bignum2);\n</code></pre>  </div></div>\n<h3 id=\"乘法\">乘法</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>multiply = bignum1.multiply(bignum2);\n</code></pre>  </div></div>\n<h3 id=\"除法\">除法</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>divide = bignum1.divide(bignum2);\n\n.divide(new BigDecimal(18),2, BigDecimal.ROUND_HALF_UP) // &gt;=5 四舍五入\n</code></pre>  </div></div>\n<p><em>注意</em>:除法的时候一定要在divide方法中传递第二个参数，定义精确到小数点后几位，否则在不整除的情况下，结果是无限循环小数时，就会抛出异常：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result。\n</code></pre>  </div></div>\n<p>一个简单的测试类：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    @Test\n    public void redisTestjisuan(){\n        BigDecimal benjin = new BigDecimal(100000.00);\n        int qishu = 3;\n        BigDecimal lilv = new BigDecimal(0.015);\n        // 每月还款额=[贷款本金×月利率×（1+月利率）^还款月数]÷[（1+月利率）^还款月数－1]\n        BigDecimal big = (lilv.add(new BigDecimal(1.0)).pow(qishu)).subtract(new BigDecimal(1));\n        BigDecimal divide = (benjin.multiply(lilv).multiply(lilv.add(new BigDecimal(1.0)).pow(qishu))).divide(big,2,RoundingMode.HALF_UP);\n        logger.info(\"每月还款额=\"+divide);\n \n    }\n</code></pre>  </div></div>\n<h3 id=\"精度和舍入\">精度和舍入</h3>\n<p>BigDecimal 可以指定精度和舍入模式来进行运算。精度表示小数部分的位数，舍入模式定义了舍入时的规则。常见的舍入模式包括 ROUND_UP（向上舍入）、ROUND_DOWN（向下舍入）和 ROUND_HALF_UP（四舍五入）等。</p>\n\n<h3 id=\"比较操作\">比较操作</h3>\n<p>BigDecimal 提供了比较操作来判断两个 BigDecimal 对象的大小关系。可以使用 compareTo 方法来进行比较，返回值为负数、零或正数，分别表示小于、等于或大于。</p>\n\n<h3 id=\"格式化和转换\">格式化和转换</h3>\n<p>BigDecimal 支持格式化输出和字符串转换，可以根据需要将 BigDecimal 对象转换为字符串或其他数值类型。</p>\n\n","dir":"/blog/development/java/basics/","name":"2023-04-27_1.md","path":"blog/development/java/basics/2023-04-27_1.md","url":"/blog/development/java/basics/2023-04-27_1.html"},{"sort":3,"layout":"default","title":"Java开发环境安装配置JDK+Maven+Tomcat","content":"<h1 id=\"java开发环境安装配置jdkmaventomcat\">Java开发环境安装配置JDK+Maven+Tomcat</h1>\n\n<p>配置环境:Windows10专业版\n注:建议为专业版,其他版本权限有可能有缺失.</p>\n\n<h2 id=\"一安装jdk18\">一.安装JDK1.8</h2>\n<h3 id=\"1-安装jdk\">1. 安装JDK</h3>\n<p>进行java开发，首先要安装jdk，安装了jdk后还要进行环境变量配置：</p>\n<h4 id=\"11-下载jdkhttpswwworaclecomtechnetworkjavajavasedownloadsindexhtml\">1.1 下载jdk（https://www.oracle.com/technetwork/java/javase/downloads/index.html).</h4>\n<p>此处提供:jdk-8u181-windows-x64<br />\n链接：https://pan.baidu.com/s/1c9vh7TRak5uhDstMO7TtxQ \n提取码：pm4c</p>\n\n<p>在下载页面中你需要选择接受许可，并根据自己的系统选择对应的版本,EXE和zip都可以,两种不同的安装方式而已.</p>\n\n<h4 id=\"12-安装\">1.2 安装</h4>\n<p>安装过程中会出现两次 安装提示 :\n第一次是安装 jdk ，第二次是安装 jre 。\n建议两个都安装在同一个java文件夹中的不同文件夹中。（不能都安装在java文件夹的根目录下，jdk和jre安装在同一文件夹会出错）</p>\n\n<h3 id=\"2-进行环境变量配置\">2. 进行环境变量配置</h3>\n<p>计算机→属性→高级系统设置→高级→环境变量</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>JAVA_HOME:\t此处根据自己安装的路径写\nPath:\t%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;（注意变量值之间用“;”隔开）\nCLASSPATH :\t.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar\n</code></pre>  </div></div>\n\n<p>注:前面有英文句号.不能缺少</p>\n<h3 id=\"3-检验\">3. 检验</h3>\n<p>1.是否配置成功 运行cmd 输入 java -version （java 和 -version 之间有空格）\n若如图所示 显示版本信息 则说明安装和配置成功。</p>\n\n<p>2.补充环境变量的解析:\nJAVA_HOME:jdk的安装路径\nclasspath:java加载类路径，只有类在classpath中java命令才能识别，在路径前加了个”.”表示当前路径。\npath：系统在任何路径下都可以识别java,javac命令</p>\n\n<p>3.注:若显示报错,解决方案:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.详细检查安装路径及书写路径\n2.将路径中的%JAVA_HOME%都改为JAVA_HOME路径:C:\\Java\\jdk1.7.0(此处根据自己地址)\n若还未解决,请百度解决.\n</code></pre>  </div></div>\n\n<h2 id=\"二安装maven\">二.安装maven</h2>\n<p>链接：https://pan.baidu.com/s/1GRHFyAnXrF09cJ7frsCvww \n提取码：gasy</p>\n\n<h3 id=\"1-安装\">1. 安装</h3>\n<p>选择安装目录,解压,\n进入conf文件夹,配置项目maven库地址,阿里或公司的私服.\nsettings.xml</p>\n\n<h3 id=\"2-配置环境变量\">2. 配置环境变量</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>MAVEN_HOME      安装目录\nPath    %MAVEN_HOME%\\bin\\;\n</code></pre>  </div></div>\n\n<h3 id=\"3-检测\">3. 检测</h3>\n<p>cmd输入mvn -v或mvn验证是否配置成功\n自动生成两个文件夹:C:\\Users\\Administrator.m2\\repository –&gt; 本地仓库目录</p>\n\n<p>注意：如果觉得在中央仓库下载jar的时候很慢，可以试试阿里云提供的maven仓库\n在settings.xml文件里的mirrors节点添加如下子节点：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;mirror&gt;  \n    &lt;id&gt;nexus-aliyun&lt;/id&gt;  \n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    \n    &lt;name&gt;Nexus aliyun&lt;/name&gt;  \n    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;  \n&lt;/mirror&gt; \n</code></pre>  </div></div>\n\n<p>此处提供已经配置好的配置文件,需要的可以直接下载:\n链接：https://pan.baidu.com/s/1QNjWeP1vJVptpG40Wwq-SA \n提取码：yz5d</p>\n\n<h2 id=\"三安装tomcat\">三.安装Tomcat</h2>\n<p>此处提供下载apache-tomcat-7.0.92:\n链接：https://pan.baidu.com/s/1zUyWTIRfYqVbczKyZtMVOw \n提取码：jgrs</p>\n\n<p>下载tomcat后解压到自己想要安装的位置，同Java环境变量的配置，新建以下四个变量（已存在则进行编辑）：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>TOMCAT_HOME：C:\\Program Files\\tomcat　　　　//tomcat安装路径，到bin上一层。\n\nCATALINA_HOME：C:\\Program Files\\tomcat　　　　//同上\n\nPath：%CATALINA_HOME%\\bin\n\nCLASSPATH：%CATALINA_HOME%\\lib\\servlet-api.jar\n</code></pre>  </div></div>\n\n<p>　　配置好以后，在cmd下cd到C:\\Program Files\\tomcat\\bin(你的安装目录)，运行“service install Tomcat7”命令即可。\n　　在浏览器地址栏输入“http://localhost”出现以下画面即使安装成功了：</p>\n\n<p>tomcat的默认端口是8080，若是想修改端口，在“conf”文件夹下找到“server.xml”，将文件中的“Connector port=’8088’”的8080修改为自己要的端口号，保存后重启tomcat即可。</p>\n","dir":"/blog/development/java/jottings/","name":"2023-04-27_2.md","path":"blog/development/java/jottings/2023-04-27_2.md","url":"/blog/development/java/jottings/2023-04-27_2.html"},{"sort":3,"layout":"default","title":"Java面试宝典三(2023最新Java面试题)","content":"<h1 id=\"java面试宝典三2023最新java面试题\">Java面试宝典三(2023最新Java面试题)</h1>\n\n<h2 id=\"一-springspring-mvc\"><strong>一. Spring/Spring MVC</strong></h2>\n\n<h3 id=\"1-为什么要使用-spring\"><strong>1. 为什么要使用 spring？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。\nspring 提供了事务支持，使得事务操作变的更加方便。\nspring 提供了面向切片编程，这样可以更方便的处理某一类的问题。\n更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。\n</code></pre>  </div></div>\n\n<h3 id=\"2-解释一下什么是-aop\"><strong>2. 解释一下什么是 aop？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。\n</code></pre>  </div></div>\n\n<p>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p>\n\n<h3 id=\"3-解释一下什么是-ioc\"><strong>3. 解释一下什么是 ioc？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。\n</code></pre>  </div></div>\n\n<p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p>\n\n<h3 id=\"4-spring-有哪些主要模块\"><strong>4. spring 有哪些主要模块？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。\nspring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。\nspring dao：Data Access Object 提供了JDBC的抽象层。\nspring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。\nspring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。\nspring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。\n</code></pre>  </div></div>\n\n<h3 id=\"5-spring-常用的注入方式有哪些\"><strong>5. spring 常用的注入方式有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>setter 属性注入\n构造方法注入\n注解方式注入\n</code></pre>  </div></div>\n\n<h3 id=\"6-spring-中的-bean-是线程安全的吗\"><strong>6. spring 中的 bean 是线程安全的吗？</strong></h3>\n\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>\n\n<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>有状态就是有数据存储功能。\n无状态就是不会保存数据。\n</code></pre>  </div></div>\n\n<h3 id=\"7-spring-支持几种-bean-的作用域\"><strong>7. spring 支持几种 bean 的作用域？</strong></h3>\n\n<p>spring 支持 5 种作用域，如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；\nprototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；\n</code></pre>  </div></div>\n\n<p>Web 环境下的作用域：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>request：每次 http 请求都会创建一个 bean；\nsession：同一个 http session 共享一个 bean 实例；\nglobal-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。\n</code></pre>  </div></div>\n\n<p><strong>「注意：」</strong> 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>\n\n<h3 id=\"8-spring-自动装配-bean-有哪些方式\"><strong>8. spring 自动装配 bean 有哪些方式？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。\nbyName：它根据 bean 的名称注入对象依赖项。\nbyType：它根据类型注入对象依赖项。\n构造函数：通过构造函数来注入依赖项，需要设置大量的参数。\nautodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。\n</code></pre>  </div></div>\n\n<h3 id=\"9-spring-事务实现方式有哪些\"><strong>9. spring 事务实现方式有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。\n编码方式：提供编码的形式管理和维护事务。\n</code></pre>  </div></div>\n\n<h3 id=\"10-说一下-spring-的事务隔离\"><strong>10. 说一下 spring 的事务隔离？</strong></h3>\n\n<p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；\nISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；\nISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；\nISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；\nISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n「脏读」 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。\n「不可重复读」 ：是指在一个事务内，多次读同一数据。\n「幻读」 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。\n</code></pre>  </div></div>\n\n<h3 id=\"11-说一下-spring-mvc-运行流程\"><strong>11. 说一下 spring mvc 运行流程？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring mvc 先将请求发送给 DispatcherServlet。\nDispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。\nDispatcherServlet 再把请求提交到对应的 Controller。\nController 进行业务逻辑处理后，会返回一个ModelAndView。\nDispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。\n视图对象负责渲染返回给客户端。\n</code></pre>  </div></div>\n\n<h3 id=\"12-spring-mvc-有哪些组件\"><strong>12. spring mvc 有哪些组件？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>前置控制器 DispatcherServlet。\n映射控制器 HandlerMapping。\n处理器 Controller。\n模型和视图 ModelAndView。\n视图解析器 ViewResolver。\n</code></pre>  </div></div>\n\n<h3 id=\"13-requestmapping-的作用是什么\"><strong>13. @RequestMapping 的作用是什么？</strong></h3>\n\n<p>将 http 请求映射到相应的类/方法上。</p>\n\n<h3 id=\"14-autowired-的作用是什么\"><strong>14. @Autowired 的作用是什么？</strong></h3>\n\n<p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p>\n\n<h2 id=\"二-spring-bootspring-cloud\"><strong>二. Spring Boot/Spring Cloud</strong></h2>\n\n<h3 id=\"1-什么是-spring-boot\"><strong>1. 什么是 spring boot？</strong></h3>\n\n<p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p>\n\n<h3 id=\"2-为什么要用-spring-boot\"><strong>2. 为什么要用 spring boot？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>配置简单\n独立运行\n自动装配\n无代码生成和 xml 配置\n提供应用监控\n易上手\n提升开发效率\n</code></pre>  </div></div>\n\n<h3 id=\"3-spring-boot-核心配置文件是什么\"><strong>3. spring boot 核心配置文件是什么？</strong></h3>\n\n<p>spring boot 核心的两个配置文件：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；\napplication (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。\n</code></pre>  </div></div>\n\n<h3 id=\"4-spring-boot-配置文件有哪几种类型它们有什么区别\"><strong>4. spring boot 配置文件有哪几种类型？它们有什么区别？</strong></h3>\n\n<p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</p>\n\n<p>. properties 配置如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring.RabbitMQ.port=5672\n</code></pre>  </div></div>\n\n<p>. yml 配置如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring:    \n\tRabbitMQ:        \n\t\tport: 5672\n</code></pre>  </div></div>\n\n<p>yml 格式不支持 @PropertySource 注解导入。</p>\n\n<h3 id=\"5-spring-boot-有哪些方式可以实现热部署\"><strong>5. spring boot 有哪些方式可以实现热部署？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；\n使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。\n</code></pre>  </div></div>\n\n<h3 id=\"6-什么是-spring-cloud\"><strong>6. 什么是 spring cloud？</strong></h3>\n\n<p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p>\n\n<h3 id=\"7-spring-cloud-断路器的作用是什么\"><strong>7. spring cloud 断路器的作用是什么？</strong></h3>\n\n<p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>\n\n<h3 id=\"8-spring-cloud-的核心组件有哪些\"><strong>8. spring cloud 的核心组件有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Eureka：服务注册于发现。\nFeign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。\nRibbon：实现负载均衡，从一个服务的多台机器中选择一台。\nHystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。\nZuul：网关管理，由 Zuul 网关转发请求给对应的服务。\n</code></pre>  </div></div>\n\n<h2 id=\"三-hibernate\"><strong>三. Hibernate</strong></h2>\n\n<h3 id=\"1-为什么要使用-hibernate\"><strong>1. 为什么要使用 hibernate？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。\nhibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。\n可以很方便的进行数据库的移植工作。\n提供了缓存机制，是程序执行更改的高效。\n</code></pre>  </div></div>\n\n<h3 id=\"2-什么是-orm-框架\"><strong>2. 什么是 ORM 框架？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。\n</code></pre>  </div></div>\n\n<p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p>\n\n<h3 id=\"3-hibernate-中如何在控制台查看打印的-sql-语句\"><strong>3. hibernate 中如何在控制台查看打印的 SQL 语句？</strong></h3>\n\n<p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p>\n\n<h3 id=\"4-hibernate-有几种查询方式\"><strong>4. hibernate 有几种查询方式？</strong></h3>\n\n<p>三种：hql、原生 SQL、条件查询 Criteria。</p>\n\n<h3 id=\"5-hibernate-实体类可以被定义为-final-吗\"><strong>5. hibernate 实体类可以被定义为 final 吗？</strong></h3>\n\n<p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p>\n\n<h3 id=\"6-在-hibernate-中使用-integer-和-int-做映射有什么区别\"><strong>6. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？</strong></h3>\n\n<p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p>\n\n<h3 id=\"7-hibernate-是如何工作的\"><strong>7. hibernate 是如何工作的？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>读取并解析配置文件。\n读取并解析映射文件，创建 SessionFactory。\n打开 Session。\n创建事务。\n进行持久化操作。\n提交事务。\n关闭 Session。\n关闭 SessionFactory。\n</code></pre>  </div></div>\n\n<h3 id=\"8-get和-load的区别\"><strong>8. get()和 load()的区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。\nload()支持延迟加载；get() 不支持延迟加载。\n</code></pre>  </div></div>\n\n<h3 id=\"9-说一下-hibernate-的缓存机制\"><strong>9. 说一下 hibernate 的缓存机制？</strong></h3>\n\n<p>hibernate 常用的缓存有一级缓存和二级缓存：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；\n\n二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。\n</code></pre>  </div></div>\n\n<h3 id=\"10-hibernate-对象有哪些状态\"><strong>10. hibernate 对象有哪些状态？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。\n持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。\n游离状态：Session 关闭之后对象就是游离状态。\n</code></pre>  </div></div>\n\n<h3 id=\"11-在-hibernate-中-getcurrentsession-和-opensession-的区别是什么\"><strong>11. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>getCurrentSession 会绑定当前线程，而 openSession 则不会。\ngetCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。\n</code></pre>  </div></div>\n\n<h3 id=\"12-hibernate-实体类必须要有无参构造函数吗为什么\"><strong>12. hibernate 实体类必须要有无参构造函数吗？为什么？</strong></h3>\n\n<p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p>\n\n<h3 id=\"13-jpa-和-hibernate-有什么区别\"><strong>13. jpa 和 hibernate 有什么区别？</strong></h3>\n\n<p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p>\n\n<h2 id=\"四-mybatis\"><strong>四. MyBatis</strong></h2>\n\n<h3 id=\"1-mybatis-中-和-的区别是什么\"><strong>1. MyBatis 中 #{}和 ${}的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>`#{}`是预编译处理\n`${}`是字符替换。 在使用 `#{}`时，MyBatis 会将 SQL 中的 `#{}`替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。\n</code></pre>  </div></div>\n\n<h3 id=\"2-mybatis-有几种分页方式\"><strong>2. MyBatis 有几种分页方式？</strong></h3>\n\n<p>分页方式：逻辑分页和物理分页。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>「逻辑分页：」** 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。\n\n「物理分页：」** 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。\n</code></pre>  </div></div>\n\n<h3 id=\"3-rowbounds-是一次性查询全部结果吗为什么\"><strong>3. RowBounds 是一次性查询全部结果吗？为什么？</strong></h3>\n\n<p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>\n\n<h3 id=\"4-mybatis-逻辑分页和物理分页的区别是什么\"><strong>4. MyBatis 逻辑分页和物理分页的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。\n\n物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。\n</code></pre>  </div></div>\n\n<h3 id=\"5-mybatis-是否支持延迟加载延迟加载的原理是什么\"><strong>5. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。\n</code></pre>  </div></div>\n\n<p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。</p>\n\n<p>比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p>\n\n<h3 id=\"6-说一下-mybatis-的一级缓存和二级缓存\"><strong>6. 说一下 MyBatis 的一级缓存和二级缓存？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。\n二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。\n</code></pre>  </div></div>\n\n<p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>\n\n<p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>\n\n<h3 id=\"7-mybatis-和-hibernate-的区别有哪些\"><strong>7. MyBatis 和 hibernate 的区别有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。\n可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。\n学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。\n二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。\n</code></pre>  </div></div>\n\n<h3 id=\"8-mybatis-有哪些执行器executor\"><strong>8. MyBatis 有哪些执行器（Executor）？</strong></h3>\n\n<p>MyBatis 有三种基本的Executor执行器：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；\nReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；\nBatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。\n</code></pre>  </div></div>\n\n<h3 id=\"9-mybatis-分页插件的实现原理是什么\"><strong>9. MyBatis 分页插件的实现原理是什么？</strong></h3>\n\n<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>\n\n<h3 id=\"10-mybatis-如何编写一个自定义插件\"><strong>10. MyBatis 如何编写一个自定义插件？</strong></h3>\n\n<p><strong>「自定义插件实现原理」</strong></p>\n\n<p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；\nStatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；\n\nParameterHandler：拦截参数的处理；\nResultSetHandler：拦截结果集的处理。\n</code></pre>  </div></div>\n\n<p><strong>「自定义插件实现关键」</strong></p>\n\n<p>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public interfaceInterceptor{      \n\tObject intercept(Invocation invocation) throws Throwable;\n\t\n\tObject plugin(Object target);\n\t\n\tvoidsetProperties(Properties properties);\n}\n\nsetProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；\nplugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；\nintercept 方法就是要进行拦截的时候要执行的方法。\n</code></pre>  </div></div>\n\n<p><strong>「自定义插件实现示例」</strong></p>\n\n<p>官方插件实现：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Intercepts({@Signature(type = Executor.class, method= \"query\", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})})\npublic class TestInterceptor implements Interceptor{   \n\tpublic Object intercept(Invocation invocation) throws Throwable {     \n\t\tObject target = invocation.getTarget(); //被代理对象     \n\t\tMethod method = invocation.getMethod(); //代理方法     \n\t\tObject[] args = invocation.getArgs(); //方法参数     \n\t\t// do something . . . . . .  方法拦截前执行代码块     \n\t\tObject result = invocation. proceed();     \n\t\t// do something . . . . . . . 方法拦截后执行代码块     \n\t\treturn result;   \n\t}  \n\tpublic Object plugin(Object target){     \n\t\treturn Plugin. wrap(target, this);   \n\t}\n}\n</code></pre>  </div></div>\n","dir":"/blog/development/interview/java/","name":"2023-04-23_3.md","path":"blog/development/interview/java/2023-04-23_3.md","url":"/blog/development/interview/java/2023-04-23_3.html"},{"sort":3,"layout":"default","title":"Spring 访问数据库","content":"<h1 id=\"spring-访问数据库\">Spring 访问数据库</h1>\n","dir":"/blog/development/java/framework/spring/","name":"2023-05-18_3.md","path":"blog/development/java/framework/spring/2023-05-18_3.md","url":"/blog/development/java/framework/spring/2023-05-18_3.html"},{"sort":3,"layout":"default","title":"SEO实操小技巧关键字","content":"<h1 id=\"seo实操小技巧关键字\">SEO实操小技巧关键字</h1>\n\n<h2 id=\"一-seo关键字优化十大技巧\">一. SEO关键字优化十大技巧</h2>\n<p>关键字在搜索引擎优化（SEO）中扮演重要角色，以下是关于关键字的一些SEO技巧：</p>\n\n<p><strong>1. 关键字研究：</strong>进行关键字研究，找到与你网站内容相关且受众搜索频率较高的关键字。使用关键字研究工具（如Google关键字规划工具、SEMrush、Moz等）来确定适合你网站的关键字。</p>\n\n<p><strong>2. 关键字密度：</strong>在网页内容中合理使用关键字。关键字密度是指关键字在内容中的出现频率，但不应过度堆砌关键字。确保关键字的使用自然流畅，对读者有意义。</p>\n\n<p><strong>3. 标题和描述：</strong>将关键字包含在页面标题（title）和元描述（meta description）标签中。这有助于搜索引擎了解页面内容，并向用户展示相关的搜索结果。</p>\n\n<p><strong>4. URL 结构：</strong>优化页面的URL结构，将关键字包含在URL中。简洁、清晰的URL有助于搜索引擎理解页面内容，并提供更好的用户体验。</p>\n\n<p><strong>5. 内部链接：</strong>在网站内部创建有关键字的内部链接，这可以增加页面之间的相关性和导航性，也有助于搜索引擎索引和理解你的网站。</p>\n\n<p><strong>6. 图像标签：</strong>为网站中的图像添加描述性的Alt标签，其中包括关键字。这有助于搜索引擎理解图像内容，并为图像搜索结果提供机会。</p>\n\n<p><strong>7. 高质量内容：</strong>编写高质量、有价值的内容，并围绕关键字进行优化。优质内容吸引用户，并增加网站在搜索引擎中的可信度和排名。</p>\n\n<p><strong>8. 用户体验：</strong>提供优秀的用户体验，包括页面加载速度、移动友好性和易用性。这些因素对于搜索引擎排名和用户满意度都很重要。</p>\n\n<p><strong>9. 外部链接：</strong>获取高质量的外部链接，来自其他网站指向你的网站。这些外部链接可以增加你网站的可信度和权威性，对搜索引擎排名有积极影响。</p>\n\n<p><strong>10. 持续优化：</strong>定期监测和分析关键字的效果，根据数据调整和优化你的SEO策略。SEO是一个持续的过程，随着搜索引擎算法的变化，你需要不断调整和改进。</p>\n\n<h2 id=\"二-seo关键词研究seo关键词优化方式\">二. SEO关键词研究（SEO关键词优化方式）</h2>\n\n<p>关键词研究是任何一个SEO项目的第一步。\n如果你不知道用户在你的领域中到底搜索什么关键词的话，那么你的SEO决策一定是基于运气，而非数据驱动。这样是没有办法去运营你的业务的.</p>\n\n<h3 id=\"1-确保你优化的是正确的目标关键词\">1. 确保你优化的是正确的目标关键词</h3>\n\n<p>大多数人在设立目标关键词的时候，经常犯以下三个错误的一个。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>没有优化任何关键词；\n尝试优化过多的关键词；\n优化不相关的关键词。\n</code></pre>  </div></div>\n\n<p>你可以通过这一点来解决前两个问题：\n每一个页面或文章，只需要设定一个特定的主关键词或者是关键词主题。</p>\n\n<h5 id=\"小提示\">小提示:</h5>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>尝试避免在多个网页上定位相同的关键字也很重要。这是因为谷歌通常只会选择对其中一个页面进行排名，而这个页面，可能不是你希望他们排名的页面！\n\n选择正确关键字，一个好办法是：将你的页面发送给朋友并询问：“这个页面的内容是什么？”\n\n他们的答案通常会为你提供最佳的关键词或主题创意。但是，在确定之前，你一定要通过谷歌去搜索这个关键词。\n\n为什么？因为搜索结果可以帮助你了解谷歌是如何看某个特定关键词的。谷歌展现的是该特定关键字的最佳结果。如果大多数结果与你尝试排名的内容大不相同，那么它可能不是一个好的目标关键词。\n\n在谷歌中，关键词 “Outreach（外联）” 排名前3位的网页。这些结果与我们的内容大不相同，意味着这不是最佳目标关键词。\n具有大量SERP功能的关键词也是一样的（例如精选片段，Adwords广告，购物结果等）。\n\n因为这些功能效果会把10个自然的有机排名结果向下推，大大的降低了自然排名的点击率，降低了可以获取到的流量。那么，这个关键词很可能也不是最佳的目标关键词。\n</code></pre>  </div></div>\n\n<h3 id=\"2-通过关键词意图分析避免出现有独角兽特征的关键词\">2. 通过关键词意图分析，避免出现有“独角兽特征”的关键词</h3>\n\n<p>有时在进行研究时，你可能会发现一个搜索量特别多的关键词。但仅仅因为一个关键词具有较高的搜索量，并不代表它将是最佳的目标关键词。</p>\n\n<p>你必须考虑关键词背后的“搜索意图”（用户搜这个词是想找到什么）。</p>\n\n<p><strong>例子</strong>：“Google Analytics（谷歌分析）” 似乎是一个很好的关键字，乍一看，似乎可以尝试去排名。</p>\n\n<p>在美国，这个词每个月有100万的搜索量！但是,这些搜索中，绝大多数的人只是希望登录谷歌分析工具。他们可能甚至都不会注意到排名第二的页面。</p>\n\n<p>这就是所谓的关键词“独角兽”特征，看起来挺不错，但你几乎不能排到第一，就算你做到了，用户也不会点击你。</p>\n\n<p>现在，如果我们向下找找，我们可能会找到 “How to use Google Analytics （如何使用Google分析）” 这个词。</p>\n\n<p>这个词，每月有1,900次的搜索。这个多半是用户希望寻找谷歌分析工具的使用指南，这意味着它可能是一个非常不错的关键词，值得去追逐。</p>\n\n<p><strong>但请记住，并非所有的关键词设定都是看搜索量的（除非你做广告联盟）。</strong></p>\n\n<p>你最终是希望，让能够为业务带来价值的关键字参与排名（即那些能带来流量，并转化为潜在客户的关键词）。因此，你必须去定位那些搜索意图相关的关键词。</p>\n\n<p>以下是一些问题，有助于你去识别那些有 “独角兽特征”的关键词：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>搜索此关键词的人，是否可能想要购买你销售的产品？\n是否有明确的方法将此关键词的流量转换为销售线索？\n从业务角度来看，关键词是否有足够高的搜索量？\n搜索量是否来自你的目标国家或地区？ （即你的客户所在地）\n</code></pre>  </div></div>\n\n<p>如果这些问题的答案都是“不”，那么你可能是找到了一个有 “独角兽特征”的关键词。言下之意，不值得去追逐。</p>\n\n<h3 id=\"3-新域名权威性低找到低难度关键词快速排名\">3. 新域名权威性低？找到低难度关键词快速排名！</h3>\n\n<p>在用一个权威性低的新域名做网站,这样意味着很难把有竞争力的关键字拍上去。</p>\n\n<p>当然，在后期是可以做到排名的，但这并不容易。你可能需要创造非常优质的的内容，然后疯狂的的推广它（以获得曝光和外链）。</p>\n\n<p>所以，新站优先针对竞争力较弱的关键字进行优化，是有道理的。这是新站增长搜索流量最快的方式。</p>\n\n<h4 id=\"例子\">例子：</h4>\n\n<p>与 “Search Engine Optimization”（搜索引擎优化）相关的大多数关键词，具有非常高的关键词难度。\n但是，有一个关键词难度非常的低的词汇，似乎更容易排名.…..</p>\n\n<p><em>“What does SEO stand for”（SEO的意思是什么）</em></p>\n\n<h3 id=\"4-找到竞争对手的大流量入口关键词同时把它们偷过来\">4. 找到竞争对手的大流量入口关键词，同时把它们“偷”过来！</h3>\n\n<p>如果你能确切了解竞争对手排名的关键字，以及这些关键字带来的搜索流量，那会不会很酷？</p>\n\n<p>当然，你可以获取根据网上工具获取到这些关键词并进行分析。</p>\n\n<h4 id=\"小提示-1\">小提示:</h4>\n\n<p>Ahrefs普通账户（Lite Account）可以获得20名以前的，标准账户（Standard Account）可以获取到50名之前的，高级或机构账户（Advanced/Agency）则可以获取到100名以前的关键词。</p>\n\n<h3 id=\"5-设置竞争对手新关键词排名实时提醒\">5. 设置竞争对手新关键词排名实时提醒</h3>\n\n<p>通过监控竞争对手新的关键字排名，就可以关注到竞争对手采用的内容策略。</p>\n\n<p>为什么？因为如果你的竞争对手开始追逐一个新的关键词，那么说不定你也需要追逐它。</p>\n\n<p>这样做非常简单，但是非常的有效！</p>\n\n<h3 id=\"6-通过特定关键词排名第一的页面了解特定页面的流量潜力\">6. 通过特定关键词排名第一的页面，了解特定页面的“流量潜力”</h3>\n\n<p>大多数页面不单单只有特定关键词参与排名，同时会有很多长尾词也参与排名。</p>\n\n<p><strong>例如</strong> “<em>Keyword research”</em>（关键字研究）即主关键词，是有排名的。同时，它还参与了 “<em>How to do keyword research</em>”（如何做关键词研究），“<em>SEO Keyword research</em>”（SEO关键词研究）以及许多其他词的排名。</p>\n\n<p>因此，查看主关键字的搜索量，不会告诉我们这个页面的真实流量潜力。</p>\n\n<p>那么，如何判断关键字的流量潜力呢？检查排名第一的页面能够获得多少流量就可以了！</p>\n\n<p><strong>比如</strong>：关键词 “best VPN”（最好的VPN）的搜索量为105K。</p>\n\n<p>但是，在实际中，你会看到排名第一的页面，每月可能获得约180K+次的自然访问量。</p>\n\n<p>由于该页面针对许多长尾词都拥有对应的排名，因此关键词“Best VPN”（最好的VPN）的真实流量潜力，会远远超过报告的搜索量。</p>\n\n<h3 id=\"7-找到自己与竞争对手的内容差距并补充这些内容\">7. 找到自己与竞争对手的内容差距，并补充这些内容！</h3>\n\n<p>“Content Gap”（内容差距机会），指的是，竞争对手参与的关键词排名，而你没有参与的部分。</p>\n\n<p>这个是很糟糕,为了快速找到自己和竞争对手之间的内容差距，你可以通过网上搜索工具进行查询分析.</p>\n\n<h3 id=\"8-找到和主题相关的问题类关键词然后通过产出内容来回答这些问题\">8. 找到和主题相关的问题类关键词，然后通过产出内容来回答这些问题</h3>\n\n<p>问答网站（例如Quora）是一个非常好的获取关键字、以及内容创意的地方。</p>\n\n<p>其中的诀窍是，寻找多次被问过的问题，这个表明目前在谷歌上找不到好的答案。</p>\n\n<p>还有另外一个技巧,如果你发现谷歌中的某个关键词Quora排名前三，那么该关键字很有可能竞争度不高。如果它不是很有竞争力，作为目标词汇是个不错的选择！</p>\n","dir":"/blog/development/html/seo/","name":"2023-04-27_3.md","path":"blog/development/html/seo/2023-04-27_3.md","url":"/blog/development/html/seo/2023-04-27_3.html"},{"sort":3,"permalink":"/blog/development/java/","layout":"default","title":"Java语言","content":"<h1 id=\"java语言\">Java语言</h1>\n\n<h2 id=\"一-java介绍\">一. Java介绍</h2>\n<p>Java是一种广泛使用的高级编程语言和计算平台，由Sun Microsystems（现在是Oracle Corporation）于1995年推出。它被设计成一种跨平台的语言，可以在各种操作系统上运行，如Windows、macOS和Linux等。</p>\n\n<h3 id=\"一-特点和优势\">(一). 特点和优势</h3>\n<p><strong>简单易学：</strong>Java语法相对简单，并且与C++等其他语言相比较容易学习和理解。</p>\n\n<p><strong>跨平台性：</strong>Java的跨平台性是其最显著的特点之一。Java程序在编译时被转换为中间字节码（bytecode），然后可以在任何支持Java虚拟机（JVM）的平台上运行。</p>\n\n<p><strong>面向对象：</strong>Java是一种面向对象的编程语言，支持封装、继承和多态等面向对象的概念。</p>\n\n<p><strong>垃圾回收：</strong>Java提供自动内存管理，通过垃圾回收器（garbage collector）自动处理内存分配和释放，减轻了开发者的负担，提高了程序的健壮性。</p>\n\n<p><strong>强大的标准库：</strong>Java提供了丰富的标准库（Java API），包含各种用于开发应用程序的类和方法。这些库涵盖了网络编程、图形界面、数据库连接、多线程等各个领域，使开发者能够更轻松地实现各种功能。</p>\n\n<p><strong>大型开发社区：</strong>Java拥有庞大的开发社区和活跃的生态系统，有大量的第三方库、框架和工具可供选择，方便开发者加快开发进程。</p>\n\n<p>Java被广泛应用于各个领域，包括企业级应用开发、桌面应用程序、移动应用开发（Android平台）、嵌入式系统、大数据处理等。它的稳定性、安全性和可靠性使得Java成为许多组织和开发者的首选编程语言之一。</p>\n\n<h3 id=\"二-语言特性\">(二). 语言特性</h3>\n\n<p><strong>面向对象：</strong>Java是一种面向对象的编程语言，支持封装、继承和多态等面向对象的概念。</p>\n\n<p><strong>平台无关性：</strong>Java的跨平台性使得Java程序可以在不同的操作系统上运行，只需在目标平台上安装对应的Java虚拟机（JVM）即可。</p>\n\n<p><strong>自动内存管理：</strong>Java提供了垃圾回收机制，通过自动内存管理功能，开发者无需手动进行内存分配和释放，减少了内存泄漏和悬挂指针等问题。</p>\n\n<p><strong>异常处理：</strong>Java提供了强大的异常处理机制，可以捕获和处理运行时异常，保证程序的稳定性和可靠性。</p>\n\n<p><strong>多线程支持：</strong>Java内置了多线程支持，可以方便地创建和管理多线程应用，实现并发编程。</p>\n\n<h3 id=\"三-平台和生态系统\">(三). 平台和生态系统</h3>\n\n<p><strong>Java平台：</strong>Java平台由Java虚拟机（JVM）和Java开发工具集（JDK）组成。JVM负责解释和执行Java字节码，JDK包含了编译器、调试器和其他开发工具。</p>\n\n<p><strong>Java标准库：</strong>Java标准库（Java API）提供了大量的类和方法，涵盖了各种领域，如网络编程、图形界面、数据库连接、多线程等。开发者可以直接使用这些类和方法来加快开发进程。</p>\n\n<p><strong>第三方库和框架：</strong>Java拥有庞大的第三方库和框架生态系统，如Spring、Hibernate、Apache Commons等，这些库和框架提供了丰富的功能和工具，简化了开发过程。</p>\n\n<p><strong>开发工具：</strong>Java开发可以使用众多开发工具，如Eclipse、IntelliJ IDEA和NetBeans等集成开发环境（IDE），以及Maven和Gradle等构建工具。</p>\n\n<h3 id=\"四-应用领域\">(四). 应用领域：</h3>\n\n<p><strong>企业级应用：</strong>Java EE（Java Enterprise Edition）为开发大规模企业级应用提供了丰富的API和组件，如Servlet、JSP、EJB等。Java EE广泛应用于企业应用开发，支持分布式计算和高可靠性。</p>\n\n<p><strong>桌面应用：</strong>Java提供了Swing和JavaFX等图形界面库，可以开发跨平台的桌面应用程序，如图形化编辑器、游戏等。</p>\n\n<p><strong>移动应用：</strong>通过使用Java和Android SDK，开发者可以构建Android平台上的移动应用程序，涵盖从智能手机到平板电脑等各种设备。</p>\n\n<h3 id=\"五-java版本\">(五). Java版本</h3>\n<h4 id=\"1-主要版本\">1. 主要版本</h4>\n<p><strong>Java 1.0：</strong>Java的初始版本，于1996年发布，引入了Java语言的基本特性和核心库。</p>\n\n<p><strong>Java 1.1：</strong>于1997年发布，增加了内部类、反射、RMI（远程方法调用）等功能，并进行了性能优化和改进。</p>\n\n<p><strong>Java 1.2（Java 2）：</strong>于1998年发布，引入了Java虚拟机的升级版本，提供了Java 2标准版（J2SE）、Java 2企业版（J2EE）和Java 2移动版（J2ME）三个平台。</p>\n\n<p><strong>Java 1.3：</strong>于2000年发布，引入了新的垃圾回收器和性能优化，增强了Swing图形界面库。</p>\n\n<p><strong>Java 1.4：</strong>于2002年发布，引入了增强的异常处理、正则表达式、XML处理等功能，并进行了性能改进。</p>\n\n<p><strong>Java 5（Java 1.5）：</strong>于2004年发布，引入了重要的语言和库特性，如泛型、枚举、自动装箱/拆箱、可变参数等，以及Java虚拟机的性能改进。</p>\n\n<p><strong>Java 6（Java 1.6）：</strong>于2006年发布，引入了一些新的语言特性和库改进，如脚注、JDBC 4.0、增强的JVM诊断等。</p>\n\n<p><strong>Java 7（Java 1.7）：</strong>于2011年发布，引入了语言和库的一些重要改进，如Diamond操作符、try-with-resources语句、Switch语句的字符串支持等。</p>\n\n<p><strong>Java 8（Java 1.8）：</strong>于2014年发布，带来了重要的语言特性和库改进，最引人注目的是Lambda表达式、Stream API、新的日期/时间API等。</p>\n\n<p><strong>Java 9：</strong>于2017年发布，引入了模块化系统（Java平台模块系统，JPMS）、JShell交互式命令行工具、改进的垃圾回收器等。</p>\n\n<p><strong>Java 10：</strong>于2018年发布，带来了局部变量类型推断、基于时间的版本号等小型改进。</p>\n\n<p><strong>Java 11：</strong>于2018年发布，是Oracle提供的免费长期支持（LTS）版本，引入了许多改进，包括HTTP客户端API、局部变量语法、ZGC垃圾回收器等。</p>\n\n<p><strong>Java 12至Java 17：</strong>这些版本在2019年至2021年期间陆续发布，带来了一系列的增强和改进，包括新的语言特性、垃圾回收器优化、性能改进等。</p>\n\n<h4 id=\"2-java-mejava-se和java-ee\">2. Java ME、Java SE和Java EE</h4>\n<p><strong>Java SE（Java Standard Edition）</strong>和<strong>Java EE（Java Enterprise Edition）</strong>是Java平台的两个不同的版本。</p>\n\n<p><strong>Java SE</strong>是Java平台的标准版，提供了基本的Java核心库和运行环境，用于开发和运行独立的桌面和命令行应用程序。它包含了Java语言的基本特性，如面向对象编程、异常处理、多线程等，以及核心库，如集合框架、输入输出、网络编程等。Java SE是Java开发的基础，几乎所有的Java应用程序都建立在Java SE的基础上。</p>\n\n<p><strong>Java EE</strong>是Java平台的企业版，用于开发和运行企业级应用程序。它在Java SE的基础上提供了一系列的扩展和组件，用于构建分布式、可扩展和可靠的企业应用。Java EE包含了许多规范和API，如Servlet、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）、Java Persistence API（JPA）等。它还提供了支持事务管理、安全性、消息传递、Web服务等企业级特性。</p>\n\n<p>简而言之，Java SE是Java的标准版，用于开发独立应用程序，而Java EE是Java的企业版，用于开发企业级应用程序，提供了更多的功能和组件来支持分布式和企业级需求。两者并不是相互排斥的关系，Java EE是基于Java SE构建的，因此Java EE应用程序也依赖于Java SE的功能和库。</p>\n\n<p><strong>Java ME</strong>就和<strong>Java SE</strong>不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。Java ME从来没有真正流行起来，反而是Android开发成为了移动平台的标准之一，因此，没有特殊需求，不建议学习Java ME。</p>\n\n<h2 id=\"二-java常用框架有哪些\">二. Java常用框架有哪些？</h2>\n<p>Java有许多流行的框架，用于开发各种类型的应用程序。以下是一些常用的Java框架：</p>\n\n<p>Spring框架：Spring是一个轻量级的Java框架，提供了广泛的功能和模块，用于开发企业级应用程序。它包括Spring Core、Spring MVC、Spring Boot等模块，提供依赖注入、面向切面编程、Web开发、数据库访问等功能。</p>\n\n<p>Hibernate框架：Hibernate是一个Java持久化框架，用于简化对象关系映射（ORM）的开发。它提供了一种将Java对象映射到关系数据库表的方式，使开发者能够以面向对象的方式进行数据库操作。</p>\n\n<p>Apache Struts框架：Struts是一个用于开发基于Java EE的Web应用程序的框架。它遵循MVC（模型-视图-控制器）设计模式，提供了一个基于配置的开发模型，简化了Web应用程序的开发过程。</p>\n\n<p>JavaServer Faces（JSF）框架：JSF是Java EE的一部分，提供了一组用于构建用户界面的组件和API。它采用了组件化的开发模型，开发者可以使用可重用的组件构建动态的Web界面。</p>\n\n<p>Apache Wicket框架：Wicket是一个面向对象的Web应用程序框架，它允许开发者使用Java和HTML来构建Web应用程序。它采用了组件化的开发模型，具有良好的可测试性和可维护性。</p>\n\n<p>Play框架：Play是一个轻量级的Web应用程序框架，用于构建响应式的、可扩展的Web应用程序。它提供了一个简单的开发模型，支持Java和Scala语言。</p>\n\n<p>Apache Camel框架：Camel是一个开源的集成框架，用于实现企业集成模式。它提供了各种组件和API，用于连接和转换不同的应用程序和数据源。</p>\n\n<p>这只是一小部分Java框架的例子，还有许多其他框架可用于不同类型的应用程序开发。选择适合你项目需求的框架时，需要考虑你的应用程序类型、规模和团队技能等因素。</p>\n\n<ul>\n <li><a href=\"/blog/development/java/jottings/\">随笔</a>\n <ul>\n <li><a href=\"/blog/development/java/jottings/2023-04-23_1.html\">Java学习大纲路径</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_1.html\">Spring中的事务回滚机制</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_2.html\">Java开发环境安装配置JDK+Maven+Tomcat</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-05-12_1.html\">Restful风格开发方式</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-05-18_1.html\">Java8 新特性全面介绍</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/basics/\">Java基础</a>\n <ul>\n <li><a href=\"/blog/development/java/basics/2023-04-24_1.html\">Java中map常见操作集合</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_2.html\">Java中Json转换的常见操作方式</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_3.html\">Java中计算List求和或List对象中某个字段的总和</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-27_1.html\">Java中BigDecimal类型详解</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/framework/\">Java框架</a>\n <ul>\n <li><a href=\"/blog/development/java/framework/spring/\">Spring Framework</a>\n <ul>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_1.html\">Spring IOC 容器</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_2.html\">Spring AOP使用</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_3.html\">Spring 访问数据库</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_4.html\">Spring 开发Web应用</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_5.html\">Spring 集成第三方组件</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/tool/\">工具包</a>\n <ul>\n <li><a href=\"/blog/development/java/tool/2023-05-12_1.html\">EASYEXCEL使用详解</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/java/","name":"README.md","path":"blog/development/java/README.md","url":"/blog/development/java/"},{"sort":3,"layout":"default","title":"Git常用操作命令","content":"<h1 id=\"git常用操作命令\">Git常用操作命令</h1>\n\n<h2 id=\"一-初始配置\">一. 初始配置</h2>\n\n<h3 id=\"1-账号邮箱配置\">1. 账号邮箱配置</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git config --global user.name test\ngit config --global user.email test@test.com\n</code></pre>  </div></div>\n<h3 id=\"2-alias简写配置\">2. alias简写配置</h3>\n<p>在Git中，你可以使用alias（别名）来为常用的Git命令创建简写配置。通过别名，你可以用更短、更简洁的方式执行常用的Git操作。</p>\n<h4 id=\"21-使用git-config命令配置别名\">2.1 使用git config命令配置别名：</h4>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git config --global alias.cp cherry-pick\ngit config --global alias.co checkout\ngit config --global alias.ci commit\ngit config --global alias.br branch\ngit config --global alias.st status\n</code></pre>  </div></div>\n<p>上述命令将创建了三个别名：cp代表cherry-pick命令，co代表checkout命令，br代表branch命令，ci代表commit命令，st代表status命令。你可以根据自己的喜好和习惯配置其他别名。</p>\n\n<h4 id=\"22-直接编辑git的配置文件\">2.2 直接编辑Git的配置文件</h4>\n\n<p>通过编辑~/.gitconfig文件（对于Windows用户来说，是C:\\Users\\你的用户名.gitconfig），你可以手动添加别名的配置。在文件中添加如下内容：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[alias]\n    co = checkout\n    br = branch\n    ci = commit\n</code></pre>  </div></div>\n<p>同样的，上述配置会创建三个别名。</p>\n\n<p>这样配置之后，你可以使用简写的命令来执行相应的Git操作。例如，git co相当于git checkout，git br相当于git branch，git ci相当于git commit。</p>\n\n<p>注意，通过–global选项配置的别名将适用于全局范围，即在你的所有Git仓库中都可使用。如果你只想在当前仓库中使用别名，可以省略–global选项，然后在仓库的.git/config文件中添加别名配置。</p>\n\n<h3 id=\"3--warning-lf-will-be-replaced-by-crlf\">3. warning: LF will be replaced by CRLF</h3>\n<p>该警告表示在Git中发现了换行符的不一致性。在Windows系统中，默认使用CRLF（回车加换行符）作为行尾符，而在Unix/Linux系统中，默认使用LF（换行符）作为行尾符。</p>\n\n<p>这个警告通常出现在跨平台协作或在不同平台上使用Git时，例如在Windows和Unix/Linux之间切换。</p>\n\n<p>Git会自动进行换行符的转换，以便确保文件在不同系统上的一致性。在这种情况下，Git发现你的代码中使用了LF作为行尾符，但它将被转换为CRLF。</p>\n\n<p>虽然这个警告不会影响代码的功能性，但如果你希望避免这个警告，可以采取以下几种解决方案之一：</p>\n\n<p><strong>忽略警告（不推荐）</strong>：你可以通过设置Git配置来忽略该警告，但这并不是一个推荐的做法，因为它可能导致行尾符不一致性的问题。在Git命令行中运行以下命令以忽略警告：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git config --global core.safecrlf false\n</code></pre>  </div></div>\n<p><strong>转换行尾符为LF</strong>：如果你在Windows上开发，可以考虑将行尾符转换为LF。在Git命令行中运行以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git config --global core.autocrlf input\n</code></pre>  </div></div>\n<p><strong>转换行尾符为CRLF</strong>：如果你在Unix/Linux上开发，并且希望行尾符被转换为CRLF，可以运行以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git config --global core.autocrlf true\n</code></pre>  </div></div>\n<p>根据你的开发环境和需求，选择适合的解决方案，并确保在团队协作时所有成员都使用相同的换行符设置，以避免不必要的换行符警告。</p>\n\n<h3 id=\"4-gitwindows中文名称路径变成xx解决\">4. git:windows中文名称、路径变成xx%解决</h3>\n<p>当在Windows中使用Git时，如果Git的文件名或路径中包含中文字符，有时会出现被编码为xx%的情况。这是因为在Windows中，默认情况下，Git使用UTF-8编码，而Windows使用的是ANSI编码。</p>\n\n<p>要解决这个问题，你可以进行以下设置：</p>\n\n<p><strong>设置Git的文件名和路径编码</strong>：在Git Bash中，运行以下命令来将Git的文件名和路径编码设置为UTF-8：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git config --global core.quotepath false\n</code></pre>  </div></div>\n<p><strong>设置Windows系统的本地编码</strong>：如果Git的文件名和路径还是显示为xx%，则需要确保Windows系统的本地编码设置与Git的编码一致。你可以按照以下步骤更改Windows系统的本地编码为UTF-8：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>在桌面上右键点击\"开始\"按钮，并选择\"运行\"。\n输入regedit并按下回车键，打开注册表编辑器。\n导航到以下路径：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage。\n双击右侧窗口中的\"ACP\"，将数值数据更改为\"65001\"。\n关闭注册表编辑器，并重新启动计算机使更改生效。 通过上述设置，Git应该能够正确地处理中文字符的文件名和路径，避免出现xx%的情况。\n</code></pre>  </div></div>\n\n<h3 id=\"5-git代理配置\">5. git代理配置</h3>\n<p>要在Git中配置代理，你可以通过以下几种方式</p>\n\n<p><strong>方式一：使用git config命令配置代理</strong>：在Git命令行中，运行以下命令来配置代理：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 设置HTTP代理\ngit config --global http.proxy &lt;代理地址&gt;\n\n# 设置HTTPS代理\ngit config --global https.proxy &lt;代理地址&gt;\n</code></pre>  </div></div>\n<p>将<代理地址>替换为你的代理服务器地址，包括主机名和端口号。例如，如果代理服务器位于proxy.example.com的端口8888上，命令将如下所示：</代理地址></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git config --global http.proxy http://proxy.example.com:8888\ngit config --global https.proxy http://proxy.example.com:8888\n</code></pre>  </div></div>\n<p>要清除已配置的代理，可以使用以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git config --global --unset http.proxy\ngit config --global --unset https.proxy\n</code></pre>  </div></div>\n<p><strong>方式二：编辑.gitconfig文件</strong>：手动编辑~/.gitconfig文件（对于Windows用户来说，是C:\\Users\\你的用户名.gitconfig），并添加以下内容：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>[http]\n    proxy = &lt;代理地址&gt;\n[https]\n    proxy = &lt;代理地址&gt;\n</code></pre>  </div></div>\n<p>将<代理地址>替换为你的代理服务器地址，与上述命令相同。</代理地址></p>\n\n<p>在配置代理之后，Git将通过指定的代理服务器进行HTTP和HTTPS通信。这对于需要通过代理访问远程仓库或下载依赖项的场景非常有用。</p>\n\n<p>确保代理服务器的地址和端口号正确，并在需要时提供代理的用户名和密码，以便成功连接到代理服务器。如果你的代理服务器需要身份验证，参考代理服务器的文档来获取详细配置说明。</p>\n\n<h2 id=\"二-git配置gitignore操作\">二. git配置.gitignore操作</h2>\n<h3 id=\"1-git移除指定目录版本控制\">1. git移除指定目录版本控制</h3>\n<p>如果你想要移除 Git 版本控制系统中的某个指定目录，可以按照以下步骤进行操作：</p>\n\n<p>1.通过 cd 命令进入该 Git 仓库所在的目录。</p>\n\n<p>2.执行以下命令，将需要移除版本控制的目录添加到 .gitignore 文件中，例如，如果你想要移除名为 example 的目录，可以执行以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>echo \"example/\" &gt;&gt; .gitignore\n</code></pre>  </div></div>\n<p>注意，如果 .gitignore 文件还不存在，可以通过以下命令创建：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>touch .gitignore\n</code></pre>  </div></div>\n<p>3.执行以下命令，删除版本库中的指定目录，但不删除本地文件：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git rm -r --cached example\n</code></pre>  </div></div>\n<p>这条命令会将 example 目录从 Git 版本库中删除，并从 Git 跟踪列表中删除。注意，使用 –cached 选项来仅仅删除 Git 跟踪列表，而不会删除本地文件。</p>\n\n<p>4.执行以下命令，提交修改：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git commit -m \"Remove example directory from version control\"\n</code></pre>  </div></div>\n<p>这条命令会提交修改并添加一个提交信息，告诉 Git 你已经从版本控制中移除了 example 目录。</p>\n\n<p>5.执行以下命令，推送修改：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git push\n</code></pre>  </div></div>\n<p>这条命令会将修改推送到远程仓库。</p>\n\n<p>现在，example 目录已经被从版本控制中移除了。注意，这些操作不会删除本地文件，只会从 Git 版本控制系统中移除指定目录。如果需要删除本地文件，可以手动删除它们。</p>\n\n<h3 id=\"2-只忽略指定目录下的文件不忽略目录\">2. 只忽略指定目录下的文件，不忽略目录</h3>\n<p>在.gitignore文件中，可以忽略指定目录下的文件，不忽略目录。但是，如果该目录下没有任何文件被跟踪，Git将不会包括该目录。在Git中，只有跟踪的文件才会被提交。</p>\n\n<p>如果你想要提交一个空目录，可以在该目录中添加一个.gitkeep文件，并将其添加到版本控制中。.gitkeep文件不需要任何内容，它只是作为一个标记来确保Git跟踪该目录。</p>\n\n<p>举个例子，在.gitignore中，忽略指定目录下的所有文件，但不忽略该目录下的：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/my_directory/*\n!/my_directory/.gitkeep\n</code></pre>  </div></div>\n<p>这样，在提交时，my_directory目录和.gitkeep文件将被包括在版本控制中。</p>\n\n<h2 id=\"三-git分支操作\">三. git分支操作</h2>\n<h3 id=\"1-git删除远程分支\">1. git删除远程分支</h3>\n<p>要删除 Git 远程分支，可以使用以下命令：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git push &lt;remote_name&gt; --delete &lt;branch_name&gt;\n</code></pre>  </div></div>\n<p>其中，<remote_name> 是你的远程仓库名称，一般为 origin；<branch_name> 是你要删除的分支名称。</branch_name></remote_name></p>\n\n<p>例如，要删除名为 my-feature-branch 的远程分支，可以使用以下命令：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git push origin --delete my-feature-branch\n</code></pre>  </div></div>\n<p>执行完毕后，该分支就会被从远程仓库中删除。</p>\n","dir":"/blog/development/tool/git/","name":"2023-05-12_1.md","path":"blog/development/tool/git/2023-05-12_1.md","url":"/blog/development/tool/git/2023-05-12_1.html"},{"sort":4,"layout":"default","title":"Java面试宝典四(2023最新Java面试题)","content":"<h1 id=\"java面试宝典四2023最新java面试题\">Java面试宝典四(2023最新Java面试题)</h1>\n\n<h2 id=\"一-rabbitmq\"><strong>一. RabbitMQ</strong></h2>\n\n<h3 id=\"1-rabbitmq-的使用场景有哪些\"><strong>1. RabbitMQ 的使用场景有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>抢购活动：削峰填谷，防止系统崩塌。\n延迟信息处理：比如 10 分钟之后给下单未付款的用户发送邮件提醒。\n解耦系统：对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。\n</code></pre>  </div></div>\n\n<h3 id=\"2-rabbitmq-有哪些重要的角色\"><strong>2. RabbitMQ 有哪些重要的角色？</strong></h3>\n\n<p>RabbitMQ中重要的角色有：生产者、消费者和代理：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>生产者：消息的创建者，负责创建和推送数据到消息服务器；\n消费者：消息的接收方，用于处理数据和确认消息；\n代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。\n</code></pre>  </div></div>\n\n<h3 id=\"3-rabbitmq-有哪些重要的组件\"><strong>3. RabbitMQ 有哪些重要的组件？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。\nChannel（信道）：消息推送使用的通道。\nExchange（交换器）：用于接受、分配消息。\nQueue（队列）：用于存储生产者的消息。\nRoutingKey（路由键）：用于把生成者的数据分配到交换器上。\nBindingKey（绑定键）：用于把交换器的消息绑定到队列上。\n</code></pre>  </div></div>\n\n<h3 id=\"4-rabbitmq-中-vhost-的作用是什么\"><strong>4. RabbitMQ 中 vhost 的作用是什么？</strong></h3>\n\n<p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p>\n\n<h3 id=\"5-rabbitmq-的消息是怎么发送的\"><strong>5. RabbitMQ 的消息是怎么发送的？</strong></h3>\n\n<p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>\n\n<h3 id=\"6-rabbitmq-怎么保证消息的稳定性\"><strong>6. RabbitMQ 怎么保证消息的稳定性？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>提供了事务的功能。\n通过将 channel 设置为 confirm（确认）模式。\n</code></pre>  </div></div>\n\n<h3 id=\"7-rabbitmq-怎么避免消息丢失\"><strong>7. RabbitMQ 怎么避免消息丢失？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>把消息持久化磁盘，保证服务器重启消息不丢失。\n每个集群中至少有一个物理磁盘，保证消息落入磁盘。\n</code></pre>  </div></div>\n\n<h3 id=\"8-要保证消息持久化成功的条件有哪些\"><strong>8. 要保证消息持久化成功的条件有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>声明队列必须设置持久化 durable 设置为 true.\n消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。\n消息已经到达持久化交换器。\n消息已经到达持久化队列。\n</code></pre>  </div></div>\n\n<p>以上四个条件都满足才能保证消息持久化成功。</p>\n\n<h3 id=\"9-rabbitmq-持久化有什么缺点\"><strong>9. RabbitMQ 持久化有什么缺点？</strong></h3>\n\n<p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p>\n\n<h3 id=\"10-rabbitmq-有几种广播类型\"><strong>10. RabbitMQ 有几种广播类型？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。\nheaders：与 direct 类似，只是性能很差，此类型几乎用不到。\nfanout：分发模式，把消费分发给所有订阅者。\ntopic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。\n</code></pre>  </div></div>\n\n<h3 id=\"11-rabbitmq-怎么实现延迟消息队列\"><strong>11. RabbitMQ 怎么实现延迟消息队列？</strong></h3>\n\n<p>延迟队列的实现有两种方式：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；\n使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。\n</code></pre>  </div></div>\n\n<h3 id=\"12-rabbitmq-集群有什么用\"><strong>12. RabbitMQ 集群有什么用？</strong></h3>\n\n<p>集群主要有以下两个用途：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；\n高容量：集群可以承载更多的消息量。\n</code></pre>  </div></div>\n\n<h3 id=\"13-rabbitmq-节点的类型有哪些\"><strong>13. RabbitMQ 节点的类型有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>磁盘节点：消息会存储到磁盘。\n内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。\n</code></pre>  </div></div>\n\n<h3 id=\"14-rabbitmq-集群搭建需要注意哪些问题\"><strong>14. RabbitMQ 集群搭建需要注意哪些问题？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>各节点之间使用“--link”连接，此属性不能忽略。\n各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。\n整个集群中必须包含一个磁盘节点。\n</code></pre>  </div></div>\n\n<h3 id=\"15-rabbitmq-每个节点是其他节点的完整拷贝吗为什么\"><strong>15. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</strong></h3>\n\n<p>不是，原因有以下两个：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；\n性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。\n</code></pre>  </div></div>\n\n<h3 id=\"16-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况\"><strong>16. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</strong></h3>\n\n<p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>不能创建队列\n不能创建交换器\n不能创建绑定\n不能添加用户\n不能更改权限\n不能添加和删除集群节点\n</code></pre>  </div></div>\n\n<p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p>\n\n<h3 id=\"17-rabbitmq-对集群节点停止顺序有要求吗\"><strong>17. RabbitMQ 对集群节点停止顺序有要求吗？</strong></h3>\n\n<p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>\n\n<h2 id=\"二-kafka\"><strong>二. Kafka</strong></h2>\n\n<h3 id=\"1-kafka-可以脱离-zookeeper-单独使用吗为什么\"><strong>1. kafka 可以脱离 zookeeper 单独使用吗？为什么？</strong></h3>\n\n<p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>\n\n<h3 id=\"2-kafka-有几种数据保留的策略\"><strong>2. kafka 有几种数据保留的策略？</strong></h3>\n\n<p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>\n\n<h3 id=\"3-kafka-同时设置了-7-天和-10g-清除数据到第五天的时候消息达到了-10g这个时候-kafka-将如何处理\"><strong>3. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</strong></h3>\n\n<p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>\n\n<h3 id=\"4-什么情况会导致-kafka-运行变慢\"><strong>4. 什么情况会导致 kafka 运行变慢？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cpu 性能瓶颈\n磁盘读写瓶颈\n网络瓶颈\n</code></pre>  </div></div>\n\n<h3 id=\"5-使用-kafka-集群需要注意什么\"><strong>5. 使用 kafka 集群需要注意什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。\n集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。\n</code></pre>  </div></div>\n\n<h2 id=\"三-zookeeper\"><strong>三. Zookeeper</strong></h2>\n\n<h3 id=\"1-zookeeper-是什么\"><strong>1. zookeeper 是什么？</strong></h3>\n\n<p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>\n\n<h3 id=\"2-zookeeper-都有哪些功能\"><strong>2. zookeeper 都有哪些功能？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.集群管理：监控节点存活状态、运行请求等。\n2.主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。\n3.分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。\n4.命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。\n</code></pre>  </div></div>\n\n<h3 id=\"3-zookeeper-有几种部署模式\"><strong>3. zookeeper 有几种部署模式？</strong></h3>\n\n<p>zookeeper 有三种部署模式：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>单机部署：一台集群上运行；\n集群部署：多台集群运行；\n伪集群部署：一台集群启动多个 zookeeper 实例运行。\n</code></pre>  </div></div>\n\n<h3 id=\"4-zookeeper-怎么保证主从节点的状态同步\"><strong>4. zookeeper 怎么保证主从节点的状态同步？</strong></h3>\n\n<p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。</p>\n\n<p>zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>\n\n<h3 id=\"5-集群中为什么要有主节点\"><strong>5. 集群中为什么要有主节点？</strong></h3>\n\n<p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>\n\n<h3 id=\"6-集群中有-3-台服务器其中一个节点宕机这个时候-zookeeper-还可以使用吗\"><strong>6. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</strong></h3>\n\n<p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>\n\n<h3 id=\"7-说一下-zookeeper-的通知机制\"><strong>7. 说一下 zookeeper 的通知机制？</strong></h3>\n\n<p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>\n\n<h2 id=\"四-mysql\"><strong>四. MySQL</strong></h2>\n\n<h3 id=\"1-数据库的三范式是什么\"><strong>1. 数据库的三范式是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。\n第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。\n第三范式：任何非主属性不依赖于其它非主属性。\n</code></pre>  </div></div>\n\n<h3 id=\"2-一张自增表里面总共有-7-条数据删除了最后-2-条数据重启-mysql-数据库又插入了一条数据此时-id-是几\"><strong>2. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>表类型如果是 MyISAM ，那 id 就是 8。\n表类型如果是 InnoDB，那 id 就是 6。\n</code></pre>  </div></div>\n\n<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>\n\n<h3 id=\"3-如何获取当前数据库版本\"><strong>3. 如何获取当前数据库版本？</strong></h3>\n\n<p>使用 select version() 获取当前 MySQL 数据库版本。</p>\n\n<h3 id=\"4-说一下-acid-是什么\"><strong>4. 说一下 ACID 是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。\n\nConsistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。\n\nIsolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n\nDurability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n</code></pre>  </div></div>\n\n<h3 id=\"5-char-和-varchar-的区别是什么\"><strong>5. char 和 varchar 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>「char(n)」：固定长度类型，比如订阅 char(10)，当你输入\"abc\"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。\n</code></pre>  </div></div>\n\n<p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>「varchar(n)」：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。\n</code></pre>  </div></div>\n\n<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>\n\n<h3 id=\"6-float-和-double-的区别是什么\"><strong>6. float 和 double 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。\ndouble 最可可以存储 16 位的十进制数，并在内存中占 8 字节。\n</code></pre>  </div></div>\n\n<h3 id=\"7-mysql-的内连接左连接右连接有什么区别\"><strong>7. MySQL 的内连接、左连接、右连接有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>内连接关键字：inner join；\n左连接：left join；\n右连接：right join。\n</code></pre>  </div></div>\n\n<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>\n\n<h3 id=\"8-mysql-索引是怎么实现的\"><strong>8. MySQL 索引是怎么实现的？</strong></h3>\n\n<p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>\n\n<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>\n\n<h3 id=\"9-怎么验证-mysql-的索引是否满足需求\"><strong>9. 怎么验证 MySQL 的索引是否满足需求？</strong></h3>\n\n<p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>explain 语法：explain select * from table where type=1。\n</code></pre>  </div></div>\n\n<h3 id=\"10-说一下数据库的事务隔离\"><strong>10. 说一下数据库的事务隔离？</strong></h3>\n\n<p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>transaction-isolation = REPEATABLE-READ  \n</code></pre>  </div></div>\n\n<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。\nREAD-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。\nREPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。\nSERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n「脏读」 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。\n\n「不可重复读」 ：是指在一个事务内，多次读同一数据。\n\n「幻读」 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。\n</code></pre>  </div></div>\n\n<h3 id=\"11-说一下-mysql-常用的引擎\"><strong>11. 说一下 MySQL 常用的引擎？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。\n\nMyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。\n</code></pre>  </div></div>\n\n<h3 id=\"12-说一下-mysql-的行锁和表锁\"><strong>12. 说一下 MySQL 的行锁和表锁？</strong></h3>\n\n<p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。\n行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。\n</code></pre>  </div></div>\n\n<h3 id=\"13-说一下乐观锁和悲观锁\"><strong>13. 说一下乐观锁和悲观锁？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。\n悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。\n</code></pre>  </div></div>\n\n<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>\n\n<h3 id=\"14-mysql-问题排查都有哪些手段\"><strong>14. MySQL 问题排查都有哪些手段？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>使用 show processlist 命令查看当前所有连接信息。\n使用 explain 命令查询 SQL 语句执行计划。\n开启慢查询日志，查看慢查询的 SQL。\n</code></pre>  </div></div>\n\n<h3 id=\"15-如何做-mysql-的性能优化\"><strong>15. 如何做 MySQL 的性能优化？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>为搜索字段创建索引。\n避免使用 select *，列出需要查询的字段。\n垂直分割分表。\n选择正确的存储引擎。\n</code></pre>  </div></div>\n\n<h2 id=\"五-redis\"><strong>五. Redis</strong></h2>\n\n<h3 id=\"1-redis-是什么都有哪些使用场景\"><strong>1. Redis 是什么？都有哪些使用场景？</strong></h3>\n\n<p>Redis 是一个使用 C 语言开发的高速缓存数据库。</p>\n\n<p>Redis 使用场景：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>记录帖子点赞数、点击数、评论数；\n缓存近期热帖；\n缓存文章详情信息；\n记录用户会话信息。\n</code></pre>  </div></div>\n\n<h3 id=\"2-redis-有哪些功能\"><strong>2. Redis 有哪些功能？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>数据缓存功能\n分布式锁的功能\n支持数据持久化\n支持事务\n支持消息队列\n</code></pre>  </div></div>\n\n<h3 id=\"3-redis-和-memcache-有什么区别\"><strong>3. Redis 和 memcache 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。\n数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。\n使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。\nvalue 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。\n</code></pre>  </div></div>\n\n<h3 id=\"4-redis-为什么是单线程的\"><strong>4. Redis 为什么是单线程的？</strong></h3>\n\n<p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>\n\n<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n\n<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>\n\n<h3 id=\"5-什么是缓存穿透怎么解决\"><strong>5. 什么是缓存穿透？怎么解决？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。\n\n解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n</code></pre>  </div></div>\n\n<h3 id=\"6-redis-支持的数据类型有哪些\"><strong>6. Redis 支持的数据类型有哪些？</strong></h3>\n\n<p>Redis 支持的数据类型：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。\n</code></pre>  </div></div>\n\n<h3 id=\"7-redis-支持的-java-客户端都有哪些\"><strong>7. Redis 支持的 Java 客户端都有哪些？</strong></h3>\n\n<p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p>\n\n<h3 id=\"8-jedis-和-redisson-有哪些区别\"><strong>8. jedis 和 Redisson 有哪些区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jedis：提供了比较全面的 Redis 命令的支持。\nRedisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。\n</code></pre>  </div></div>\n\n<h3 id=\"9-怎么保证缓存和数据库数据的一致性\"><strong>9. 怎么保证缓存和数据库数据的一致性？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>合理设置缓存的过期时间。\n新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。\n</code></pre>  </div></div>\n\n<h3 id=\"10-redis-持久化有几种方式\"><strong>10. Redis 持久化有几种方式？</strong></h3>\n\n<p>Redis 的持久化有两种方式，或者说有两种策略：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。\nAOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。\n</code></pre>  </div></div>\n\n<h3 id=\"11-redis-怎么实现分布式锁\"><strong>11. Redis 怎么实现分布式锁？</strong></h3>\n\n<p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>\n\n<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>\n\n<h3 id=\"12-redis-分布式锁有什么缺陷\"><strong>12. Redis 分布式锁有什么缺陷？</strong></h3>\n\n<p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>\n\n<h3 id=\"13-redis-如何做内存优化\"><strong>13. Redis 如何做内存优化？</strong></h3>\n\n<p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p>\n\n<h3 id=\"14-redis-淘汰策略有哪些\"><strong>14. Redis 淘汰策略有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>volatile-lru：从已设置过期时间的数据集（server. db\\[i\\]. expires）中挑选最近最少使用的数据淘汰。\nvolatile-ttl：从已设置过期时间的数据集（server. db\\[i\\]. expires）中挑选将要过期的数据淘汰。\nvolatile-random：从已设置过期时间的数据集（server. db\\[i\\]. expires）中任意选择数据淘汰。\nallkeys-lru：从数据集（server. db\\[i\\]. dict）中挑选最近最少使用的数据淘汰。\nallkeys-random：从数据集（server. db\\[i\\]. dict）中任意选择数据淘汰。\nno-enviction（驱逐）：禁止驱逐数据。\n</code></pre>  </div></div>\n\n<h3 id=\"15-redis-常见的性能问题有哪些该如何解决\"><strong>15. Redis 常见的性能问题有哪些？该如何解决？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。\n\nRedis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。\n</code></pre>  </div></div>\n\n<h2 id=\"六-jvm\"><strong>六. JVM</strong></h2>\n\n<h3 id=\"1-说一下-jvm-的主要组成部分及其作用\"><strong>1. 说一下 JVM 的主要组成部分？及其作用？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>类加载器（ClassLoader）\n运行时数据区（Runtime Data Area）\n执行引擎（Execution Engine）\n本地库接口（Native Interface）\n\n「组件的作用」：首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。\n</code></pre>  </div></div>\n\n<h3 id=\"2-说一下-jvm-运行时数据区\"><strong>2. 说一下 JVM 运行时数据区？</strong></h3>\n\n<p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；\n\nJava 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；\n\n本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；\n\nJava 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；\n\n方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\n</code></pre>  </div></div>\n\n<h3 id=\"3-说一下堆栈的区别\"><strong>3. 说一下堆栈的区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>功能方面：堆是用来存放对象的，栈是用来执行程序的。\n共享性：堆是线程共享的，栈是线程私有的。\n空间大小：堆大小远远大于栈。\n</code></pre>  </div></div>\n\n<h3 id=\"4-队列和栈是什么有什么区别\"><strong>4. 队列和栈是什么？有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>队列和栈都是被用来预存储数据的。\n\n队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。\n\n栈和队列很相似，但它运行对元素进行后进先出进行检索。\n</code></pre>  </div></div>\n\n<h3 id=\"5-什么是双亲委派模型\"><strong>5. 什么是双亲委派模型？</strong></h3>\n\n<p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>\n\n<p>类加载器分类：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；\n\n其他类加载器：\n扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style=\"box-sizing: border-box; outline: 0px !important;\"&gt;libext目录或Java. ext. dirs系统变量指定的路径中的所有类库；\n应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。\n</code></pre>  </div></div>\n\n<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>\n\n<h3 id=\"6-说一下类装载的执行过程\"><strong>6. 说一下类装载的执行过程？</strong></h3>\n\n<p>类装载分为以下 5 个步骤：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>加载：根据查找路径找到相应的 class 文件然后导入；\n检查：检查加载的 class 文件的正确性；\n准备：给类中的静态变量分配内存空间；\n解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；\n初始化：对静态变量和静态代码块执行初始化工作。\n</code></pre>  </div></div>\n\n<h3 id=\"7-怎么判断对象是否可以被回收\"><strong>7. 怎么判断对象是否可以被回收？</strong></h3>\n\n<p>一般有两种方法来判断：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；\n可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。\n</code></pre>  </div></div>\n\n<h3 id=\"8-java-中都有哪些引用类型\"><strong>8. Java 中都有哪些引用类型？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>强引用：发生 gc 的时候不会被回收。\n软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。\n弱引用：有用但不是必须的对象，在下一次GC时会被回收。\n虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。\n</code></pre>  </div></div>\n\n<h3 id=\"9-说一下-jvm-有哪些垃圾回收算法\"><strong>9. 说一下 JVM 有哪些垃圾回收算法？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。\n标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。\n\n复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。\n\n分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。\n</code></pre>  </div></div>\n\n<h3 id=\"10-说一下-jvm-有哪些垃圾回收器\"><strong>10. 说一下 JVM 有哪些垃圾回收器？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Serial：最早的单线程串行垃圾回收器。\nSerial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。\nParNew：是 Serial 的多线程版本。\nParallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。\nParallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。\nCMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。\nG1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。\n</code></pre>  </div></div>\n\n<h3 id=\"11-详细介绍一下-cms-垃圾回收器\"><strong>11. 详细介绍一下 CMS 垃圾回收器？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。\n\nCMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。\n</code></pre>  </div></div>\n\n<h3 id=\"12-新生代垃圾回收器和老生代垃圾回收器都有哪些有什么区别\"><strong>12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>新生代回收器：Serial、ParNew、Parallel Scavenge\n老年代回收器：Serial Old、Parallel Old、CMS\n整堆回收器：G1\n</code></pre>  </div></div>\n\n<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>\n\n<h3 id=\"13-简述分代垃圾回收器是怎么工作的\"><strong>13. 简述分代垃圾回收器是怎么工作的？</strong></h3>\n\n<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>\n\n<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>把 Eden + From Survivor 存活的对象放入 To Survivor 区；\n清空 Eden 和 From Survivor 分区；\nFrom Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。\n</code></pre>  </div></div>\n\n<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>\n\n<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>\n\n<h3 id=\"14-说一下-jvm-调优的工具\"><strong>14. 说一下 JVM 调优的工具？</strong></h3>\n\n<p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jconsole：用于对 JVM 中的内存、线程和类等进行监控；\njvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。\n</code></pre>  </div></div>\n\n<h3 id=\"15-常用的-jvm-调优的参数都有哪些\"><strong>15. 常用的 JVM 调优的参数都有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-Xms2g：初始化推大小为 2g；\n-Xmx2g：堆最大内存为 2g；\n-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；\n-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；\n–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；\n-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；\n-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；\n-XX:+PrintGC：开启打印 gc 信息；\n-XX:+PrintGCDetails：打印 gc 详细信息。\n</code></pre>  </div></div>\n","dir":"/blog/development/interview/java/","name":"2023-04-23_4.md","path":"blog/development/interview/java/2023-04-23_4.md","url":"/blog/development/interview/java/2023-04-23_4.html"},{"sort":4,"permalink":"/blog/development/python/jottings/","layout":"default","title":"随笔","content":"<h1 id=\"随笔\">随笔</h1>\n\n","dir":"/blog/development/python/jottings/","name":"README.md","path":"blog/development/python/jottings/README.md","url":"/blog/development/python/jottings/"},{"sort":4,"permalink":"/blog/development/python/django/","layout":"default","title":"Django","content":"<h1 id=\"django\">Django</h1>\n\n<ul>\n <li><a href=\"/blog/development/python/django/2023-04-27_1.html\">Django中url与path及re_path区别</a></li>\n</ul>\n","dir":"/blog/development/python/django/","name":"README.md","path":"blog/development/python/django/README.md","url":"/blog/development/python/django/"},{"sort":4,"permalink":"/blog/development/python/","layout":"default","title":"Python笔记","content":"<h1 id=\"python笔记\">Python笔记</h1>\n\n<ul>\n <li><a href=\"/blog/development/python/jottings/\">随笔</a></li>\n <li><a href=\"/blog/development/python/django/\">Django</a>\n <ul>\n <li><a href=\"/blog/development/python/django/2023-04-27_1.html\">Django中url与path及re_path区别</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/python/","name":"README.md","path":"blog/development/python/README.md","url":"/blog/development/python/"},{"sort":4,"layout":"default","title":"Centos防火墙配置","content":"<h1 id=\"centos防火墙配置\">Centos防火墙配置</h1>\n\n<p><a href=\"https://justmyfreedom.com/\">Centos7.3防火墙配置</a></p>\n\n<h2 id=\"一常用设置\">一.常用设置</h2>\n\n<h3 id=\"1查看firewall服务状态\">1、查看firewall服务状态</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    systemctl status firewalld\n</code></pre>  </div></div>\n\n<h3 id=\"2查看firewall的状态\">2、查看firewall的状态</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    firewall-cmd --state\n</code></pre>  </div></div>\n\n<h3 id=\"3开启重启关闭\">3、开启、重启、关闭、</h3>\n<p>开启</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    service firewalld start 或 systemctl start firewalld\n</code></pre>  </div></div>\n\n<p>重启</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    service firewalld restart  或 systemctl restart firewalld\n</code></pre>  </div></div>\n\n<p>关闭</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>service firewalld stop  或 systemctl stop firewalld\n</code></pre>  </div></div>\n\n<h3 id=\"4查看防火墙规则\">4、查看防火墙规则</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    firewall-cmd --list-all\n</code></pre>  </div></div>\n\n<h3 id=\"5查询开放关闭端口\">5、查询、开放、关闭端口</h3>\n<h4 id=\"使用命令进行操作\">使用命令进行操作</h4>\n<p>查询端口是否开放</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    firewall-cmd --query-port=8080/tcp\n</code></pre>  </div></div>\n<p>查询所有开启端口</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    firewall-cmd --zone=public --list-ports\n</code></pre>  </div></div>\n\n<p>开放80端口</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    firewall-cmd --permanent --add-port=80/tcp --permanent\n</code></pre>  </div></div>\n\n<p>移除端口</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    firewall-cmd --permanent --remove-port=8080/tcp --permanent\n</code></pre>  </div></div>\n\n<p>重启防火墙(修改配置后要重启防火墙)</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    firewall-cmd --reload\n</code></pre>  </div></div>\n\n<p>参数解释</p>\n<blockquote>\n <p>1、firwall-cmd：是Linux提供的操作firewall的一个工具；\n2、–permanent：表示设置为持久；\n3、–add-port：标识添加的端口；</p>\n</blockquote>\n\n<h4 id=\"直接修改防火墙配置文件\">直接修改防火墙配置文件</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    /etc/firewalld/zones/public.xml\n</code></pre>  </div></div>\n\n<p>修改/etc/firewalld/zones/public.xml 保存后,运行:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    firewall-cmd --complete-reload\n</code></pre>  </div></div>\n\n<h2 id=\"二其他设置\">二.其他设置</h2>\n<p>查看防火墙规则（只显示/etc/firewalld/zones/public.xml中防火墙策略）</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    firewall-cmd --list-all\n</code></pre>  </div></div>\n<p>查看所有的防火墙策略（即显示/etc/firewalld/zones/下的所有策略）</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    firewall-cmd --list-all-zones\n</code></pre>  </div></div>\n\n<p>配置firewalld-cmd</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>查看版本：firewall-cmd --version\n查看帮助：firewall-cmd --help\n显示状态：firewall-cmd --state\n查看所有打开的端口：firewall-cmd --zone=public --list-ports\n更新防火墙规则：firewall-cmd --reload\n查看区域信息: firewall-cmd --get-active-zones\n查看指定接口所属区域：firewall-cmd --get-zone-of-interface=eth0\n拒绝所有包：firewall-cmd --panic-on\n取消拒绝状态：firewall-cmd --panic-off\n查看是否拒绝：firewall-cmd --query-panic\n</code></pre>  </div></div>\n\n<p>systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>启动一个服务：systemctl start firewalld.service\n关闭一个服务：systemctl stop firewalld.service\n重启一个服务：systemctl restart firewalld.service\n显示一个服务的状态：systemctl status firewalld.service\n在开机时启用一个服务：systemctl enable firewalld.service\n在开机时禁用一个服务：systemctl disable firewalld.service\n查看服务是否开机启动：systemctl is-enabled firewalld.service\n查看已启动的服务列表：systemctl list-unit-files|grep enabled\n查看启动失败的服务列表：systemctl --failed\n</code></pre>  </div></div>\n","dir":"/blog/development/os/linux/","name":"2023-05-17_1.md","path":"blog/development/os/linux/2023-05-17_1.md","url":"/blog/development/os/linux/2023-05-17_1.html"},{"sort":4,"layout":"default","title":"laydate渲染日期","content":"<h1 id=\"laydate渲染日期\">laydate渲染日期</h1>\n\n<h2 id=\"一-laydate渲染开始日期结束日期并限制选择\">一. laydate渲染开始日期结束日期并限制选择</h2>\n\n<h3 id=\"1-html页面日期组件\">1. html页面日期组件：</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;div class=\"layui-inline\"&gt;\n   &lt;label class=\"layui-form-label\"&gt;开始日期：&lt;span\n           class=\"layui-font-red\"&gt;*&lt;/span&gt;：&lt;/label&gt;\n   &lt;div class=\"layui-input-inline\" id=\"bData1\"&gt;\n       &lt;input type=\"text\" name=\"bDate\" id=\"bDate\" lay-verify=\"date|required\"\n              placeholder=\"yyyy-MM-dd\" autocomplete=\"off\" class=\"layui-input\"&gt;\n   &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"layui-inline\"&gt;\n   &lt;label class=\"layui-form-label\"&gt;结束日期：&lt;span\n           class=\"layui-font-red\"&gt;*&lt;/span&gt;：&lt;/label&gt;\n   &lt;div class=\"layui-input-inline\" id=\"eData1\"&gt;\n       &lt;input type=\"text\" name=\"eDate\" id=\"eDate\" lay-verify=\"date|required\"\n              placeholder=\"yyyy-MM-dd\" autocomplete=\"off\" class=\"layui-input\"&gt;\n   &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>  </div></div>\n\n<h3 id=\"2-js渲染\">2. js渲染</h3>\n<h4 id=\"21-方法一\">2.1 方法一：</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>//获取当前年份\nvar nowDateYear = new Date().getFullYear();\nvar minDate = nowDateYear + '-01-01';\nvar maxDate = nowDateYear + '-12-31';\n \nvar startDate=laydate.render({\n\telem: '#bDate'\n\t,min: minDate\n\t,max: maxDate\n\t, done: function (value, dates) {\n\t      endDate.config.min = {\n\t          year: dates.year,\n\t          month: dates.month - 1, //关键\n\t          date: dates.date,\n\t          hours: 0,\n\t          minutes: 0,\n\t          seconds: 0\n\t      }\n\t   }\n\t});\n\nvar endDate=laydate.render({\n      elem: '#eDate'\n      ,min: minDate\n      ,max: maxDate\n     ,done: function (value, dates) {\n         startDate.config.max={\n             year:dates.year,\n             month:dates.month-1,//关键\n             date: dates.date,\n             hours: 0,\n             minutes: 0,\n             seconds : 0\n         }\n     }\n  });\n</code></pre>  </div></div>\n\n<h4 id=\"22-方法二\">2.2 方法二：</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>var beginDay = editPreBill.bDate || ''; //默认值\nvar endDay = editPreBill.eDate || '';   //默认值\n//开始\nwriteBdate('bData', beginDay, endDay);\n//结束\nwriteEdate('eData', endDay, beginDay);\n\n//渲染开始日期\nfunction writeBdate(elem1, value1, value2) {\n    laydate.render({\n        elem: '#' + elem1\n        , value: value1//初始值\n        , max: value2 == '' ? 4073558400000 : value2\n        , done: function (value, date, endDate) {\n            beginDay = value;\n//重新结束渲染\n            $(\"#eData\").remove();\n            $(\"#eData1\").html(' &lt;input type=\"text\" name=\"eDate\" id=\"eData\" lay-verify=\"date\" placeholder=\"yyyy-MM-dd\" autocomplete=\"off\" class=\"layui-input\"&gt;');\n            writeEdate(\"eData\", value2, beginDay);\n        }\n    });\n}\n\nfunction writeEdate(elem1, value1, value2) {\n    laydate.render({\n        elem: '#' + elem1\n        , value: value1//初始值\n        , min: value2 == '' ? -4073558400000 : value2\n        , done: function (value, date, endDate) {\n            endDay = value;\n//重新渲染\n            $(\"#bData\").remove();\n            $(\"#bData1\").html(' &lt;input type=\"text\" name=\"bDate\" id=\"bData\" lay-verify=\"date\" placeholder=\"yyyy-MM-dd\" autocomplete=\"off\" class=\"layui-input\"&gt;');\n            writeBdate(\"bData\", value2, endDay);\n        }\n    });\n}\n</code></pre>  </div></div>\n\n<h2 id=\"二-laydaterender常见问题\">二. laydate.render常见问题</h2>\n\n<h3 id=\"1-多次渲染的问题\">1. 多次渲染的问题</h3>\n\n<p>layui的laydate.render()多次渲染的问题</p>\n\n<p><strong>描述：根据“上午”、“下午”的不同选择，限制可选时间的组件显示不同内容</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;div className=\"main-head\"&gt;\n    &lt;p&gt;&lt;span&gt;在线预定&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;div className=\"main-reserve\"&gt;\n    &lt;form action=\"#\" method=\"post\" id=\"food-reserve\" className=\"layui-form\"&gt;\n        &lt;ul&gt;\n            &lt;li&gt;\n                &lt;div className=\"layui-inline\"&gt;\n                    &lt;div className=\"layui-input-inline\"&gt;\n                        &lt;select name=\"modules\" lay-verify=\"required\" onChange=\"selectFood()\" lay-search=\"\"&gt;\n                            &lt;option value=\"0\" selected&gt;请选择时间范围&lt;/option&gt;\n                            &lt;option value=\"1\"&gt;上午&lt;/option&gt;\n                            &lt;option value=\"2\"&gt;下午&lt;/option&gt;\n                        &lt;/select&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/li&gt;\n\n            &lt;li&gt;\n                &lt;label className=\"layui-form-label\"&gt;时间&lt;/label&gt;\n                &lt;div className=\"layui-input-inline\" id=\"timeInput\"&gt;\n                    &lt;input type=\"text\" className=\"layui-input\" id=\"test-limit3\" name=\"time\" autoComplete=\"off\"&gt;\n                &lt;/div&gt;\n            &lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;div className=\"layui-form-item\"&gt;\n            &lt;div className=\"layui-input-block\"&gt;\n                &lt;button className=\"layui-btn\" lay-submit=\"\" lay-filter=\"demo1\"&gt;立即提交&lt;/button&gt;\n                &lt;button type=\"reset\" className=\"layui-btn layui-btn-primary\"&gt;重置&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n    &lt;/form&gt;\n&lt;/div&gt;\n    \n</code></pre>  </div></div>\n\n<p><strong>laydate.render()只会渲染一次，若要多次渲染，可以移除元素，重新加载</strong></p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>var form;\nlayui.use(['laydate', 'form'], function () {\n    var laydate = layui.laydate;\n    form = layui.form; //只有执行了这一步，部分表单元素才会自动修饰成功\n\n    form.on('select', function (data) {\n        //获取被选中的option标签\n        var flag = data.value;\n        if (flag == 1) {\n            /* 移除元素，重新加载 */\n            $(\"#test-limit3\").remove();\n            $(\"#timeInput\").html('&lt;input type=\"text\" class=\"layui-input\" id=\"test-limit3\" name=\"time\" autocomplete=\"off\"&gt;');\n            //限定可选时间\n            laydate.render({\n                elem: '#test-limit3'\n                , type: 'time'\n                , min: '10:30:00'\n                , max: '12:00:00'\n                , btns: ['clear', 'confirm']\n            });\n        } else if (flag == 2) {\n            $(\"#test-limit3\").remove();\n            $(\"#timeInput\").html('&lt;input type=\"text\" class=\"layui-input\" id=\"test-limit3\" name=\"time\" autocomplete=\"off\"&gt;');\n            //限定可选时间\n            laydate.render({\n                elem: '#test-limit3'\n                , type: 'time'\n                , min: '14:00:00'\n                , max: '22:00:00'\n                , btns: ['clear', 'confirm']\n            });\n        } else {\n            alert(\"请选择时间范围\");\n        }\n    })；\n});\n</code></pre>  </div></div>\n","dir":"/blog/development/html/jottings/","name":"2023-05-12_2.md","path":"blog/development/html/jottings/2023-05-12_2.md","url":"/blog/development/html/jottings/2023-05-12_2.html"},{"sort":4,"layout":"default","title":"Restful风格开发方式","content":"<h1 id=\"restful风格开发方式\">Restful风格开发方式</h1>\n\n<h2 id=\"一概念\">一.概念</h2>\n\n<p>一种软件架构风格、设计风格，而<strong>不是</strong>标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>\n\n<h3 id=\"1url定义\">1.URL定义</h3>\n\n<p>资源：互联网所有的事物都可以被抽象为资源 <br />\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 <br />\n分别对应 添加、 删除、修改、查询。 </p>\n\n<h3 id=\"2传统方式操作资源\">2.传统方式操作资源 </h3>\n<p><a href=\"http://127.0.0.1/item/queryItem.action?id=1\">http://127.0.0.1/item/queryUser.action?id=1</a>   查询,GET <br />\n<a href=\"http://127.0.0.1/item/saveItem.action\">http://127.0.0.1/item/save</a><a href=\"http://127.0.0.1/item/queryItem.action?id=1\">User</a><a href=\"http://127.0.0.1/item/saveItem.action\">.action</a>             新增,POST <br />\n<a href=\"http://127.0.0.1/item/updateItem.action\">http://127.0.0.1/item/update</a><a href=\"http://127.0.0.1/item/queryItem.action?id=1\">User</a><a href=\"http://127.0.0.1/item/updateItem.action\">.action</a>          更新,POST <br />\n<a href=\"http://127.0.0.1/item/deleteItem.action?id=1\">http://127.0.0.1/item/delete</a><a href=\"http://127.0.0.1/item/queryItem.action?id=1\">User</a><a href=\"http://127.0.0.1/item/deleteItem.action?id=1\">.action?id=1</a>  删除,GET或POST</p>\n\n<h3 id=\"3请求方式\">3.请求方式</h3>\n\n<p>可以通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。其中，GET 用于查询资源，POST 用于创建资源，PUT 用于更新服务端的资源的全部信息，PATCH 用于更新服务端的资源的部分信息，DELETE 用于删除服务端的资源。</p>\n\n<p>这里使用“用户”的案例进行回顾通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。</p>\n\n<h2 id=\"二使用restful操作资源\">二.使用RESTful操作资源 </h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>【GET】 /users # 查询用户信息列表`\n\n【GET】 /users/1001 # 查看某个用户信息`\n\n【POST】 /users # 新建用户信息`\n\n【PUT】 /users/1001 # 更新用户信息(全部字段)`\n\n【PATCH】 /users/1001 # 更新用户信息(部分字段)`\n\n【DELETE】 /users/1001 # 删除用户信息`\n</code></pre>  </div></div>\n\n<p><strong>之前的操作是没有问题的,大神认为是有问题的,有什么问题呢?你每次请求的接口或者地址,都在做描述,例如查询的时候用了</strong>queryUser<strong>,新增的时候用了</strong>saveUser<strong> ，修改</strong>的时候用了<strong>updateUser</strong>,其实完全没有这个必要,我使用了get请求,就是查询.使用post请求,就是新增的请求,PUT就是修改，delete就是删除，我的意图很明显,完全没有必要做描述,这就是为什么有了restful.**</p>\n\n<h2 id=\"三api设计风格基本规则\">三.API设计风格基本规则</h2>\n\n<h3 id=\"1使用名词而不是动词\">1.使用名词而不是动词</h3>\n\n<p>不要使用：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/getAllUsers  \n/createNewUser  \n/deleteAllUser\n</code></pre>  </div></div>\n\n<h3 id=\"2get方法和查询参数不应该涉及状态改变\">2.Get方法和查询参数不应该涉及状态改变</h3>\n\n<p>使用<strong>PUT, POST</strong> 和<strong>DELETE</strong> 方法 而不是<strong> GET</strong> 方法来改变状态，不要使用<strong>GET</strong> 进行状态改变:</p>\n\n<h3 id=\"3使用复数名词\">3.使用复数名词</h3>\n\n<p>不要混淆名词单数和复数，为了保持简单，只对所有资源使用复数。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/cars 而不是 /car  \n/users 而不是 /user  \n/products 而不是 /product  \n/settings 而部署 /setting\n</code></pre>  </div></div>\n\n<h3 id=\"4-使用子资源表达关系\">4. 使用子资源表达关系</h3>\n\n<p>如果一个资源与另外一个资源有关系，使用子资源：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GET /cars/711/drivers/ 返回 car 711的所有司机  \nGET /cars/711/drivers/4 返回 car 711的4号司机\n</code></pre>  </div></div>\n\n<h3 id=\"5使用http头声明序列化格式\">5.使用Http头声明序列化格式</h3>\n\n<p>在客户端和服务端，双方都要知道通讯的格式，格式在HTTP-Header中指定</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Content-Type 定义请求格式  \nAccept 定义系列可接受的响应格式\n</code></pre>  </div></div>\n\n<h3 id=\"6为集合提供过滤-排序-选择和分页等功能\">6.为集合提供<strong>过滤 排序 选择和分页等功能</strong></h3>\n\n<p><strong>Filtering过滤</strong>:</p>\n\n<p>使用唯一的查询参数进行过滤：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GET /cars?color=red 返回红色的cars  \nGET /cars?seats&lt;=2 返回小于两座位的cars集合\n</code></pre>  </div></div>\n\n<p><strong>Sorting</strong>排序:</p>\n\n<p>允许针对多个字段排序</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GET /cars?sort=-manufactorer,+model\n</code></pre>  </div></div>\n\n<p>这是返回根据生产者降序和模型升序排列的car集合</p>\n\n<p><strong>Field selection</strong></p>\n\n<p>移动端能够显示其中一些字段，它们其实不需要一个资源的所有字段，给API消费者一个选择字段的能力，这会降低网络流量，提高API可用性。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GET /cars?fields=manufacturer,model,id,color\n</code></pre>  </div></div>\n\n<p><strong>Paging分页</strong></p>\n\n<p>使用 limit 和offset.实现分页，缺省limit=20 和offset=0；</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GET /cars?offset=10&amp;limit=5\n</code></pre>  </div></div>\n\n<p>为了将总数发给客户端，使用订制的HTTP头： X-Total-Count.</p>\n\n<p>链接到下一页或上一页可以在HTTP头的link规定，遵循Link规定:</p>\n\n<p>Link: <a href=\"https://justmyfreedom.com/blog/frontier/new/technology/2023-04-23_1.html\">https://justmyfreedom.com/blog/frontier/new/technology/2023-04-23_1.html</a>; rel=”next”,<br />\n<a href=\"https://justmyfreedom.com/blog/development/interview/java/2023-04-23_1.html\">https://justmyfreedom.com/blog/development/interview/java/2023-04-23_1.html</a>; rel=”last”,<br />\n<a href=\"https://justmyfreedom.com/blog/development/interview/java/2023-04-23_4.html\">https://justmyfreedom.com/blog/development/interview/java/2023-04-23_4.html</a>; rel=”first”,<br />\n<a href=\"https://justmyfreedom.com/blog/development/html/jottings/2023-04-21_1.html\">https://justmyfreedom.com/blog/development/html/jottings/2023-04-21_1.html</a>; rel=”prev”,</p>\n\n<h3 id=\"7版本化你的api\">7.版本化你的API</h3>\n\n<p>使得API版本变得强制性，不要发布无版本的API，使用简单数字，避免小数点如2.5.</p>\n\n<p>一般在Url后面使用?v</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/blog/api/v1\n</code></pre>  </div></div>\n\n<h3 id=\"8-使用http状态码处理错误\">8. 使用Http状态码处理错误</h3>\n\n<p>如果你的API没有错误处理是很难的，只是返回500和出错堆栈不一定有用</p>\n\n<p>Http状态码提供70个出错，我们只要使用10个左右：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>200 – OK – 一切正常  \n201 – OK – 新的资源已经成功创建  \n204 – OK – 资源已经成功擅长\n\n304 – Not Modified – 客户端使用缓存数据\n\n400 – Bad Request – 请求无效，需要附加细节解释如 \"JSON无效\"  \n401 – Unauthorized – 请求需要用户验证  \n403 – Forbidden – 服务器已经理解了请求，但是拒绝服务或这种请求的访问是不允许的。  \n404 – Not found – 没有发现该资源  \n422 – Unprocessable Entity – 只有服务器不能处理实体时使用，比如图像不能被格式化，或者重要字段丢失。\n\n500 – Internal Server Error – API开发者应该避免这种错误。\n</code></pre>  </div></div>\n\n<p>使用详细的错误包装错误：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>{\n\n  \"errors\": \\[\n\n   {\n\n    \"userMessage\": \"Sorry, the requested resource does not exist\",\n\n    \"internalMessage\": \"No car found in the database\",\n\n    \"code\": 34,\n\n    \"more info\": \"http://dev.mwaysolutions.com/blog/api/v1/errors/12345\"\n\n   }\n\n  \\]\n\n}\n</code></pre>  </div></div>\n\n<h3 id=\"9允许覆盖http方法\">9.允许覆盖http方法</h3>\n\n<p>一些代理只支持<strong>POST</strong> 和 <strong>GET方法，</strong> 为了使用这些有限方法支持RESTful API，需要一种办法覆盖http原来的方法。</p>\n\n<p>使用订制的HTTP头 <strong>X-HTTP-Method-Override</strong> 来覆盖POST 方法.</p>\n\n<p>总而言之restful是一种旧技术新风格</p>\n","dir":"/blog/development/java/jottings/","name":"2023-05-12_1.md","path":"blog/development/java/jottings/2023-05-12_1.md","url":"/blog/development/java/jottings/2023-05-12_1.html"},{"sort":4,"permalink":"/blog/ancientBooks/","layout":"default","title":"典籍","content":"<h1 id=\"典籍\">典籍</h1>\n\n<ul>\n <li><a href=\"/blog/ancientBooks/shiJing/\">诗经</a></li>\n <li><a href=\"/blog/ancientBooks/tangShi/\">唐诗</a></li>\n</ul>\n","dir":"/blog/ancientBooks/","name":"README.md","path":"blog/ancientBooks/README.md","url":"/blog/ancientBooks/"},{"sort":4,"layout":"default","title":"Spring 开发Web应用","content":"<h1 id=\"spring-开发web应用\">Spring 开发Web应用</h1>\n","dir":"/blog/development/java/framework/spring/","name":"2023-05-18_4.md","path":"blog/development/java/framework/spring/2023-05-18_4.md","url":"/blog/development/java/framework/spring/2023-05-18_4.html"},{"sort":5,"layout":"default","title":"Html中CSS和JavaScript 文件添加版本号有哪些方式","content":"<h1 id=\"html中css和javascript-文件添加版本号有哪些方式\">Html中CSS和JavaScript 文件添加版本号有哪些方式</h1>\n\n<p>为 CSS 和 JavaScript 文件添加版本号可以有效避免浏览器缓存文件，以确保用户在更新网站文件后能够正确地加载最新的版本。以下是一些为 CSS 和 JavaScript 文件添加版本号的方式：</p>\n\n<h2 id=\"一-时间戳\">一. 时间戳</h2>\n\n<p>使用时间戳是一种简单而有效的方式。可以使用当前时间戳作为文件的版本号，例如：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;link rel=\"stylesheet\" href=\"/css/styles.css?ver=1620856587\" /&gt;\n&lt;script src=\"/js/scripts.js?ver=1620856587\"&gt;&lt;/script&gt;\n</code></pre>  </div></div>\n<p>每次更新文件时，只需要将版本号更新为当前时间戳即可。</p>\n\n<h3 id=\"1-jekyll中使用时间戳\">1. Jekyll中使用时间戳</h3>\n<p>可以使用 Liquid 标签来获取文件的最后修改时间，例如：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;link rel=\"stylesheet\" href=\"/css/style.css?1684748445\"&gt;\n&lt;script src=\"/js/script.js?1684748445\"&gt;&lt;/script&gt;\n</code></pre>  </div></div>\n<p>这样，在生成的 HTML 中，文件的 URL 就会带上一个形如 ?1619776226 的时间戳参数。</p>\n\n<h2 id=\"二-md5hash\">二. MD5Hash</h2>\n\n<p>使用文件内容的 MD5 哈希值作为文件版本号。可以使用文件内容的 MD5 哈希值作为版本号，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;link rel=\"stylesheet\" href=\"/css/styles.css?ver=dc6b3d43b3e03c07e18e45ec6a1c029d\" /&gt;\n&lt;script src=\"/js/scripts.js?ver=9d0e7a71c9eb8f7c15aeb6b1d6c93a6d\"&gt;&lt;/script&gt;\n</code></pre>  </div></div>\n\n<p>每次更新文件时，需要计算文件内容的 MD5 哈希值，并将其用作版本号。</p>\n\n<h3 id=\"1-jekyll中使用md5hash\">1. Jekyll中使用MD5Hash</h3>\n\n<p>可以使用 Liquid 标签结合 Jekyll 自带的 md5 过滤器来获取文件内容的哈希值，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;link rel=\"stylesheet\" href=\"/css/style./css/style.css.css\"&gt;\n&lt;script src=\"/js/script./js/script.js.js\"&gt;&lt;/script&gt;\n</code></pre>  </div></div>\n\n<p>这样，在生成的 HTML 中，文件的 URL 就会带上一个形如 .5d41402abc4b2a76b9719d911017c592.css 的哈希值后缀。</p>\n\n<p>需要注意的是，如果使用此种方法，修改了 CSS 或 JavaScript 文件后，需要手动更新 HTML 中的文件引用，否则文件名不会改变，浏览器就会使用缓存中的旧文件。</p>\n\n<h2 id=\"三-自动化工具\">三. 自动化工具</h2>\n\n<p>可以使用一些自动化工具来为 CSS 和 JavaScript 文件添加版本号，例如 webpack 和 gulp。这些工具可以自动计算文件的版本号并将其添加到文件名中。例如，webpack 中可以使用 [contenthash] 占位符来为文件生成唯一的版本号，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;link rel=\"stylesheet\" href=\"/css/styles.239r92r23923r.css\" /&gt;\n&lt;script src=\"/js/scripts.239r92r23923r.js\"&gt;&lt;/script&gt;\n</code></pre>  </div></div>\n\n<p>每次更新文件时，webpack 将自动计算文件的内容哈希值，并将其添加到文件名中。这样可以确保每个文件都有唯一的版本号。</p>\n\n","dir":"/blog/development/html/jottings/","name":"2023-05-17_1.md","path":"blog/development/html/jottings/2023-05-17_1.md","url":"/blog/development/html/jottings/2023-05-17_1.html"},{"sort":5,"layout":"default","title":"Spring 集成第三方组件","content":"<h1 id=\"spring-集成第三方组件\">Spring 集成第三方组件</h1>\n","dir":"/blog/development/java/framework/spring/","name":"2023-05-18_5.md","path":"blog/development/java/framework/spring/2023-05-18_5.md","url":"/blog/development/java/framework/spring/2023-05-18_5.html"},{"sort":5,"permalink":"/blog/development/java/framework/","layout":"default","title":"Java框架","content":"<h1 id=\"java框架\">Java框架</h1>\n\n<ul>\n <li><a href=\"/blog/development/java/framework/spring/\">Spring Framework</a>\n <ul>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_1.html\">Spring IOC 容器</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_2.html\">Spring AOP使用</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_3.html\">Spring 访问数据库</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_4.html\">Spring 开发Web应用</a></li>\n <li><a href=\"/blog/development/java/framework/spring/2023-05-18_5.html\">Spring 集成第三方组件</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/java/framework/","name":"README.md","path":"blog/development/java/framework/README.md","url":"/blog/development/java/framework/"},{"sort":5,"permalink":"/blog/religion/","layout":"default","title":"宗教","content":"<h1 id=\"宗教\">宗教</h1>\n\n<p>source: <code class=\"language-plaintext highlighter-rouge\">blog/religion/README.md</code></p>\n","dir":"/blog/religion/","name":"README.md","path":"blog/religion/README.md","url":"/blog/religion/"},{"sort":5,"layout":"default","title":"Java8 新特性全面介绍","content":"<h1 id=\"java8-新特性全面介绍\">Java8 新特性全面介绍</h1>\n\n<p>Java 8 已经发布很久了，很多报道表明 Java 8 是一次重大的版本升级，虽然我们的 JDK 环境也升级到1.8，但是在日常的开发过程中，使用最多的编程风格还是停留在 JDK1.7。</p>\n\n<h2 id=\"一介绍\">一、介绍</h2>\n\n<p>Java 8 已经发布很久了，很多报道表明 Java 8 是一次重大的版本升级，虽然我们的 JDK 环境也升级到1.8，但是在日常的开发过程中，使用最多的编程风格还是停留在 JDK1.7。</p>\n\n<p>Java8 新增了非常多的特性，主要有以下几个：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. Lambda 表达式：Lambda表达式是Java 8中最重要的特性之一。它提供了一种简洁而灵活的方式来编写匿名函数。Lambda表达式可以作为参数传递给方法或存储在变量中，并可以替代使用匿名内部类的方式。\n2. 函数式接口：函数式接口是指只包含一个抽象方法的接口。Java 8引入了一些新的函数式接口，例如Predicate、Consumer、Supplier、Function等，这些接口可以用Lambda表达式来实现。\n3. 方法引用：方法引用提供了非常有用的语法，可以直接引用已有Java类或对象(实例)的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码\n4. 默认方法：Java 8允许在接口中定义默认方法，即具有默认实现的方法。这样可以使得接口的修改更加灵活，不会破坏已有的实现。\n5. Stream API：Stream API提供了一种功能强大的处理集合数据的方式。它可以通过一系列的中间操作和终端操作来对集合进行过滤、映射、排序、聚合等操作，使得代码更加简洁、可读性更强。\n6. Optional 类：Optional类是一种容器对象，可以用来表示一个值存在或不存在。它可以避免空指针异常，并提供了一些便捷的方法来处理可能为空的值。\n7. Date Time API：Java 8引入了java.time包，提供了一套全新的日期和时间API。它提供了更好的可读性和易用性，并且支持更多的操作，例如日期的解析格式化、时区处理、日期计算等。\n8. Nashorn, JavaScript 引擎：Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用\n</code></pre>  </div></div>\n\n<p>除了上述主要特性外，Java 8还包含了其他一些改进，例如重复注解、类型注解、改进的类型推断、新的IO和NIO API等。这些新特性使得Java 8成为了一个更现代化、更强大的编程语言。</p>\n\n<p>话不多说，直接上代码!</p>\n\n<h2 id=\"二-常用功能\">二. 常用功能</h2>\n\n<h3 id=\"一-lambda-表达式\">(一). Lambda 表达式</h3>\n\n<p>Lambda表达式是Java 8引入的一种新的语法特性，它提供了一种简洁而灵活的方式来编写匿名函数。</p>\n\n<h4 id=\"1-基础介绍\">1. 基础介绍</h4>\n<p>Lambda表达式的语法形式如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>(parameters) -&gt; expression\n或\n(parameters) -&gt; { statements; }\n</code></pre>  </div></div>\n\n<p>其中，parameters指定了Lambda表达式的参数列表，可以包含零个或多个参数。参数列表可以省略类型，编译器会根据上下文进行类型推断。</p>\n\n<p>-&gt;是Lambda运算符，将参数列表与Lambda表达式的主体分隔开来。</p>\n\n<p>expression是单个表达式，可以是一个返回值的计算或一个方法调用。如果Lambda表达式只有一条表达式，可以省略花括号{}和return关键字。</p>\n\n<p>{ statements; }是一系列语句的块，可以包含多条语句，并可以有返回值。</p>\n\n<p>Lambda表达式可以用于函数式接口的实现，函数式接口是指只包含一个抽象方法的接口。Lambda表达式可以与函数式接口相匹配，用于提供该接口的实现。</p>\n\n<p>例如，下面是一个使用Lambda表达式的例子：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n// 使用Lambda表达式对集合进行遍历和打印\nnames.forEach(name -&gt; System.out.println(name));\n\n// 使用Lambda表达式对集合进行过滤\nList&lt;String&gt; filteredNames = names.stream()\n                                  .filter(name -&gt; name.length() &gt; 4)\n                                  .collect(Collectors.toList());\n</code></pre>  </div></div>\n<p>Lambda表达式可以简化代码，使代码更加紧凑和可读。它提供了一种简单而强大的方式来处理函数式编程的需求，例如在集合处理、事件处理、多线程等方面的应用广泛。</p>\n\n<h4 id=\"2-lambda编程风格分类\">2. Lambda编程风格分类</h4>\n\n<h5 id=\"21-可选类型声明\">2.1 可选类型声明</h5>\n<p>不需要声明参数类型，编译器可以统一识别参数值</p>\n\n<p>在使用过程中，我们可以不用显示声明参数类型，编译器可以统一识别参数类型，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Collections.sort(names, (s1, s2) -&gt; s1.compareTo(s2)); \n</code></pre>  </div></div>\n<p>上面代码中的参数s1、s2的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Collections.sort(names, (String s1, String s2) -&gt; s1.compareTo(s2)); \n</code></pre>  </div></div>\n<p>运行之后，两者结果一致!</p>\n\n<h5 id=\"22-可选的参数圆括号\">2.2 可选的参数圆括号</h5>\n<p>当方法那只有一个参数时，无需定义圆括号，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Arrays.asList( \"a\", \"b\", \"d\" ).forEach( e -&gt; System.out.println( e ) ); \n</code></pre>  </div></div>\n<p>但多个参数时，需要定义圆括号，例如：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Arrays.asList( \"a\", \"b\", \"d\" ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );\n</code></pre>  </div></div>\n<h5 id=\"23-可选的大括号\">2.3 可选的大括号</h5>\n<p>当主体只包含了一行时，无需使用大括号，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Arrays.asList( \"a\", \"b\", \"c\" ).forEach( e -&gt; System.out.println( e ) ); \n</code></pre>  </div></div>\n<p>当主体包含多行时，需要使用大括号，例如：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Arrays.asList( \"a\", \"b\", \"c\" ).forEach( e -&gt; { \n    System.out.println( e ); \n    System.out.println( e ); \n} );\n</code></pre>  </div></div>\n<h5 id=\"24-可选的返回关键字\">2.4 可选的返回关键字</h5>\n<p>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值\n如果表达式中的语句块只有一行，则可以不用使用return语句，返回值的类型也由编译器推理得出，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Arrays.asList( \"a\", \"b\", \"d\" ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) ); \n</code></pre>  </div></div>\n<p>如果语句块有多行，可以在大括号中指明表达式返回值，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Arrays.asList( \"a\", \"b\", \"d\" ).sort( ( e1, e2 ) -&gt; { \n    int result = e1.compareTo( e2 ); \n    return result; \n} );\n</code></pre>  </div></div>\n<p> </p>\n<h5 id=\"25-变量作用域\">2.5 变量作用域</h5>\n\n<p>还有一点需要了解的是，Lambda 表达式可以引用类成员和局部变量，但是会将这些变量隐式得转换成final，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>String separator = \",\"; \nArrays.asList( \"a\", \"b\", \"c\" ).forEach( \n    ( String e ) -&gt; System.out.print( e + separator ) ); \n</code></pre>  </div></div>\n<p>和</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>final String separator = \",\"; \nArrays.asList( \"a\", \"b\", \"c\" ).forEach( \n    ( String e ) -&gt; System.out.print( e + separator ) ); \n</code></pre>  </div></div>\n<p>两者等价!</p>\n\n<p>同时，Lambda 表达式的局部变量可以不用声明为final，但是必须不可被后面的代码修改(即隐性的具有 final 的语义)，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>int num = 1; \nArrays.asList(1,2,3,4).forEach(e -&gt; System.out.println(num + e)); \nnum =2; \n//报错信息：Local variable num defined in an enclosing scope must be final or effectively final \n</code></pre>  </div></div>\n\n<p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量，例如：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>int num = 1; \nArrays.asList(1,2,3,4).forEach(num -&gt; System.out.println(num)); \n//报错信息：Variable 'num' is already defined in the scope \n</code></pre>  </div></div>\n\n<h4 id=\"3-lambda编程使用分类\">3. Lambda编程使用分类</h4>\n\n<p><strong>遍历和过滤：</strong>Lambda表达式可以用于集合的遍历和过滤操作，使用函数式接口如Consumer、Predicate等。这种风格的Lambda表达式常见于使用Stream API进行集合操作。</p>\n\n<p><strong>映射和转换：</strong>Lambda表达式可以用于集合的映射和转换操作，使用函数式接口如Function、UnaryOperator等。这种风格的Lambda表达式常见于使用Stream API进行数据转换和处理。</p>\n\n<p><strong>排序和比较：</strong>Lambda表达式可以用于集合的排序和比较操作，使用函数式接口如Comparator等。这种风格的Lambda表达式常见于使用Collections.sort()等排序方法或使用Stream API进行排序操作。</p>\n\n<p><strong>链式调用和组合：</strong>Lambda表达式可以通过链式调用和组合实现复杂的操作流程，例如使用Stream API的filter()、map()、reduce()等方法，以及使用函数式接口的andThen()、compose()等方法。</p>\n\n<p><strong>并行处理：</strong>Lambda表达式可以通过Stream API的并行处理特性实现并行计算，提高程序的性能。这种风格的Lambda表达式常见于对大数据集或耗时操作进行并行处理。</p>\n\n<p>总体而言，Lambda编程风格强调使用简洁、灵活的Lambda表达式来实现函数式编程的各种操作。它能够减少样板代码、提高代码可读性，并且使得代码更加模块化和易于维护。Lambda表达式的引入使得Java的编程范式更加多样化，并且使得函数式编程成为Java开发中的一种重要编程风格。</p>\n\n<h3 id=\"二-函数式接口\">(二). 函数式接口</h3>\n\n<p>Java 8提供了java.util.function包，其中定义了一些常用的函数式接口，用于支持函数式编程的需求。</p>\n\n<p>函数接口指的是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口，这样的接口可以隐式转换为 Lambda 表达式。</p>\n\n<p>以下是一些常用的函数式接口：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Supplier&lt;T&gt;：无参数，返回一个结果。对应的方法是T get()。\nConsumer&lt;T&gt;：接受一个参数，无返回值。对应的方法是void accept(T t)。\nPredicate&lt;T&gt;：接受一个参数，返回一个布尔值。对应的方法是boolean test(T t)。\nFunction&lt;T, R&gt;：接受一个参数，返回一个结果。对应的方法是R apply(T t)。\nUnaryOperator&lt;T&gt;：接受一个参数，返回与参数类型相同的结果。对应的方法是T apply(T t)。\nBinaryOperator&lt;T&gt;：接受两个参数，返回一个结果，且参数和结果类型相同。对应的方法是T apply(T t1, T t2)。\n</code></pre>  </div></div>\n\n<p>除了以上几个常用的函数式接口，还有一些其他的函数式接口，如BiFunction、BiConsumer、BiPredicate等，用于支持多个参数的场景。</p>\n\n<p>函数式接口可以使用Lambda表达式或方法引用来创建实例。例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// 使用Lambda表达式创建Supplier接口的实例\nSupplier&lt;String&gt; supplier = () -&gt; \"Hello\";\n\n// 使用方法引用创建Consumer接口的实例\nConsumer&lt;String&gt; consumer = System.out::println;\n\n// 使用Lambda表达式创建Predicate接口的实例\nPredicate&lt;Integer&gt; predicate = n -&gt; n &gt; 0;\n\n// 使用Lambda表达式创建Function接口的实例\nFunction&lt;Integer, String&gt; function = n -&gt; Integer.toString(n);\n\n// 使用Lambda表达式创建UnaryOperator接口的实例\nUnaryOperator&lt;Integer&gt; operator = n -&gt; n * 2;\n\n// 使用Lambda表达式创建BinaryOperator接口的实例\nBinaryOperator&lt;Integer&gt; binaryOperator = (a, b) -&gt; a + b;\n</code></pre>  </div></div>\n<p>函数式接口在函数式编程和Lambda表达式的使用中发挥重要作用。它们提供了一种简洁而灵活的方式来实现函数的传递和组合，使得代码更加简洁和可读。</p>\n\n<h3 id=\"三-方法引用\">(三). 方法引用</h3>\n<p>Java 8引入了方法引用（Method References）的概念，它允许直接通过方法的名称来引用现有的方法。方法引用提供了一种更简洁和易读的方式来传递方法作为参数或在函数式接口中使用。</p>\n\n<p>方法引用可以看作是Lambda表达式的一种简化形式，它可以替代Lambda表达式的情况，即当Lambda表达式仅仅是调用一个已经存在的方法时。</p>\n\n<p>在Java 8中，方法引用可以分为以下几种形式：</p>\n<h4 id=\"1-静态方法引用\">1. 静态方法引用</h4>\n<p>引用静态方法，语法为类名::静态方法名。例如，Math::max表示引用Math类的max方法。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// 静态方法引用\nFunction&lt;Integer, Double&gt; sqrt = Math::sqrt;\nSystem.out.println(sqrt.apply(16)); // 输出：4.0\n</code></pre>  </div></div>\n\n<h4 id=\"2-实例方法引用\">2. 实例方法引用</h4>\n<p>引用某个对象的实例方法，语法为对象::方法名。例如，list::size表示引用list对象的size方法。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// 实例方法引用\nList&lt;String&gt; list = Arrays.asList(\"Java\", \"Python\", \"C++\");\nConsumer&lt;String&gt; print = System.out::println;\nlist.forEach(print); // 输出：Java Python C++\n</code></pre>  </div></div>\n<h4 id=\"3-类名方法引用\">3. 类名方法引用</h4>\n<p>引用特定类的任意对象的实例方法，语法为类名::方法名。例如，String::length表示引用String类的length方法。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// 类名方法引用\nFunction&lt;String, Integer&gt; length = String::length;\nSystem.out.println(length.apply(\"Hello\")); // 输出：5\n</code></pre>  </div></div>\n<h4 id=\"4-构造方法引用\">4. 构造方法引用</h4>\n<p>引用构造方法来创建新对象，语法为类名::new。例如，ArrayList::new表示引用ArrayList的无参构造方法。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// 构造方法引用\nSupplier&lt;List&lt;String&gt;&gt; listSupplier = ArrayList::new;\nList&lt;String&gt; newList = listSupplier.get();\n</code></pre>  </div></div>\n<p>使用方法引用可以简化代码并提高可读性，特别是在函数式接口中传递方法时。它允许直接引用已经存在的方法，而无需编写冗长的Lambda表达式或匿名内部类。</p>\n\n<p>方法引用是Java 8中一个强大且实用的特性，可以使代码更简洁、易读，并提高开发效率。它是函数式编程在Java中的重要组成部分，与Lambda表达式一起为Java引入了更加灵活和优雅的编程方式。</p>\n\n<h3 id=\"四-默认方法\">(四). 默认方法</h3>\n<p>Java 8引入了默认方法（Default Methods），也称为扩展方法（Extension Methods），它们是接口中具有默认实现的方法。</p>\n\n<p>默认方法允许在接口中定义具有方法体的方法，而不需要实现类必须提供方法的具体实现。默认方法为接口提供了一种向后兼容的方式，在向现有接口添加新方法时，不会破坏已有的实现类。</p>\n\n<p>默认方法在接口中使用default关键字进行定义，具有方法体。接口中的默认方法可以直接在接口中调用，也可以被实现该接口的类重写。</p>\n\n<p>以下是一个示例，演示了默认方法的使用：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>interface Vehicle {\n    void start();\n\n    default void honk() {\n        System.out.println(\"Honking the horn\");\n    }\n}\n</code></pre>  </div></div>\n<p>对上述示例接口的两个实现类</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>class Car implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Starting the car\");\n    }\n}\nclass Bike implements Vehicle {\n    @Override\n    public void start() {\n        System.out.println(\"Starting the bike\");\n    }\n\n    @Override\n    public void honk() {\n        System.out.println(\"Bike honking the horn\");\n    }\n}\n</code></pre>  </div></div>\n<p>对实现类的使用</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public class Main {\n    public static void main(String[] args) {\n        Vehicle car = new Car();\n        car.start(); // 输出：Starting the car\n        car.honk();  // 输出：Honking the horn\n\n        Vehicle bike = new Bike();\n        bike.start(); // 输出：Starting the bike\n        bike.honk();  // 输出：Bike honking the horn\n    }\n}\n</code></pre>  </div></div>\n<p>在上述示例中，Vehicle接口定义了两个方法：start()和默认方法honk()。Car类和Bike类实现了Vehicle接口，并分别提供了自己的实现。Car类使用了默认方法的默认实现，而Bike类重写了默认方法。</p>\n\n<p>默认方法的引入使得接口能够具有一些通用的行为，而不会破坏已有的实现类。它为接口的演化提供了更大的灵活性，使得在接口上添加新的功能变得更加容易。</p>\n\n<h3 id=\"五-stream-api\">(五). Stream API</h3>\n<p>Java 8引入了Stream API，它是一种用于处理集合数据的新的抽象层。Stream API允许开发人员以声明性的方式操作数据集合，实现更简洁、更可读的代码。</p>\n\n<h4 id=\"1介绍\">1.介绍</h4>\n<p>Stream是一个来自数据源的元素队列，并支持各种操作，比如过滤、映射、排序、聚合等。使用Stream API，可以在集合上执行复杂的数据操作，而无需编写繁琐的循环和条件语句。</p>\n\n<p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>\n\n<p>元素流在管道中经过中间操作(intermediate operation)的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>+--------------------+       +------+   +------+   +---+   +-------+ \n| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect| \n+--------------------+       +------+   +------+   +---+   +-------+ \n</code></pre>  </div></div>\n<p>以上的流程转换为 Java 代码，实例如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); \n// 获取集合中大于2、并且经过排序、平方去重的有序集合 \nList&lt;Integer&gt; squaresList = numbers \n        .stream() \n        .filter(x -&gt; x &gt; 2) \n        .sorted((x,y) -&gt; x.compareTo(y)) \n        .map( i -&gt; i*i).distinct().collect(Collectors.toList()); \n</code></pre>  </div></div>\n<p>在 Java 8 中，集合接口有两个方法来生成流：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>stream()：为集合创建串行流\nparallelStream()：为集合创建并行流 当然，流的来源可以是集合，数组，I/O channel， 产生器generator 等!\n</code></pre>  </div></div>\n\n<h4 id=\"2-stream-api的常用操作\">2. Stream API的常用操作：</h4>\n\n<h5 id=\"21创建stream\">2.1创建Stream</h5>\n<p>可以通过集合、数组、I/O通道等方式创建Stream。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nStream&lt;Integer&gt; stream = numbers.stream();\n</code></pre>  </div></div>\n<h5 id=\"22过滤filter\">2.2过滤filter</h5>\n<p>使用filter()方法过滤Stream中的元素。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Integer&gt; evenNumbers = numbers.stream()\n                                   .filter(n -&gt; n % 2 == 0)\n                                   .collect(Collectors.toList());\n</code></pre>  </div></div>\n<h5 id=\"23映射map\">2.3映射map</h5>\n<p>使用map()方法将Stream中的元素映射到另一个值。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;String&gt; words = Arrays.asList(\"Java\", \"Stream\", \"API\");\nList&lt;Integer&gt; wordLengths = words.stream()\n                                 .map(String::length)\n                                 .collect(Collectors.toList());\n</code></pre>  </div></div>\n\n<h5 id=\"24排序sorted\">2.4排序sorted</h5>\n<p>使用sorted()方法对Stream中的元素进行排序。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Integer&gt; sortedNumbers = numbers.stream()\n                                     .sorted()\n                                     .collect(Collectors.toList());\n</code></pre>  </div></div>\n\n<h5 id=\"25聚合操作reduce\">2.5聚合操作reduce</h5>\n<p>使用reduce()方法对Stream中的元素进行聚合操作，如求和、求最大值、求最小值等。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>int sum = numbers.stream()\n                 .reduce(0, Integer::sum);\n</code></pre>  </div></div>\n<h5 id=\"26收集结果collect\">2.6收集结果collect</h5>\n<p>使用collect()方法将Stream中的元素收集到一个集合或Map中。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Integer&gt; collectedNumbers = numbers.stream()\n                                        .collect(Collectors.toList());\n\nMap&lt;String, Integer&gt; nameLengthMap = names.stream()\n                                          .collect(Collectors.toMap(Function.identity(), String::length));\n</code></pre>  </div></div>\n<p>Stream API还提供了许多其他操作，如限制元素数量、跳过元素、查找元素、判断是否满足条件等。</p>\n\n<p>使用Stream API可以编写更简洁、更可读的代码，它提供了一种更直观的方式来处理集合数据，同时还能够发挥并行计算的潜力，提高程序的性能。</p>\n\n<h3 id=\"六-optional类\">(六). Optional类</h3>\n<p>Java 8引入了Optional类，它是用来解决空指针异常（NullPointerException）的常见问题的一种方式。Optional类是一个容器对象，可以包含一个非空的值或者表示值不存在。使用Optional类可以避免显式地进行空值检查，从而简化了代码，并提高了代码的可读性和健壮性。</p>\n\n<h4 id=\"1-创建optional对象\">1. 创建Optional对象：</h4>\n\n<p>使用静态方法of()创建包含非空值的Optional对象。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Optional&lt;String&gt; optional = Optional.of(\"Hello\");\n</code></pre>  </div></div>\n<p>使用静态方法empty()创建一个空的Optional对象。</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Optional&lt;String&gt; emptyOptional = Optional.empty();\n</code></pre>  </div></div>\n<p>使用静态方法ofNullable()创建一个Optional对象，可以接受空值。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Optional&lt;String&gt; optional = Optional.ofNullable(null);\n</code></pre>  </div></div>\n<h4 id=\"2-检查值的存在\">2. 检查值的存在：</h4>\n<p>使用isPresent()方法检查Optional对象是否包含值。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Optional&lt;String&gt; optional = Optional.of(\"Hello\");\nif (optional.isPresent()) {\n    System.out.println(\"Value is present: \" + optional.get());\n} else {\n    System.out.println(\"Value is absent\");\n}\n</code></pre>  </div></div>\n<h4 id=\"3-获取值\">3. 获取值：</h4>\n<p>使用get()方法获取Optional对象中的值（前提是已经通过isPresent()方法检查了值的存在性）。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Optional&lt;String&gt; optional = Optional.of(\"Hello\");\nString value = optional.get();\n</code></pre>  </div></div>\n<h4 id=\"4-避免空值\">4. 避免空值：</h4>\n<p>使用orElse()方法获取Optional对象中的值，如果值不存在则返回指定的默认值。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Optional&lt;String&gt; optional = Optional.ofNullable(null);\nString value = optional.orElse(\"Default Value\");\n</code></pre>  </div></div>\n<p>使用orElseGet()方法获取Optional对象中的值，如果值不存在则通过Supplier接口提供一个默认值。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Optional&lt;String&gt; optional = Optional.ofNullable(null);\nString value = optional.orElseGet(() -&gt; generateDefaultValue());\n</code></pre>  </div></div>\n<h4 id=\"5-处理值\">5. 处理值：</h4>\n<p>使用ifPresent()方法对Optional对象中的值进行处理，如果值存在则执行指定的操作。</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Optional&lt;String&gt; optional = Optional.of(\"Hello\");\noptional.ifPresent(value -&gt; System.out.println(\"Value is present: \" + value));\n</code></pre>  </div></div>\n<h4 id=\"6-链式调用\">6. 链式调用：</h4>\n<p>可以通过链式调用一系列Optional对象的方法来处理值的存在与否。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Optional&lt;String&gt; optional = Optional.of(\"Hello\");\noptional.map(String::toUpperCase)\n        .ifPresent(value -&gt; System.out.println(\"Modified value: \" + value));\n</code></pre>  </div></div>\n<p>Optional类提供了一种优雅地处理空值的方式，它可以避免繁琐的空值检查，使代码更加简洁和可读。使用Optional类可以提高代码的健壮性，并减少空指针异常的发生。</p>\n\n<h3 id=\"七-date-time-api\">(七). Date Time API</h3>\n<p>Java 8引入了新的日期和时间API，以解决旧的Date和Calendar类在设计上的一些问题。新的日期和时间API位于java.time包中，提供了更简洁、易用和线程安全的日期和时间处理方式。</p>\n\n<h4 id=\"1-使用原因\">1. 使用原因</h4>\n\n<p><strong>设计更合理：</strong>旧的Date和Calendar类在设计上存在一些问题，比如可变性、线程安全性和易用性等方面。新的Date Time API通过不可变性、线程安全性和清晰的设计，避免了这些问题，并提供了更一致、更可靠的日期和时间操作。</p>\n\n<p><strong>更加易用：</strong>新的Date Time API提供了一组简洁而直观的类和方法，使得日期和时间的操作更加易用和直观。它提供了更多的方法来处理日期和时间，如日期加减、格式化、解析、比较等操作，减少了编写复杂代码的工作量。</p>\n\n<p><strong>更好的类型安全性：</strong>新的Date Time API引入了一些新的类型，如LocalDate、LocalTime、LocalDateTime等，用于表示日期和时间。这些类型提供了更严格的类型检查和更准确的操作，减少了错误和异常的发生。</p>\n\n<p><strong>更好的时区支持：</strong>新的Date Time API提供了更好的时区支持，可以轻松地处理不同时区的日期和时间。它引入了ZoneId和ZonedDateTime等类，用于表示带有时区的日期和时间，提供了丰富的时区操作和转换方法。</p>\n\n<p><strong>与其他API的集成：</strong>新的Date Time API与其他Java 8的特性和API更好地集成，如Lambda表达式、Stream API等。它可以与函数式编程结合使用，使得处理日期和时间的代码更加简洁和灵活。</p>\n\n<h4 id=\"2-主要组件和用法\">2. 主要组件和用法</h4>\n\n<h5 id=\"21-localdate\">2.1 LocalDate</h5>\n<p>表示日期，不包含时间和时区信息。</p>\n\n<p>创建当前日期：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LocalDate today = LocalDate.now();\n</code></pre>  </div></div>\n<p>创建指定日期：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LocalDate date = LocalDate.of(2023, 5, 18);\n</code></pre>  </div></div>\n<p>获取日期的年、月、日等信息：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>int year = date.getYear();\nMonth month = date.getMonth();\nint day = date.getDayOfMonth();\nDayOfWeek dayOfWeek = date.getDayOfWeek();\n</code></pre>  </div></div>\n<h5 id=\"22-localtime\">2.2 LocalTime</h5>\n<p>表示时间，不包含日期和时区信息。</p>\n\n<p>创建当前时间：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LocalTime time = LocalTime.now();\n</code></pre>  </div></div>\n<p>创建指定时间：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LocalTime time = LocalTime.of(10, 30, 0);\n</code></pre>  </div></div>\n<p>获取时间的小时、分钟、秒等信息：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>int hour = time.getHour();\nint minute = time.getMinute();\nint second = time.getSecond();\n</code></pre>  </div></div>\n<h5 id=\"23-localdatetime\">2.3 LocalDateTime</h5>\n<p>表示日期和时间，不包含时区信息。</p>\n\n<p>创建当前日期和时间：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LocalDateTime dateTime = LocalDateTime.now();\n</code></pre>  </div></div>\n<p>创建指定日期和时间：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LocalDateTime dateTime = LocalDateTime.of(2023, 5, 18, 10, 30, 0);\n</code></pre>  </div></div>\n\n<p>获取日期和时间的各个组成部分：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>int year = dateTime.getYear();\nMonth month = dateTime.getMonth();\nint day = dateTime.getDayOfMonth();\nint hour = dateTime.getHour();\nint minute = dateTime.getMinute();\nint second = dateTime.getSecond();\n</code></pre>  </div></div>\n<h5 id=\"24-zoneddatetime\">2.4 ZonedDateTime</h5>\n<p>表示带有时区的日期和时间。</p>\n\n<p>创建当前日期和时间，并指定时区：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of(\"Asia/Shanghai\"));\n</code></pre>  </div></div>\n\n<p>创建指定日期和时间，并指定时区：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ZonedDateTime zonedDateTime = ZonedDateTime.of(LocalDateTime.now(), ZoneId.of(\"Asia/Tokyo\"));\n</code></pre>  </div></div>\n<h5 id=\"25-duration\">2.5 Duration</h5>\n<p>表示一段时间间隔。</p>\n\n<p>计算两个时间点之间的间隔：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LocalDateTime start = LocalDateTime.of(2023, 5, 18, 10, 0, 0);\nLocalDateTime end = LocalDateTime.of(2023, 5, 18, 11, 30, 0);\nDuration duration = Duration.between(start, end);\nlong minutes = duration.toMinutes();\n</code></pre>  </div></div>\n<h5 id=\"26-period\">2.6 Period</h5>\n<p>表示日期之间的间隔。</p>\n\n<p>计算两个日期之间的间隔：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>LocalDate startDate = LocalDate.of(2023, 5, 18);\nLocalDate endDate = LocalDate.of(2023, 6, 18);\nPeriod period = Period.between(startDate, endDate);\nint months = period.getMonths();\nint days = period.getDays();\n</code></pre>  </div></div>\n\n<p>Java 8 Date Time API提供了丰富的类和方法，可以更方便地进行日期和时间的处理。它的设计更加符合实际需求，并且提供了很多便利的操作方法，使得日期和时间的计算、格式化和解析等操作变得简单而直观。</p>\n\n<h3 id=\"八-nashorn-javascript-引擎\">(八). Nashorn, JavaScript 引擎</h3>\n\n<p>Java 8引入了Nashorn作为新的JavaScript引擎，它是基于JVM的高性能JavaScript运行时环境。Nashorn的目标是提供一个与传统的Rhino引擎相比更快速、更现代化的JavaScript解释器。</p>\n\n<p>以下是Nashorn的一些主要特点和优势：</p>\n\n<p><strong>高性能：</strong>Nashorn引擎使用了JIT（即时编译）技术，能够将JavaScript代码编译成高效的字节码，从而实现更快的执行速度。相比传统的Rhino引擎，Nashorn在性能上有显著的提升。</p>\n\n<p><strong>与Java的无缝集成：</strong>Nashorn可以直接访问Java类和API，能够在Java和JavaScript之间进行无缝的交互。JavaScript代码可以调用Java类的方法、访问Java对象的属性，反之亦然。这种集成性使得在Java应用程序中嵌入JavaScript代码变得更加方便。</p>\n\n<p><strong>支持ES6标准：</strong>Nashorn对ES6（ECMAScript 2015）标准提供了广泛的支持，包括箭头函数、模板字符串、解构赋值、类和模块等特性。这使得开发者能够使用最新的JavaScript语言特性，提高代码的可读性和开发效率。</p>\n\n<p><strong>轻量级和易于部署：</strong>Nashorn是一个轻量级的JavaScript引擎，作为JDK的一部分，无需单独安装，可以直接在Java应用程序中使用。这使得部署和管理变得更加简单。</p>\n\n<p><strong>脚本执行和嵌入式应用：</strong>Nashorn可以作为脚本引擎使用，可以从命令行或脚本文件中执行JavaScript代码。同时，它也可以作为嵌入式引擎在Java应用程序中使用，通过API调用执行JavaScript代码。</p>\n\n<p>当使用Nashorn JavaScript引擎时，可以在Java中嵌入JavaScript代码并进行互操作。以下是一个简单的示例，展示了如何在Java中执行JavaScript代码和在JavaScript中调用Java方法</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n\npublic class NashornExample {\n    public static void main(String[] args) {\n        // 创建Nashorn引擎\n        ScriptEngineManager engineManager = new ScriptEngineManager();\n        ScriptEngine engine = engineManager.getEngineByName(\"nashorn\");\n\n        try {\n            // 在Java中执行JavaScript代码\n            engine.eval(\"print('Hello from JavaScript!');\");\n\n            // 在JavaScript中调用Java方法\n            engine.eval(\"var result = java.lang.Math.sqrt(16);\");\n            Object result = engine.get(\"result\");\n            System.out.println(\"Square root of 16 is: \" + result);\n        } catch (ScriptException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>  </div></div>\n<p>上述示例中，首先创建了一个Nashorn引擎。然后使用eval方法执行了一段JavaScript代码，在控制台输出了”Hello from JavaScript!”。接着，在JavaScript中调用了Java的Math.sqrt方法来计算16的平方根，然后通过engine.get方法获取了计算结果，并在Java中打印出来。</p>\n\n<p>这个示例展示了Nashorn在Java和JavaScript之间的互操作能力。你可以根据具体的需求，编写更复杂的代码来实现更多的交互操作。</p>\n\n<p>总的来说，Nashorn提供了一个高性能、与Java无缝集成的JavaScript运行时环境。它使得在Java应用程序中使用JavaScript变得更加便捷，同时也提供了现代化的语言特性和更好的性能。不过需要注意的是，自Java 11开始，Nashorn被标记为已弃用，并在未来的版本中可能会被移除，建议使用其他现代化的JavaScript引擎，如GraalVM。</p>\n","dir":"/blog/development/java/jottings/","name":"2023-05-18_1.md","path":"blog/development/java/jottings/2023-05-18_1.md","url":"/blog/development/java/jottings/2023-05-18_1.html"},{"sort":8,"permalink":"/blog/development/os/","layout":"default","title":"操作系统","content":"<h1 id=\"操作系统\">操作系统</h1>\n\n<ul>\n <li><a href=\"/blog/development/os/linux/\">linux</a>\n <ul>\n <li><a href=\"/blog/development/os/linux/2023-05-17_2.html\">Linux命令大全(Linux常用命令基础)</a></li>\n <li><a href=\"/blog/development/os/linux/2023-05-17_3.html\">Linux命令大全(Linux常用命令进阶)</a></li>\n <li><a href=\"/blog/development/os/linux/2023-04-23_1.html\">Linux的上传和下载功能</a></li>\n <li><a href=\"/blog/development/os/linux/2023-05-17_1.html\">Centos防火墙配置</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/os/windows/\">windows</a>\n <ul>\n <li><a href=\"/blog/development/os/windows/2023-04-27_1.html\">Windows端口常见问题解决</a></li>\n <li><a href=\"/blog/development/os/windows/2023-05-17_1.html\">Windows常用小技巧</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/os/","name":"README.md","path":"blog/development/os/README.md","url":"/blog/development/os/"},{"sort":9,"permalink":"/blog/development/html/webdesign/","layout":"default","title":"Jekyll网站开发","content":"<h1 id=\"jekyll网站开发\">Jekyll网站开发</h1>\n\n<ul>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_1.html\">Jekyll安装配置和使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_2.html\">七牛云对象存储(图床)免费使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-05-12_1.html\">免费的Jekyll静态网站发布平台</a></li>\n</ul>\n","dir":"/blog/development/html/webdesign/","name":"README.md","path":"blog/development/html/webdesign/README.md","url":"/blog/development/html/webdesign/"},{"sort":9,"permalink":"/blog/development/tool/software/","layout":"default","title":"开发工具","content":"<h1 id=\"开发工具\">开发工具</h1>\n\n<ul>\n <li><a href=\"/blog/development/tool/software/2023-05-17_1.html\">软件开发者常用的工具有哪些(软件开发工具)？</a></li>\n <li><a href=\"/blog/development/tool/software/2023-05-17_2.html\">Idea-Intellij IDEA常用功能及功能优化设置</a></li>\n <li><a href=\"/blog/development/tool/software/2023-05-17_3.html\">Visual Studio Code常用功能及功能优化设置</a></li>\n</ul>\n","dir":"/blog/development/tool/software/","name":"README.md","path":"blog/development/tool/software/README.md","url":"/blog/development/tool/software/"},{"sort":9,"permalink":"/blog/development/html/seo/","layout":"default","title":"SEO优化","content":"<h1 id=\"seo优化\">SEO优化</h1>\n\n<ul>\n <li><a href=\"/blog/development/html/seo/2023-04-27_1.html\">NGINX强制使用https访问(http跳转到https)</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_2.html\">最新主流搜索引擎提交sitemap大全（网站地图）</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_3.html\">SEO实操小技巧关键字</a></li>\n</ul>\n","dir":"/blog/development/html/seo/","name":"README.md","path":"blog/development/html/seo/README.md","url":"/blog/development/html/seo/"},{"sort":9,"permalink":"/blog/about/","layout":"default","title":"关于","content":"<h1 id=\"关于\">关于</h1>\n<p>网站相关文章目录</p>\n\n<ul>\n <li><a href=\"/blog/about/website/\">网站</a>\n <ul>\n <li><a href=\"/blog/about/website/2023-04-23_1.html\">关于Justmyfreedom网站</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/about/","name":"README.md","path":"blog/about/README.md","url":"/blog/about/"},{"sort":9,"permalink":"/blog/development/java/tool/","layout":"default","title":"工具包","content":"<h1 id=\"工具包\">工具包</h1>\n\n<ul>\n <li><a href=\"/blog/development/java/tool/2023-05-12_1.html\">EASYEXCEL使用详解</a></li>\n</ul>\n","dir":"/blog/development/java/tool/","name":"README.md","path":"blog/development/java/tool/README.md","url":"/blog/development/java/tool/"},{"sort":9,"permalink":"/blog/development/tool/","layout":"default","title":"工具","content":"<h1 id=\"工具\">工具</h1>\n\n<ul>\n <li><a href=\"/blog/development/tool/redis/\">Redis</a>\n <ul>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_1.html\">Windows部署redis集群模式</a></li>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_2.html\">redis如何设置密码</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/git/\">Git</a>\n <ul>\n <li><a href=\"/blog/development/tool/git/2023-04-27_1.html\">最新Github创建仓库,将项目上传到GitHub</a></li>\n <li><a href=\"/blog/development/tool/git/2023-04-28_1.html\">Git一份代码同时提交两个Git仓库</a></li>\n <li><a href=\"/blog/development/tool/git/2023-05-12_1.html\">Git常用操作命令</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/maven/\">Maven</a>\n <ul>\n <li><a href=\"/blog/development/tool/maven/2023-04-27_1.html\">Maven推送本地jar包到仓库</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/software/\">开发工具</a>\n <ul>\n <li><a href=\"/blog/development/tool/software/2023-05-17_1.html\">软件开发者常用的工具有哪些(软件开发工具)？</a></li>\n <li><a href=\"/blog/development/tool/software/2023-05-17_2.html\">Idea-Intellij IDEA常用功能及功能优化设置</a></li>\n <li><a href=\"/blog/development/tool/software/2023-05-17_3.html\">Visual Studio Code常用功能及功能优化设置</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/tool/","name":"README.md","path":"blog/development/tool/README.md","url":"/blog/development/tool/"}]