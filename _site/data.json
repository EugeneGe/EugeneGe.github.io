[{"permalink":"/blog/frontier/new/technology/","layout":"default","title":"科技","content":"# 科技\n\n{% include list.liquid all=true %}\n","dir":"/blog/frontier/new/technology/","name":"README.md","path":"blog/frontier/new/technology/README.md","url":"/blog/frontier/new/technology/"},{"permalink":"/blog/about/website/","layout":"default","title":"网站","content":"# 网站\n\n","dir":"/blog/about/website/","name":"README.md","path":"blog/about/website/README.md","url":"/blog/about/website/"},{"permalink":"/blog/life/travel/","layout":"default","title":"趣事小记","content":"# 趣事小记\n\nsource: `{{ page.path }}`\n","dir":"/blog/life/travel/","name":"README.md","path":"blog/life/travel/README.md","url":"/blog/life/travel/"},{"permalink":"/blog/life/poetry/","layout":"default","title":"诗词鉴赏","content":"# 诗词鉴赏\n\n{% include list.liquid all=true %}\n","dir":"/blog/life/poetry/","name":"README.md","path":"blog/life/poetry/README.md","url":"/blog/life/poetry/"},{"permalink":"/blog/frontier/new/life/","layout":"default","title":"生活","content":"# 生活\n\n{% include list.liquid all=true %}\n","dir":"/blog/frontier/new/life/","name":"README.md","path":"blog/frontier/new/life/README.md","url":"/blog/frontier/new/life/"},{"sort":1,"layout":"default","title":"推荐几款好用的自用软件","content":"<h1 id=\"推荐几款好用的自用软件\">推荐几款好用的自用软件</h1>\n\n<p>安利几款好用的自用软件,每一个都找了,好久,有需要的可以下载,各位有好的软件也可以在留言中分享,文章会不定期更新!</p>\n\n<h2 id=\"推荐几款好用的orc截屏识字软件\">推荐几款好用的ORC截屏识字软件</h2>\n<p>其中包含好几软ORC软件,网站找了好久,很多都是有毒的,终于找到后分享给大家,特别安利天若ORC软件,体积小,无毒.纯绿色软件.需要的可以使用百度云下载</p>\n\n<p><a href=\"https://pan.baidu.com/s/1_v-Lgc6Txp630avQlZCvNA\">百度分享地址</a>提取码：prwv</p>\n","dir":"/blog/frontier/recommend/","name":"2023-04-27_1.md","path":"blog/frontier/recommend/2023-04-27_1.md","url":"/blog/frontier/recommend/2023-04-27_1.html"},{"sort":1,"layout":"default","title":"Just My Socks 介绍，Just My Socks 是什么？","content":"<h1 id=\"just-my-socks-介绍just-my-socks-是什么\">Just My Socks 介绍，Just My Socks 是什么？</h1>\n\n<p><a href=\"https://justmysocks.net/members/aff.php?aff=5696\">Just My Socks</a>，也有人喜欢搜 JustMySocks 或 JMS，或者是中文翻译：就是我的袜子。Just My Socks 本身其实是搬瓦工官方的一个 $$ 服务（机场），提供的线路也是跟搬瓦工 VPS 一样，有 CN2 GIA、日本软银、联通 AS9929 等，支持支付宝、银联和 PayPal 付款，最低月付 5.88 美元。</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230423155458min.png\" alt=\"微信截图_20230423155458min\" /></p>\n\n<h2 id=\"just-my-socks-介绍\">Just My Socks 介绍</h2>\n<p>Just My Socks 官网：Just My Socks 官网</p>\n\n<p>Just My Socks 是由搬瓦工官方运营的一个机场服务，并且保证 IP 可用。目前，除了最开始的 LA 方案外，Just My Socks 这几年陆续增加了香港 CMI + NTT 方案、英国伦敦联通 AS9929 方案、日本 CN2 GIA 方案、香港 CN2 GIA 方案、香港 IPLC 方案等</p>\n\n<h2 id=\"just-my-socks-优点\">Just My Socks 优点</h2>\n\n<p>相比于市面上一些其他机场，Just My Socks 作为搬瓦工官方产品，更加靠谱稳定。下面罗列几条 Just My Socks 优点：</p>\n\n<p>稳定靠谱：搬瓦工官网出品，不怕跑路。\n付款方便：支持支付宝、银联、PayPal。\n线路质量高：提供搬瓦工 CN2 GIA 线路，三网 CN2 GIA 直连，对移动、电信、联通均有优化，速度快，线路稳定。\n保证服务可用：Just My Socks 保证服务 IP 可用，不用担心 IP 被墙。\n带宽大：提供最高5Gbps带宽，不限速，不限制设备数量。</p>\n\n<h2 id=\"just-my-socks-可用地址\">Just My Socks 可用地址</h2>\n\n<p>Just My Socks官网更新历程：</p>\n\n<p>Just My Socks官网（国内无法直接访问）：<a href=\"https://justmysocks.net/members/aff.php?aff=5696\">https://justmysocks.net</a>\n2019年4月9日推出第一个官网镜像站（国内无法直接访问）：<a href=\"https://justmysocks1.net/members/aff.php?aff=5696\">https://justmysocks1.net</a>\n2020年1月8日推出第二个官网镜像站（国内无法直接访问）：<a href=\"https://justmysocks2.net/members/aff.php?aff=5696\">https://justmysocks2.net</a>\n2020年6月4日推出第三个官网镜像站：<a href=\"https://justmysocks3.net/members/aff.php?aff=5696\">https://justmysocks3.net</a></p>\n","dir":"/blog/frontier/recommend/","name":"2023-04-23_1.md","path":"blog/frontier/recommend/2023-04-23_1.md","url":"/blog/frontier/recommend/2023-04-23_1.html"},{"sort":1,"permalink":"/blog/development/html/jottings/","layout":"default","title":"随笔","content":"<h1 id=\"随笔\">随笔</h1>\n\n<ul>\n <li><a href=\"/blog/development/html/jottings/2023-04-21_1.html\">html页面如何设置适配移动端</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-04-27_1.html\">HTML页面中返回顶部的几种实现</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_1.html\">html表格导出excel有几种方式</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_2.html\">laydate渲染日期</a></li>\n</ul>\n","dir":"/blog/development/html/jottings/","name":"README.md","path":"blog/development/html/jottings/README.md","url":"/blog/development/html/jottings/"},{"sort":1,"layout":"default","title":"NGINX强制使用https访问(http跳转到https)","content":"<h1 id=\"nginx强制使用https访问http跳转到https\">NGINX强制使用https访问(http跳转到https)</h1>\n\n<p>新站SEO的朋友注意了,经本人测试,使用404强制跳转会导致页面无收录,因为爬虫不会跳转,比如访问地址<a href=\"https://justmyfreedom.com/\">https://justmyfreedom.com/</a>会直接报404,而不会去管后面跳转的地址,直接显示无页面.</p>\n\n<h2 id=\"一需求简介\">一.需求简介</h2>\n<p>  基于nginx搭建了一个https访问的虚拟主机，监听的域名是<a href=\"https://justmyfreedom.com/\">justmyfreedom.com</a>，但是很多用户不清楚https和http的区别，会很容易敲成<a href=\"https://justmyfreedom.com\">https://justmyfreedom.com</a>这时会报出404错误，所以我需要做<strong>基于justmyfreedom.com域名的http向https的强制跳转</strong></p>\n\n<h2 id=\"二http跳转到https配置方式\">二.http跳转到https配置方式</h2>\n<p>进过网上查询,总结了一下三种方式,可以根据需求进行设置.</p>\n\n<h3 id=\"第一种nginx的rewrite方法\">第一种:nginx的rewrite方法</h3>\n<p>这应该是大家最容易想到的方法.</p>\n\n<p>第一步：打开NGINX的配置文件（通常是位于/etc/nginx/nginx.conf或/etc/nginx/conf.d/default.conf）。</p>\n\n<p>第二步：在HTTP server块中，找到对应的server段落。在该段落中，添加以下代码以将所有HTTP请求重定向到HTTPS：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 80;\n    server_name example.com;  // 替换为你的域名\n\n    # HTTP重定向到HTTPS\n    rewrite ^(.*)$ https://$host$1 permanent;\n}\n\n</code></pre>  </div></div>\n<p>这将使用rewrite指令将所有HTTP请求重定向到相应的HTTPS URL。</p>\n\n<p>第三步：在同一个配置文件中，找到HTTPS server块，该块用于处理HTTPS请求。确保以下配置选项正确设置：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 443 ssl;\n    server_name example.com;  // 替换为你的域名\n\n    # 其他SSL/TLS配置项\n    ssl_certificate /path/to/ssl_certificate.crt;  // 替换为你的SSL证书路径\n    ssl_certificate_key /path/to/private_key.key;  // 替换为你的私钥路径\n\n    # 其他配置项\n}\n\n</code></pre>  </div></div>\n<p>确保在listen指令中使用了ssl关键字，以便监听HTTPS流量。</p>\n\n<p>第四步：保存并关闭配置文件。重新加载NGINX配置，以使更改生效。可以通过运行以下命令来实现：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo service nginx reload\n\n</code></pre>  </div></div>\n<p>大功告成！</p>\n\n<h3 id=\"第二种nginx的497状态码\">第二种:nginx的497状态码</h3>\n<p>error code 497</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>497 - normal request was sent to HTTPS\n</code></pre>  </div></div>\n<p>解释：当此虚拟站点只允许https访问时，当用http访问时nginx会报出497错误码,利用error_page命令将497状态码的链接重定向到<a href=\"https://justmyfreedom.com/\">https://justmyfreedom.com/</a>这个域名上</p>\n\n<p>可以按照以下步骤进行配置：</p>\n\n<p>第一步：打开NGINX的配置文件（通常是位于/etc/nginx/nginx.conf或/etc/nginx/conf.d/default.conf）。</p>\n\n<p>第二步：在HTTP server块中，找到对应的server段落。在该段落中，添加以下代码以将所有HTTP请求重定向到HTTPS，并返回497状态码：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 80;\n    server_name example.com;  // 替换为你的域名\n\n    # HTTP重定向到HTTPS，并返回497状态码\n    return 497;\n}\n\n</code></pre>  </div></div>\n<p>这将使用return指令将所有HTTP请求重定向到相应的HTTPS URL，并返回497状态码表示重定向。</p>\n\n<p>第三步：在同一个配置文件中，找到HTTPS server块，该块用于处理HTTPS请求。确保以下配置选项正确设置：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 443 ssl;\n    server_name example.com;  // 替换为你的域名\n\n    # 其他SSL/TLS配置项\n    ssl_certificate /path/to/ssl_certificate.crt;  // 替换为你的SSL证书路径\n    ssl_certificate_key /path/to/private_key.key;  // 替换为你的私钥路径\n\n    # 其他配置项\n}\n</code></pre>  </div></div>\n<p>确保在listen指令中使用了ssl关键字，以便监听HTTPS流量。</p>\n\n<p>第四步：保存并关闭配置文件。重新加载NGINX配置，以使更改生效。可以通过运行以下命令来实现：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo service nginx reload\n</code></pre>  </div></div>\n<p>大功告成！</p>\n\n<h3 id=\"第三种indexhtml刷新网页\">第三种:index.html刷新网页</h3>\n<p>上述两种方法均会耗费服务器的资源，我们可以查看其他网站是如何实现http跳转到https的跳转.测试在浏览器中输入将baidu.com,发现很巧妙的利用meta的刷新作用，将baidu.com跳转到<a href=\"www.baidu.com\">www.baidu.com</a>因此我们可以基于<a href=\"https://justmyfreedom.com/\">http://justmyfreedom.com</a>的虚拟主机路径下也写一个index.html，内容就是http向https的跳转</p>\n\n<p>可以参照以下步骤设置：</p>\n\n<p>第一步：都是打开NGINX的配置文件（通常是位于/etc/nginx/nginx.conf或/etc/nginx/conf.d/default.conf）。</p>\n\n<p>第二步：在HTTP server块中，找到对应的server段落。在该段落中，添加以下代码以将所有HTTP请求重定向到HTTPS：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 80;\n    server_name example.com;  // 替换为你的域名\n\n    # HTTP重定向到HTTPS\n    return 301 https://$host$request_uri;\n}\n</code></pre>  </div></div>\n<p>这将使用return指令将所有HTTP请求重定向到相应的HTTPS URL。</p>\n\n<p>第三步：在同一个配置文件中，找到HTTPS server块，该块用于处理HTTPS请求。确保以下配置选项正确设置：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 443 ssl;\n    server_name example.com;  // 替换为你的域名\n\n    # 其他SSL/TLS配置项\n    ssl_certificate /path/to/ssl_certificate.crt;  // 替换为你的SSL证书路径\n    ssl_certificate_key /path/to/private_key.key;  // 替换为你的私钥路径\n\n    # 其他配置项\n\n    location / {\n        try_files $uri $uri/ /index.html;\n    }\n}\n</code></pre>  </div></div>\n<p>在HTTPS server块的location /段落中，使用try_files指令将请求重定向到index.html文件。这将确保在刷新页面时保持HTTPS连接。</p>\n\n<p>第四步：保存并关闭配置文件。重新加载NGINX配置，以使更改生效。可以通过运行以下命令来实现：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>sudo service nginx reload\n</code></pre>  </div></div>\n<h3 id=\"第四种使用-if-指令\">第四种：使用 if 指令</h3>\n\n<p>和以上方式相同，打开配置文件，修改：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>server {\n    listen 80;\n    server_name example.com;  // 替换为你的域名\n\t\n    if ($http_x_forwarded_proto != \"https\") {\n        return 301 https://$host$request_uri;\n    }\n\n    # 其他配置项\n}\n\n</code></pre>  </div></div>\n<p>在上面配置中，使用了 $http_x_forwarded_proto 变量来判断请求是否通过 HTTP 而不是 HTTPS。如果条件成立，即请求不是通过 HTTPS 访问的，则将其重定向到相应的 HTTPS URL。</p>\n\n<p>请注意，<strong>使用 if 指令需要谨慎</strong>，因为它可能会引入一些不可预测的行为，并且在高负载环境下可能会影响性能。建议使用其他方式（如重定向或 rewrite）来实现强制使用 HTTPS 访问，以获得更可靠和高效的结果。</p>\n\n<p>在配置完成后，保存并重新加载 NGINX 配置。</p>\n\n<p><strong>注意:</strong>\n以上步骤做好之后，当用户访问的网站时，NGINX将使用rewrite指令将HTTP请求重定向到相应的HTTPS URL。确保将”example.com”替换为自己的域名，并将SSL证书和私钥的路径设置为正确的值。</p>\n\n<p>上述几种方法均可以实现基于nginx强制将http请求跳转到https请求，大家可以评价一下优劣或者根据实际需求进行选择。参考时一定要结合自己的实际情况，我很多配置基于项目安全考虑做了删减.</p>\n\n","dir":"/blog/development/html/seo/","name":"2023-04-27_1.md","path":"blog/development/html/seo/2023-04-27_1.md","url":"/blog/development/html/seo/2023-04-27_1.html"},{"sort":1,"layout":"default","title":"关于Justmyfreedom网站","content":"<h1 id=\"关于justmyfreedom网站\">关于Justmyfreedom网站</h1>\n<blockquote>\n <p>大家好，我是<a href=\"https://justmyfreedom.com/\">终南有客</a>，一个热爱自由和创造，喜欢探索和发现新事物的软件开发者</p>\n\n</blockquote>\n\n<p>作为一名软件开发者，工作时间也挺久了，一直想要做一个网站，但总是因为各种原因止步，很是遗憾！</p>\n\n<p>最近在工作之余，突然又蹦出来这个念头，于是趁热打铁，防止自己又出什么幺蛾子，赶紧申请了域名：Justmyfreedom.com，顺带着查看几个感兴趣的博客布局，最终形成了Justmyfreedom网站的布局。</p>\n<h2 id=\"justmyfreedom的含义\">Justmyfreedom的含义</h2>\n<p>在申请域名的时候想了好多域名，最终挑选了这个域名，寓意也很简单：这个网站仅仅表示个人的自由和独立，每个人应该享有自己的自由和权利。</p>\n\n<h2 id=\"首页\">首页</h2>\n<p>首页是一个导航网站布局，工作时会切换好多个搜索网站去搜索信息，并且有很多常用的网址，因此做成了这个简约风格的导航网页，使用起来会方便很多。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230423140835min.png\" alt=\"微信截图_20230423140835min\" /></p>\n\n<h2 id=\"blog\">blog</h2>\n<p>blog中主要是关于平常工作、生活等方面的记录，也有一些开发记录给大家做参考。</p>\n\n<p>当然，可能有人会说不是有很多免费的网站也能记录吗？为什么不用？</p>\n\n<p>那些博客也在用，但是总感觉各种的不方便</p>\n\n<p>哈哈哈……</p>\n\n<p>真正的原因其实：Just my freedom\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230423142633min.png\" alt=\"微信截图_20230423142633min\" /></p>\n\n<h2 id=\"终南有客终南有客公众号\">终南有客终南有客公众号</h2>\n<p>下面是我的公众号，想要了解更多信息的朋友可以关注下，\n<img src=\"https://image.justmyfreedom.com/static/assets/common/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png\" alt=\"终南有客公众号\" /></p>\n","dir":"/blog/about/website/","name":"2023-04-23_1.md","path":"blog/about/website/2023-04-23_1.md","url":"/blog/about/website/2023-04-23_1.html"},{"sort":1,"layout":"default","title":"ChatGpt","content":"<h1 id=\"chatgpt\">ChatGpt</h1>\n\n<h2 id=\"一chatgpt是什么\">一.ChatGpt是什么</h2>\n<p>ChatGPT全称为“chat Generative Pre-trained Transformer”，翻译成中文就是生成型预训练变换模型。它是美国公司OpenAI在2022年11月30日发布研发的聊天机器人程序，能用于问答、文本摘要生成、机器翻译、分类、代码生成和对话AI。[1]是一款人工智能技术驱动的自然语言处理工具。</p>\n\n<p>ChatGPT是一种基于自然语言处理技术和深度学习算法的人工智能语言模型，由OpenAI开发。它可以理解和生成自然语言，包括文字和语音，能够进行对话、问答、摘要生成、文章创作等任务。ChatGPT的基本原理是利用深度学习算法对大规模文本数据进行训练，通过学习文本数据的模式和结构，构建出一种语言模型，可以模仿人类语言的表达和理解方式，从而实现自然语言处理的功能。ChatGPT是目前最先进的自然语言处理技术之一，具有广泛的应用前景，包括智能客服、聊天机器人、虚拟助手等。</p>\n\n<h2 id=\"1科学上网注册与使用-chatgpt\">1.科学上网注册与使用 ChatGPT</h2>\n\n<p>手把手教你如何在国内科学注册chatGPT\n，流程比较简单，主要分以下3步：</p>\n\n<ul>\n <li>科学上网</li>\n <li>注册ChatGPT</li>\n <li>手机号接收验证码</li>\n</ul>\n\n<h3 id=\"2科学上网\">2.科学上网</h3>\n\n<p>如果你已经可以科学上网了，则可以跳过这1步。</p>\n\n<p>科学上网不仅是可以用来使用chatGPT，也可以看ins、油管、face、电报、推特等，所以常备一个科学上网的账号是非常必要的。这里推荐JustMysocks服务，我个人已经使用了5年了，比较稳定，价格合理。注册方式可参考<a href=\"https://justmyfreedom.com/blog/frontier/recommend/2023-04-23_1.html\">Just My Socks 介绍，Just My Socks 是什么？\n</a></p>\n\n<h3 id=\"3注册chatgpt\">3.注册ChatGPT</h3>\n\n<p>首先打开科学上网，访问 chatGPT 官网注册 <a href=\"https://chat.openai.com/auth/login\">https://chat.openai.com/auth/login</a> 填写邮箱，验证邮箱，到手机号输入界面，这里需要一个海外手机号，如果没有请看第3步</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230512160844min.png\" alt=\"微信截图_20230512160844min\" /></p>\n\n<h3 id=\"4接码平台\">4.接码平台</h3>\n<p>手机号接收验证码 <a href=\"https://sms-activate.org/?ref=5329402\">sms-activate</a></p>\n\n<ol>\n <li>给接码平台充值，在右上角，可以使用支付宝或银联卡充值</li>\n <li>在左边选择 openai 再选择一个国家，建议选择印度尼西亚，比较便宜，不过印度更稳定</li>\n <li>回到首页获取号码，回到ChatGPT里填写，等待接收验证码，然后填写到 ChatGPT 注册界面，完成注册</li>\n</ol>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/1232333333333333333min.png\" alt=\"1232333333333333333min\" /></p>\n\n<h3 id=\"5使用chatgpt\">5.使用ChatGPT</h3>\n\n<p>注册完成后，重新登录，可以使用 ChatGPT 了\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230512161708min.png\" alt=\"微信截图_20230512161708min\" /></p>\n","dir":"/blog/frontier/new/technology/","name":"2023-04-23_1.md","path":"blog/frontier/new/technology/2023-04-23_1.md","url":"/blog/frontier/new/technology/2023-04-23_1.html"},{"sort":1,"permalink":"/blog/frontier/recommend/","layout":"default","title":"推荐","content":"<h1 id=\"推荐\">推荐</h1>\n\n<ul>\n <li><a href=\"/blog/frontier/recommend/2023-04-27_1.html\">推荐几款好用的自用软件</a></li>\n <li><a href=\"/blog/frontier/recommend/2023-04-23_1.html\">Just My Socks 介绍，Just My Socks 是什么？</a></li>\n</ul>\n","dir":"/blog/frontier/recommend/","name":"README.md","path":"blog/frontier/recommend/README.md","url":"/blog/frontier/recommend/"},{"sort":1,"layout":"default","title":"html页面如何设置适配移动端","content":"<h1 id=\"html页面如何设置适配移动端\">html页面如何设置适配移动端</h1>\n\n<p>最近做了一个静态网站，需要做一个简单的移动端适配，因为本人主要所后端，因此对前端方面知识比较欠缺。因此记录下开发过程，防止遗忘，也便于大家参考！以下是几种适配移动端的主流方式：</p>\n<h2 id=\"一-html页面适配移动端有哪些主流方式\">一. html页面适配移动端有哪些主流方式？</h2>\n<p>以下是查询到的几种主流的移动端适配方式：</p>\n\n<h3 id=\"方式一-使用响应式布局适配移动端\">方式一. 使用响应式布局适配移动端</h3>\n<p>通过CSS媒体查询，根据不同屏幕尺寸设置不同的样式，使页面在不同的设备上呈现出最佳的视觉效果。</p>\n<h4 id=\"优缺点\">优缺点：</h4>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>优点：\n通过针对不同屏幕尺寸的样式设置，可以在各种设备上呈现出最佳的视觉效果。\n不需要对页面进行复杂的重构，只需要在CSS中添加媒体查询即可。\n缺点：\n需要编写大量的CSS代码，包括各种媒体查询和样式设置。\n在样式设置不合理的情况下，可能会导致页面在某些设备上呈现效果不佳。\n</code></pre>  </div></div>\n\n<h4 id=\"示例代码\">示例代码：</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n\t&lt;title&gt;响应式布局示例&lt;/title&gt;\n\t&lt;meta charset=\"UTF-8\"&gt;\n\t&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n\t&lt;style&gt;\n\t\t/* 默认样式 */\n\t\th1 {\n\t\t\tfont-size: 28px;\n\t\t\tcolor: #333;\n\t\t\ttext-align: center;\n\t\t}\n\t\tp {\n\t\t\tfont-size: 16px;\n\t\t\tcolor: #666;\n\t\t\ttext-align: justify;\n\t\t\tmargin: 0 auto;\n\t\t\tmax-width: 1280px;\n\t\t}\n\t\t\n\t\t/* 媒体查询样式 */\n\t\t@media screen and (max-width: 1280px) {\n\t\t\th1 {\n\t\t\t\tfont-size: 24px;\n\t\t\t}\n\t\t\tp {\n\t\t\t\tfont-size: 14px;\n\t\t\t}\n\t\t}\n\t\t@media screen and (max-width: 560px) {\n\t\t\th1 {\n\t\t\t\tfont-size: 20px;\n\t\t\t}\n\t\t\tp {\n\t\t\t\tfont-size: 12px;\n\t\t\t}\n\t\t}\n\t&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\t&lt;header&gt;\n\t\t&lt;h1&gt;响应式布局示例&lt;/h1&gt;\n\t&lt;/header&gt;\n\t&lt;main&gt;\n\t\t&lt;p&gt;通过CSS媒体查询，根据不同屏幕尺寸设置不同的样式，使页面在不同的设备上呈现出最佳的视觉效果。&lt;/p&gt;\n\t&lt;/main&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>  </div></div>\n<p>示例中，”&lt;meta&gt;” 标签中的 “viewport” 属性用于设置页面的视口大小，以便在不同的设备上以不同的比例显示页面。CSS 样式中，”max-width” 属性用于限制元素的最大宽度，以确保在较大屏幕上元素不会超出屏幕宽度。媒体查询的 “screen” 选择器用于指定应用于屏幕设备的样式。</p>\n\n<p>示例中，定义了两个媒体查询：一种在屏幕宽度小于或等于 1280px 时应用，另一种在屏幕宽度小于或等于 560px 时应用。这些媒体查询分别针对不同的屏幕尺寸设置标题和段落的字体大小。这样，在较小的屏幕上，文本将缩小，以适应屏幕大小，从而提供更好的展示效果。</p>\n\n<h3 id=\"方式二-使用视口viewport适配移动端\">方式二. 使用视口（Viewport）适配移动端</h3>\n<p>在HTML头部添加”meta”标签，设置视口的宽度、缩放比例等属性，让页面在移动设备上呈现出最佳的效果。</p>\n<h4 id=\"优缺点-1\">优缺点：</h4>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>优点：\n可以在移动设备上呈现出最佳的效果，避免了在移动设备上出现缩放或者溢出的问题。\n通过设置缩放比例，可以控制页面的大小，防止页面在移动设备上过大或过小。\n缺点：\n需要手动设置\"meta\"标签，对于大型的网站或者应用程序，需要进行大量的工作量。\n不同的设备可能需要不同的视口设置，需要针对每个设备进行适配。 #### 示例:\t 以下是使用视口（Viewport）进行代码示例的例子：\n</code></pre>  </div></div>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Viewport Example&lt;/title&gt;\n    &lt;style&gt;\n      /* 设置不同屏幕尺寸下的样式 */\n      @media (max-width: 767px) {\n        body {\n          font-size: 16px;\n        }\n      }\n\n      @media (min-width: 768px) and (max-width: 991px) {\n        body {\n          font-size: 18px;\n        }\n      }\n\n      @media (min-width: 992px) {\n        body {\n          font-size: 20px;\n        }\n      }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Viewport Example&lt;/h1&gt;\n    &lt;p&gt;This is an example of using viewport to make a responsive webpage.&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>  </div></div>\n<p>在该示例中，HTML头部中添加了一个”meta”标签，用于设置视口的宽度和缩放比例等属性。然后，使用CSS媒体查询根据不同屏幕尺寸设置不同的样式，使页面在不同的设备上呈现出最佳的视觉效果。通过这种方式，我们可以在移动设备上创建具有响应式布局的网页。</p>\n\n<h3 id=\"方式三-使用rem单位适配移动端\">方式三. 使用rem单位适配移动端</h3>\n<p>rem是相对于根元素的字体大小来计算的单位，可以根据屏幕大小动态调整字体大小和其他元素的尺寸，从而适配不同的屏幕尺寸。</p>\n\n<p>可以在CSS样式表中使用rem单位来设置字体大小和其他元素的尺寸。通常情况下，会将根元素的字体大小设置为基准值，然后使用rem单位来设置其他元素的尺寸。</p>\n<h4 id=\"优缺点-2\">优缺点：</h4>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>优点：\n可以根据屏幕大小动态调整字体大小和其他元素的尺寸，从而适配不同的屏幕尺寸。\n可以使页面元素在不同设备上呈现出类似的比例和样式。\n缺点：\n适用范围受限，主要用于字体和元素大小的调整，无法实现复杂布局。\n代码编写需要一定的技巧和经验。 #### 例如：\n</code></pre>  </div></div>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/* 设置根元素的字体大小为16px */\nhtml {\n  font-size: 16px;\n}\n\n/* 使用rem单位来设置字体大小和其他元素的尺寸 */\nh1 {\n  font-size: 2rem; /* 相当于32px */\n  margin-bottom: 1.5rem; /* 相当于24px */\n}\n\np {\n  font-size: 1.125rem; /* 相当于18px */\n  line-height: 1.5rem; /* 相当于24px */\n}\n\n@media screen and (max-width: 768px) {\n  /* 在小屏幕上调整根元素的字体大小 */\n  html {\n    font-size: 14px;\n  }\n\n  /* 使用rem单位来设置字体大小和其他元素的尺寸 */\n  h1 {\n    font-size: 1.75rem; /* 相当于24.5px */\n    margin-bottom: 1rem; /* 相当于14px */\n  }\n\n  p {\n    font-size: 1rem; /* 相当于14px */\n    line-height: 1.5rem; /* 相当于21px */\n  }\n}\n\n</code></pre>  </div></div>\n<p>在这个示例中，首先将根元素的字体大小设置为16px，然后使用rem单位来设置标题、段落等元素的字体大小和间距。在”@media”查询中，根据屏幕宽度的不同，动态调整根元素的字体大小，从而适配不同的屏幕尺寸。</p>\n\n<h3 id=\"方式四-使用flexbox布局适配移动端\">方式四. 使用Flexbox布局适配移动端</h3>\n<p>使用Flexbox可以轻松实现自适应布局，使页面元素根据设备屏幕大小自动调整位置和大小。</p>\n\n<h4 id=\"优缺点-3\">优缺点：</h4>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>优点：\n可以轻松实现自适应布局，使页面元素根据设备屏幕大小自动调整位置和大小。\n可以很好地适应不同的屏幕尺寸，且对于复杂布局也有很好的支持。\n缺点：\n兼容性问题，旧版浏览器可能无法支持Flexbox布局。\n对于不熟悉Flexbox的开发人员，可能需要学习一些新的CSS属性和概念。 #### 示例：\n</code></pre>  </div></div>\n\n<p>以下是一个使用Flexbox布局的代码示例，其中通过 “display: flex” 将 “&lt;div&gt;” 元素设置为Flex容器，使用 “flex-direction” 指定Flex容器中元素的排列方向，使用 “flex-wrap” 指定Flex容器中元素是否换行，使用 “justify-content” 和 “align-items” 分别指定Flex容器中元素在主轴和侧轴上的对齐方式。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;Flexbox Layout Example&lt;/title&gt;\n  &lt;style&gt;\n    /* 将div设置为Flex容器 */\n    div {\n      display: flex;\n      flex-direction: row; /* 水平排列 */\n      flex-wrap: wrap; /* 换行 */\n      justify-content: space-around; /* 主轴居中对齐 */\n      align-items: center; /* 侧轴居中对齐 */\n    }\n    \n    /* Flex容器中的元素 */\n    div &gt; div {\n      width: 200px;\n      height: 200px;\n      background-color: #ccc;\n      margin: 10px;\n    }\n    \n    /* 在移动设备上将元素宽度调整为100% */\n    @media screen and (max-width: 480px) {\n      div &gt; div {\n        width: 100%;\n      }\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;div&gt;元素1&lt;/div&gt;\n    &lt;div&gt;元素2&lt;/div&gt;\n    &lt;div&gt;元素3&lt;/div&gt;\n    &lt;div&gt;元素4&lt;/div&gt;\n    &lt;div&gt;元素5&lt;/div&gt;\n    &lt;div&gt;元素6&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>  </div></div>\n<h3 id=\"方式五-使用flexbox布局适配移动端\">方式五. 使用Flexbox布局适配移动端</h3>\n<p>CSS Grid是一种强大的布局方式，可以更加灵活地控制页面元素的位置和大小，也能够适应不同的屏幕尺寸。</p>\n<h4 id=\"优缺点-4\">优缺点：</h4>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>优点：\n可以更加灵活地控制页面元素的位置和大小，也能够适应不同的屏幕尺寸。\n对于复杂布局的支持更加全面，可以实现更加自由的布局。\n缺点：\n兼容性问题，旧版浏览器可能无法支持CSS Grid布局。\n对于不熟悉CSS Grid的开发人员，可能需要学习一些新的CSS属性和概念。 #### 示例： 以下是一个使用CSS Grid布局的代码示例：\n</code></pre>  </div></div>\n\n<p>HTML部分：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;div class=\"grid-container\"&gt;\n  &lt;div class=\"grid-item\"&gt;1&lt;/div&gt;\n  &lt;div class=\"grid-item\"&gt;2&lt;/div&gt;\n  &lt;div class=\"grid-item\"&gt;3&lt;/div&gt;\n  &lt;div class=\"grid-item\"&gt;4&lt;/div&gt;\n  &lt;div class=\"grid-item\"&gt;5&lt;/div&gt;\n  &lt;div class=\"grid-item\"&gt;6&lt;/div&gt;\n&lt;/div&gt;\n\n</code></pre>  </div></div>\n<p>CSS部分：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>.grid-container {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  grid-gap: 20px;\n}\n.grid-item {\n  background-color: #f1f1f1;\n  padding: 20px;\n  text-align: center;\n}\n\n</code></pre>  </div></div>\n<p>这个例子中，创建了一个包含6个元素的网格容器，使用了 “display: grid” 来开启网格布局，并通过 “grid-template-columns” 属性来设置列的数量和大小。</p>\n\n<p>在这里，使用了 “repeat(auto-fit, minmax(200px, 1fr))” 来创建自适应的列，这意味着每列的最小宽度为200像素，最大宽度为1份剩余空间，使得网格可以在不同屏幕尺寸下自适应地调整。 “grid-gap” 属性用于设置行列之间的间距。最后，我们为每个网格项设置了一些基本样式，包括背景色和内边距。</p>\n\n<p>以上是不同移动端适配方式的优缺点，各位可以根据具体业务需求，进行方式选择！</p>\n","dir":"/blog/development/html/jottings/","name":"2023-04-21_1.md","path":"blog/development/html/jottings/2023-04-21_1.md","url":"/blog/development/html/jottings/2023-04-21_1.html"},{"sort":1,"layout":"default","title":"Jekyll安装配置和使用","content":"<h1 id=\"jekyll安装配置和使用\">Jekyll安装配置和使用</h1>\n\n<p>最近想试试用Jekyll在Github搭建blog。选取网站模板，修改域名等等这些网上都有很详细的教程了，文末会附上链接，这里就不再赘述了。本文主要记录在Windows本地安装jekyll环境的过程，遇到的问题及如何解决的。参考<a href=\"http://jekyllcn.com/docs/posts/\">Jekyll</a>官网</p>\n\n<h2 id=\"一-环境安装\">一. 环境安装</h2>\n\n<h3 id=\"1-安装ruby\">1. 安装Ruby</h3>\n<p>在Windows上使用RubyInstaller安装比较方便，去<a href=\"https://rubyinstaller.org/downloads/\">Ruby官网</a>下载最新版本的RubyInstaller。注意32位和64位版本的区分。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424134647min.png\" alt=\"微信截图_20230424134647min\" />\n在这里直接选择下载 Ruby+Devkit 3.1.4-1 (x64) 版本即可，就不用Ruby和Devkit分开安装了。</p>\n\n<blockquote>\n <p>注意：这里建议先选好Jekyll网站模板，在根据网站模板所需要的Ruby版本进行安装。否则在启动的时候可能会出现版本不兼容问题，处理起来比较麻烦。</p>\n</blockquote>\n\n<p>安装后选择安装msys2 -&gt;3，可能会安装失败,此处我没有管，也没有另行操作。</p>\n\n<h3 id=\"2-安装jekyll\">2. 安装Jekyll</h3>\n<p>安装这个比较费时，在cmd中输入:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>gem install jekyll\n</code></pre>  </div></div>\n<p>安装完后查看：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jekyll -v\n</code></pre>  </div></div>\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424134834min.png\" alt=\"微信截图_20230424134834min\" /></p>\n\n<h2 id=\"二-jekyll启动\">二. jekyll启动</h2>\n\n<h3 id=\"1-下载jekyll主题\">1. 下载Jekyll主题</h3>\n<p>可通过如下Jekyll主题商店自行选取喜欢的主题库：</p>\n\n<p>https://jamstackthemes.dev/ssg/jekyll/</p>\n\n<p>http://jekyllthemes.org/</p>\n\n<h4 id=\"下载jekyll主题根据喜好自行选择\">下载jekyll主题（根据喜好自行选择）</h4>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git clone https://github.com/rundocs/jekyll-rtd-theme.git\n</code></pre>  </div></div>\n\n<h3 id=\"2-启动\">2. 启动</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#进入下载好的目录\ncd jekyll-rtd-theme\n# 配置bundle国内镜像仓库\nbundle config mirror.https://rubygems.org https://gems.ruby-china.com\n# 安装依赖\nbundle install\n# 启动本地主题\njekyll serve 或 bundle exec jekyll serve 因为本身Jekyll是个代码生成器，修改MD并不是立刻映射到html文件上。可以用这条命令启动服务，这样文件被改变之后，会即刻刷新网页\n</code></pre>  </div></div>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>bundle exec jekyll serve --livereload\n</code></pre>  </div></div>\n<h3 id=\"3-访问地址\">3. 访问地址：</h3>\n<p>http://127.0.0.1:4000/</p>\n\n<h2 id=\"三-jekyll配置本地启动手机访问\">三. jekyll配置本地启动手机访问</h2>\n\n<h3 id=\"1-查询的本地-ip-地址\">1. 查询的本地 IP 地址。</h3>\n<p>如果你使用的是 macOS 或 Linux 操作系统，可以打开终端（Terminal）应用，并输入以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ifconfig\n</code></pre>  </div></div>\n\n<p>如果你使用的是 Windows 操作系统，可以打开命令提示符（Command Prompt）应用，并输入以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ifconfig 在终端或命令提示符中，你应该可以看到一个名为 \"inet\" 或 \"IPv4 Address\" 的 IP 地址。这就是你的本地 IP 地址。\n</code></pre>  </div></div>\n\n<h3 id=\"2-配置-jekyll-以使用本地-ip-地址\">2. 配置 Jekyll 以使用本地 IP 地址。</h3>\n\n<p>在终端或命令提示符中，进入你的 Jekyll 站点所在的目录，并运行以下命令：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jekyll serve --host=0.0.0.0\n或\nbundle exec jekyll serve --host=0.0.0.0\n</code></pre>  </div></div>\n<p>这个命令会让 Jekyll 使用 0.0.0.0 这个特殊的 IP 地址，表示允许任何设备访问该站点。</p>\n\n<h3 id=\"3-访问\">3. 访问</h3>\n<p>在手机浏览器中输入你的本地 IP 地址，加上 Jekyll 默认的端口号 4000。\n在手机浏览器中输入以下网址：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>http://你的本地IP地址:4000\n</code></pre>  </div></div>\n<p>例如，如果你的本地 IP 地址是 192.168.0.100，那么你应该输入以下网址：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>http://192.168.0.100:4000\n</code></pre>  </div></div>\n\n<p>现在你应该可以在手机上访问你的 Jekyll 站点了。</p>\n\n<h2 id=\"四-jekyll其他常见问题\">四. jekyll其他常见问题</h2>\n\n<h3 id=\"1-重新安装gem\">1. 重新安装gem</h3>\n<p>如果在启动过程中出现报错，大概率是版本问题，如果是版本问题，则按照以下方式处理，如果是其他问题，则查看具体问题进行处理</p>\n\n<p>查看版本</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>bundle exec jekyll --version\n</code></pre>  </div></div>\n\n<p>更新Gemfile.lock 文件里的依赖</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 重新安装一遍\ngem install bundler jekyll\n\n# 更新所有的 gems\nbundle update\n\n# 测试\njekyll --version\n</code></pre>  </div></div>\n\n<p>重新使用启动命令进行启动：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jekyll serve 或 bundle exec jekyll serve\n</code></pre>  </div></div>\n<p>如果仍未解决，可以查看主题模板所需要的版本，重新安装。</p>\n\n<h3 id=\"2-后台启动\">2. 后台启动</h3>\n<p>“jekyll serve”命令启动如果终端关闭，进程就停止了，如果想要在后台启动，则需要更换其他命令。</p>\n\n<h4 id=\"控制台启动命令\">控制台启动命令</h4>\n<p>Auto-regeneration（自动再生成文件）: 开启。使用 <code class=\"language-plaintext highlighter-rouge\">--no-watch</code> 来关闭。</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jekyll serve\nbundle exec jekyll serve\n</code></pre>  </div></div>\n<h4 id=\"后台启动命令\">后台启动命令</h4>\n<p>功能和<code class=\"language-plaintext highlighter-rouge\">jekyll serve</code>命令相同，但是会脱离终端在后台运行</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jekyll serve --detach\n</code></pre>  </div></div>\n\n<p>如果你想关闭服务器，可以使用<code class=\"language-plaintext highlighter-rouge\">kill -9 1234</code>命令，”1234” 是进程号（PID）。\n如果你找不到进程号，那么就用<code class=\"language-plaintext highlighter-rouge\">ps aux | grep jekyll</code>命令来查看，然后关闭服务器</p>\n\n<h3 id=\"3-创建新主题博客\">3. 创建新主题博客</h3>\n<p>如果不想使用模板，可以自己创建一个jekyll主题。进入进文件夹，创建一个名为myblog的主题</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ jekyll new myblog\nor \n$ jekyll new . --force\n</code></pre>  </div></div>\n<p>创建好之后，可以进行自行开发完善</p>\n\n<h3 id=\"4-其他命令\">4. 其他命令</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># gem清单\ngem list\n# 删除Bundle的一个镜像源\n$ bundle config --delete 'mirror.https://rubygems.org'\n</code></pre>  </div></div>\n<p>其他更多命令，可以使用”gem help”命令查看</p>\n\n","dir":"/blog/development/html/webdesign/","name":"2023-04-24_1.md","path":"blog/development/html/webdesign/2023-04-24_1.md","url":"/blog/development/html/webdesign/2023-04-24_1.html"},{"sort":1,"layout":"default","title":"2023年计划考试时间(全年)","content":"<h1 id=\"2023年计划考试时间全年\">2023年计划考试时间(全年)</h1>\n\n<p>以下是根据网上信息整理的2023年考试日期安排，部分考试时间可能后续有变动，请及时关注！</p>\n<h2 id=\"2023年1月-\">2023年1月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1月7日-8日      2023年国家公务员考试\n1月7日-8日      自学考试\n1月7日-8日      教师资格考试\n1月1日-1月31日  全国消防操作员\n1月开始  \t\t 人力资源管理师（各地自定）\n</code></pre>  </div></div>\n\n<h2 id=\"2023年2月-\">2023年2月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>2月25日         公务员省考\n2月25-26日      基金从业（专场第1次）\n</code></pre>  </div></div>\n\n<h2 id=\"2023年3月-\">2023年3月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>3月11日         教师资格考试\n3月18日-19日    2022税务师（补考）\n3月18日-19日    公共英语\n3月25日-26日    2022执业药师（补考）\n3月25日-26日    2022一级消防（补考）\n3月25日-26日    2022一级建造师（补考）\n3月25日-27日    计算机等级考试\n3月-6月         专升本考试\n</code></pre>  </div></div>\n\n<h2 id=\"2023年4月-\">2023年4月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>4月8日-9日      2022经济师（补考）\n4月8日-9日      咨询工程师（投资）\n4月8日-9日      执业护士\n4月15日-16日    初级护师\n4月15日-16 日   卫生资格\n4月15日-16日    主管护师\n4月15日-16日    自学考试\n4月22日         专八考试\n4月22日-23日    2022一级造价（补考）\n4月22日-23日    卫生资格\n</code></pre>  </div></div>\n\n<h2 id=\"2023年5月-\">2023年5月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>5月13日         BEC初级\n5月13日-14日    监理工程师\n5月13日-14日    教师资格考试\n5月13日         会计（高级）\n5月13日-17日    会计（初级）\n5月20日         全国期货从业\n5月20日         演出经纪人员资格\n5月20日         BEC高级\n5月20日-21日    基金从业（统考第1次）\n5月27日         BEC中级\n5月27日-28日    计算机等级考试\n5月27日-28日    环境影响评价工程师\n5月27日-28日    房地产经纪人\n5月27日-28日    软件水平考试\n</code></pre>  </div></div>\n\n<h2 id=\"2023年6月-\">2023年6月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>6月3-4日        银行专业资格考试\n6月3-4日        证券从业资格考试\n6月3日起        执业医师考试\n6月7日-10日     高考\n6月10日         英语四级考试\n6月10日         英语六级考试\n6月10日-11日    注册计量师（一、二级）\n6月10日-11日    机动车检测维修工程师\n6月10日-11日    二级建造师\n6月10日-11日    社会工作者考试\n6月中下旬    \t考（各地不同）\n6月17日-18日    注册核安全工程师\n6月17日-18日    不动产登记代理人\n6月17日-18日    公路水运工程试验检测师\n6月17日-18日    2022勘察设计注册工程师（补考）\n6月18日         专四考试\n6月18日         高级经济师考试\n</code></pre>  </div></div>\n\n<h2 id=\"2023年7月-\">2023年7月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>7月1日-2日      自学考试\n7月1日-2日      专利代理师\n7月8日-9日      拍卖师（纸笔作答）\n7月16日         执业兽医\n7月29日-30日    基金从业（专场第2次）\n</code></pre>  </div></div>\n\n<h2 id=\"2023年8月-\">2023年8月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>8月18日-20日    执业医师考试（第一次笔试）\n8月25日-27日    注册会计师\n8月26日-27日    拍卖师（实际操作）\n</code></pre>  </div></div>\n\n<h2 id=\"2023年9月-\">2023年9月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>9月2日-3日      矿业权评估师\n9月9日-10日     一级建造师\n9月9日-11日     中级会计职称考试\n9月16日         教师资格考试\n9月16日         全国期货从业\n9月16日-17日    法律职业资格考试\n9月16日-17日    公共英语\n9月16日-17日    注册城乡规划师\n9月23日-24日    注册测绘师\n9月23日-24日    设备监理师\n9月23日-24日    资产评估师\n9月23日-24日    注册验船师\n9月23日-24日    文物保护工程从业资格\n9月23日-24日    广播电视播音员、主持人资格\n9月23日-25日    计算机等级考试\n9月24日         审计\n</code></pre>  </div></div>\n\n<h2 id=\"2023年10月-\">2023年10月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>10月14日        出版专业资格\n10月14日        通信\n10月14日-15日   注册建筑师（一、二级）\n10月15日        法律职业资格考试\n10月21日-22日   注册建筑师（一级）\n10月21日-22日   成人高考\n10月21日-22日   执业药师考试\n10月21日-25日   精算师\n10月28日-29日   银行专业资格考试\n10月28日-29日   房地产经纪人\n10月28日-29日   自学考试\n10月28日-29日   中级注册安全工程师\n10月28日-29日   一级造价工程师\n10月29日        统计\n</code></pre>  </div></div>\n\n<h2 id=\"2023年11月-\">2023年11月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>11月4日         新闻记者职业资格\n11月4日-5日     勘察设计注册工程师\n11月4日-5日     基金从业（专场第3次）\n11月4日-5日     一级消防工程师\n11月4日-5日     计算机技术与软件\n11月4日-5日     一、二、三级翻译资格\n11月11-12日     初级经济师\n11月11-12日     中级经济师\n11月11-12日     执业医师考试（第二次笔试）\n11月11-12日     房地产估价师\n11月18日        BEC高级\n11月18日-19日   税务师\n11月18日        全国期货从业\n11月25日        BEC初级\n11月25日        导游资格\n11月26日        2024国家公务员\n</code></pre>  </div></div>\n\n<h2 id=\"2023年12月-\">2023年12月 ：</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>12月2日-3日     计算机等级考试\n12月2日         BEC中级\n12月9日         英语四级考试\n12月9日         英语六级考试\n12月9日-10日    教师资格考试（面试）\n12月23日-25日   研究生考试\n</code></pre>  </div></div>\n","dir":"/blog/frontier/new/life/","name":"2023-04-23_1.md","path":"blog/frontier/new/life/2023-04-23_1.md","url":"/blog/frontier/new/life/2023-04-23_1.html"},{"sort":1,"permalink":"/blog/frontier/","layout":"default","title":"前沿","content":"<h1 id=\"前沿\">前沿</h1>\n<p>时代前沿</p>\n\n<ul>\n <li><a href=\"/blog/frontier/recommend/\">推荐</a>\n <ul>\n <li><a href=\"/blog/frontier/recommend/2023-04-27_1.html\">推荐几款好用的自用软件</a></li>\n <li><a href=\"/blog/frontier/recommend/2023-04-23_1.html\">Just My Socks 介绍，Just My Socks 是什么？</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/frontier/new/\">新闻</a>\n <ul>\n <li><a href=\"/blog/frontier/new/technology/\">科技</a>\n <ul>\n <li><a href=\"/blog/frontier/new/technology/2023-04-23_1.html\">ChatGpt</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/frontier/new/life/\">生活</a>\n <ul>\n <li><a href=\"/blog/frontier/new/life/2023-04-23_1.html\">2023年计划考试时间(全年)</a></li>\n </ul>\n </li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/frontier/","name":"README.md","path":"blog/frontier/README.md","url":"/blog/frontier/"},{"sort":1,"permalink":"/blog/development/tool/redis/","layout":"default","title":"Redis","content":"<h1 id=\"redis\">Redis</h1>\n\n<ul>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_1.html\">Windows部署redis集群模式</a></li>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_2.html\">redis如何设置密码</a></li>\n</ul>\n","dir":"/blog/development/tool/redis/","name":"README.md","path":"blog/development/tool/redis/README.md","url":"/blog/development/tool/redis/"},{"sort":1,"permalink":"/blog/development/interview/","layout":"default","title":"面试宝典","content":"<h1 id=\"面试宝典\">面试宝典</h1>\n\n<ul>\n <li><a href=\"/blog/development/interview/java/\">Java面试题</a>\n <ul>\n <li><a href=\"/blog/development/interview/java/2023-04-23_1.html\">Java面试宝典一(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_2.html\">Java面试宝典二(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_3.html\">Java面试宝典三(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_4.html\">Java面试宝典四(2023最新Java面试题)</a></li>\n </ul>\n </li>\n</ul>\n\n","dir":"/blog/development/interview/","name":"README.md","path":"blog/development/interview/README.md","url":"/blog/development/interview/"},{"sort":1,"layout":"default","title":"Java面试宝典一(2023最新Java面试题)","content":"<h1 id=\"java面试宝典一2023最新java面试题\">Java面试宝典一(2023最新Java面试题)</h1>\n\n<p>最近正在考虑找新工作，进行面试，但是工作时间比较久了，很多基础知识都很模糊，所以得复习下，顺便做下记录。</p>\n\n<p>包含Java基础相关的面试题，本文的宗旨是为读者朋友们整理一份详实而又准确的面试清单，下面一起进入主题吧</p>\n\n<p>本文分为十九个模块，分别是：<strong>「Java 基础、容器、多线程、反射、对象拷贝、Java Web 、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、MyBatis、RabbitMQ、Kafka、Zookeeper、MySQL、Redis、JVM」</strong></p>\n\n<h2 id=\"一-java-基础\">一. Java 基础</h2>\n\n<h3 id=\"1-jdk-和-jre-有什么区别\"><strong>1. JDK 和 JRE 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。\nJRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。\n</code></pre>  </div></div>\n\n<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p>\n\n<h3 id=\"2--和-equals-的区别是什么\"><strong>2. == 和 equals 的区别是什么？</strong></h3>\n\n<p><strong>「== 解读」</strong></p>\n\n<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>基本类型：比较的是值是否相同；\n引用类型：比较的是引用是否相同；\n</code></pre>  </div></div>\n\n<p>代码示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>String x = \"string\";\nString y = \"string\";\nString z = new String(\"string\");\nSystem.out.println(x==y); // true\nSystem.out.println(x==z); // false\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x.equals(z)); // true\n</code></pre>  </div></div>\n\n<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>\n\n<p><strong>「equals 解读」</strong></p>\n\n<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>\n\n<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>class Cat{    \n\tpublic Cat(String name){        \n\t\tthis.name = name;    \n\t}     \n\t\n\tprivate String name;\n\t\n\tpublic String getName(){        \n\t\treturn name;    \n\t}     \n\tpublic void setName(String name){        \n\t\tthis.name = name;    \n\t}\n} \n\nCat c1 = new Cat(\"王磊\");\nCat c2 = new Cat(\"王磊\");\nSystem.out.println(c1.equals(c2)); // false\n</code></pre>  </div></div>\n\n<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public boolean equals(Object obj){        \n\treturn (this == obj);\n}\n</code></pre>  </div></div>\n\n<p>原来 equals 本质上就是 ==。</p>\n\n<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>String s1 = new String(\"老王\");\nString s2 = new String(\"老王\");\nSystem.out.println(s1.equals(s2)); // true\n</code></pre>  </div></div>\n\n<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public boolean equals(Object anObject){    \n\tif (this == anObject) {        \n\t\treturn true;    \n\t}    \n\tif (anObject instanceof String) {        \n\t\tString anotherString = (String)anObject;        \n\t\tint n = value.length;        \n\t\tif (n == anotherString.value.length) {            \n\t\t\tchar v1[] = value;            \n\t\t\tchar v2[] = anotherString.value;            \n\t\t\tint i = 0;            \n\t\t\twhile (n-- != 0) {                \n\t\t\t\tif (v1[i] != v2[i])                    \n\t\t\t\treturn false;                \n\t\t\t\ti++;            \t\n\t\t\t}            \n\t\t\treturn true;        \n\t\t}    \n\t}    \n\treturn false;\n}\n</code></pre>  </div></div>\n\n<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>\n\n<p><strong>「总结」</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>\n\n<h3 id=\"3-两个对象的-hashcode-相同则-equals-也一定为-true对吗\"><strong>3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</strong></h3>\n\n<p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p>\n\n<p>代码示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>String str1 = \"通话\";\nString str2 = \"重地\";\nSystem.out.println(String.format(\"str1：%d | str2：%d\", str1.hashCode(), str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n</code></pre>  </div></div>\n\n<p>执行的结果：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>str1：1179395 | str2：1179395 false\n</code></pre>  </div></div>\n\n<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>\n\n<h3 id=\"4-final-在-java-中有什么作用\"><strong>4. final 在 Java 中有什么作用？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>final 修饰的类叫最终类，该类不能被继承。\nfinal 修饰的方法不能被重写。\nfinal 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n</code></pre>  </div></div>\n\n<h3 id=\"5-java-中的-math-round-1-5-等于多少\"><strong>5. Java 中的 Math. round(-1. 5) 等于多少？</strong></h3>\n\n<p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>\n\n<h3 id=\"6-string-属于基础的数据类型吗\"><strong>6. String 属于基础的数据类型吗？</strong></h3>\n\n<p>String 不属于基础类型，基础类型有 8 种：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>byte、boolean、char、short、int、float、long、double\n</code></pre>  </div></div>\n\n<p>而 String 属于对象。</p>\n\n<h3 id=\"7-java-中操作字符串都有哪些类它们之间有什么区别\"><strong>7. Java 中操作字符串都有哪些类？它们之间有什么区别？</strong></h3>\n\n<p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\n\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n</code></pre>  </div></div>\n\n<h3 id=\"8-string-stri与-string-strnew-stringi一样吗\"><strong>8. String str=”i”与 String str=new String(“i”)一样吗？</strong></h3>\n\n<p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>\n\n<h3 id=\"9-如何将字符串反转\"><strong>9. 如何将字符串反转？</strong></h3>\n\n<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>\n\n<p>示例代码：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// StringBuffer reverse\nStringBuffer stringBuffer = new StringBuffer();\nstringBuffer.append(\"abcdefg\");\nSystem.out.println(stringBuffer.reverse()); // gfedcba\n// StringBuilder reverse\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"abcdefg\");\nSystem.out.println(stringBuilder.reverse()); // gfedcba\n</code></pre>  </div></div>\n\n<h3 id=\"10-string-类的常用方法都有那些\"><strong>10. String 类的常用方法都有那些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>indexOf()：返回指定字符的索引。\ncharAt()：返回指定索引处的字符。\nreplace()：字符串替换。\ntrim()：去除字符串两端空白。\nsplit()：分割字符串，返回一个分割后的字符串数组。\ngetBytes()：返回字符串的 byte 类型数组。\nlength()：返回字符串长度。\ntoLowerCase()：将字符串转成小写字母。\ntoUpperCase()：将字符串转成大写字符。\nsubstring()：截取字符串。\nequals()：字符串比较。\n</code></pre>  </div></div>\n\n<h3 id=\"11-抽象类必须要有抽象方法吗\"><strong>11. 抽象类必须要有抽象方法吗？</strong></h3>\n\n<p>不需要，抽象类不一定非要有抽象方法。</p>\n\n<p>示例代码：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>abstract classCat{    \n\tpublicstaticvoidsayHi(){        \n\t\tSystem. out. println(\"hi~\");    \n\t}\n}\n</code></pre>  </div></div>\n\n<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>\n\n<h3 id=\"12-普通类和抽象类有哪些区别\"><strong>12. 普通类和抽象类有哪些区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>普通类不能包含抽象方法，抽象类可以包含抽象方法。\n抽象类不能直接实例化，普通类可以直接实例化。\n</code></pre>  </div></div>\n\n<h3 id=\"13-抽象类能使用-final-修饰吗\"><strong>13. 抽象类能使用 final 修饰吗？</strong></h3>\n\n<p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，编辑器也会提示错误信息：Illegal combination of modifiers: ‘abstract’ and ‘final’</p>\n\n<h3 id=\"14-接口和抽象类有什么区别\"><strong>14. 接口和抽象类有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n构造函数：抽象类可以有构造函数；接口不能有。\n实现数量：类可以实现很多个接口；但是只能继承一个抽象类。\n访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n</code></pre>  </div></div>\n\n<h3 id=\"15-java-中-io-流分为几种\"><strong>15. Java 中 IO 流分为几种？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>按功能来分：输入流（input）、输出流（output）。\n按类型来分：字节流和字符流。\n</code></pre>  </div></div>\n\n<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>\n\n<h3 id=\"16-bionioaio-有什么区别\"><strong>16. BIO、NIO、AIO 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\nNIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\nAIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n</code></pre>  </div></div>\n\n<h3 id=\"17-files的常用方法都有哪些\"><strong>17. Files的常用方法都有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Files.exists()：检测文件路径是否存在。\nFiles.createFile()：创建文件。\nFiles.createDirectory()：创建文件夹。\nFiles.delete()：删除一个文件或目录。\nFiles.copy()：复制文件。\nFiles.move()：移动文件。\nFiles.size()：查看文件个数。\nFiles.read()：读取文件。\nFiles.write()：写入文件。\n</code></pre>  </div></div>\n\n<h2 id=\"二-容器\">二. 容器</h2>\n\n<h3 id=\"1-java-容器都有哪些\"><strong>1. Java 容器都有哪些？</strong></h3>\n\n<p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Collection\n\tList\n\t\tArrayList\n\t\tLinkedList\n\t\tVector\n\t\tStack\n\tSet\n\t\tHashSet\n\t\tLinkedHashSet\n\t\tTreeSet\nMap\n\tHashMap\n\t\tLinkedHashMap\n\tTreeMap\n\tConcurrentHashMap\n\tHashtable\n</code></pre>  </div></div>\n\n<h3 id=\"2-collection-和-collections-有什么区别\"><strong>2. Collection 和 Collections 有什么区别？</strong></h3>\n\n<ul>\n <li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li>\n <li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法：Collections. sort(list)。</li>\n</ul>\n\n<h3 id=\"3-listsetmap-之间的区别是什么\"><strong>3. List、Set、Map 之间的区别是什么？</strong></h3>\n\n<p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>\n\n<p>三者之间的区别，如下表：\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230423195054min.png\" alt=\"微信截图_20230423195054min\" /></p>\n\n<h3 id=\"4-hashmap-和-hashtable-有什么区别\"><strong>4. HashMap 和 Hashtable 有什么区别？</strong></h3>\n\n<ul>\n <li>存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</li>\n <li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li>\n <li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>\n</ul>\n\n<h3 id=\"5-如何决定使用-hashmap-还是-treemap\"><strong>5. 如何决定使用 HashMap 还是 TreeMap？</strong></h3>\n\n<p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>\n\n<h3 id=\"6-说一下-hashmap-的实现原理\"><strong>6. 说一下 HashMap 的实现原理？</strong></h3>\n\n<p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>\n\n<h3 id=\"7-说一下-hashset-的实现原理\"><strong>7. 说一下 HashSet 的实现原理？</strong></h3>\n\n<p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>\n\n<h3 id=\"8-arraylist-和-linkedlist-的区别是什么\"><strong>8. ArrayList 和 LinkedList 的区别是什么？</strong></h3>\n\n<ul>\n <li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>\n <li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>\n <li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>\n</ul>\n\n<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>\n\n<h3 id=\"9-如何实现数组和-list-之间的转换\"><strong>9. 如何实现数组和 List 之间的转换？</strong></h3>\n\n<ul>\n <li>数组转 List：使用 Arrays.asList(array) 进行转换。</li>\n <li>List 转数组：使用 List 自带的 toArray() 方法。</li>\n</ul>\n\n<p>代码示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// list to array\nList&lt;String&gt; list = new ArrayList&lt;String&gt;();\nlist. add(\"王磊\");\nlist. add(\"的博客\");\nlist. toArray();\n// array to list\nString[] array = new String[]{\"王磊\",\"的博客\"};\nArrays. asList(array);\n</code></pre>  </div></div>\n\n<h3 id=\"10-arraylist-和-vector-的区别是什么\"><strong>10. ArrayList 和 Vector 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。\n性能：ArrayList 在性能方面要优于 Vector。\n扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。\n</code></pre>  </div></div>\n\n<h3 id=\"11-array-和-arraylist-有何区别\"><strong>11. Array 和 ArrayList 有何区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。\nArray 是指定固定大小的，而 ArrayList 大小是自动扩展的。\nArray 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。\n</code></pre>  </div></div>\n\n<h3 id=\"12-在-queue-中-poll和-remove有什么区别\"><strong>12. 在 Queue 中 poll()和 remove()有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>相同点：都是返回第一个元素，并在队列中删除返回的对象。\n不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。\n</code></pre>  </div></div>\n\n<p>代码示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();\nqueue.offer(\"string\"); // add\nSystem.out.println(queue.poll());\nSystem.out.println(queue.remove());\nSystem.out.println(queue.size());\n</code></pre>  </div></div>\n\n<h3 id=\"13-哪些集合类是线程安全的\"><strong>13. 哪些集合类是线程安全的？</strong></h3>\n\n<p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java.util.concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>\n\n<h3 id=\"14-迭代器-iterator-是什么\"><strong>14. 迭代器 Iterator 是什么？</strong></h3>\n\n<p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>\n\n<h3 id=\"15-iterator-怎么使用有什么特点\"><strong>15. Iterator 怎么使用？有什么特点？</strong></h3>\n\n<p>Iterator 使用代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nIterator&lt;String&gt; it = list. iterator();\nwhile(it. hasNext()){  \n\tString obj = it. next();  \n\tSystem. out. println(obj);\n}\n</code></pre>  </div></div>\n\n<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>\n\n<h3 id=\"16-iterator-和-listiterator-有什么区别\"><strong>16. Iterator 和 ListIterator 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。\nIterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。\nListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。\n</code></pre>  </div></div>\n\n<h3 id=\"17-怎么确保一个集合不能被修改\"><strong>17. 怎么确保一个集合不能被修改？</strong></h3>\n\n<p>可以使用 Collections.unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java.lang.UnsupportedOperationException 异常。</p>\n\n<p>示例代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist. add(\"x\");\nCollection&lt;String&gt; clist = Collections.unmodifiableCollection(list);\nclist. add(\"y\"); // 运行时此行报错\nSystem. out. println(list. size());\n</code></pre>  </div></div>\n\n<h2 id=\"三-多线程\">三. 多线程</h2>\n\n<h3 id=\"1-并行和并发有什么区别\"><strong>1. 并行和并发有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>并行：多个处理器或多核处理器同时处理多个任务。\n并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。 例如：\n\n并发 = 两个队列和一个售票员。\n并行 = 两个队列和两个售票员。\n</code></pre>  </div></div>\n\n<h3 id=\"2-线程和进程的区别\"><strong>2. 线程和进程的区别？</strong></h3>\n\n<p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>\n\n<h3 id=\"3-守护线程是什么\"><strong>3. 守护线程是什么？</strong></h3>\n\n<p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>\n\n<h3 id=\"4-创建线程有哪几种方式\"><strong>4. 创建线程有哪几种方式？</strong></h3>\n\n<p>创建线程有三种方式：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>继承 Thread 重写 run 方法；\n实现 Runnable 接口；\n实现 Callable 接口。\n</code></pre>  </div></div>\n\n<h3 id=\"5-说一下-runnable-和-callable-有什么区别\"><strong>5. 说一下 runnable 和 callable 有什么区别？</strong></h3>\n\n<p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p>\n\n<h3 id=\"6-线程有哪些状态\"><strong>6. 线程有哪些状态？</strong></h3>\n\n<p>线程的状态：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NEW 尚未启动\nRUNNABLE 正在执行中\nBLOCKED 阻塞的（被同步锁或者IO锁阻塞）\nWAITING 永久等待状态\nTIMED_WAITING 等待指定的时间重新被唤醒的状态\nTERMINATED 执行完成\n</code></pre>  </div></div>\n\n<h3 id=\"7-sleep-和-wait-有什么区别\"><strong>7. sleep() 和 wait() 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>类的不同：sleep() 来自 Thread，wait() 来自 Object。\n释放锁：sleep() 不释放锁；wait() 释放锁。\n用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。\n</code></pre>  </div></div>\n\n<h3 id=\"8-notify和-notifyall有什么区别\"><strong>8. notify()和 notifyAll()有什么区别？</strong></h3>\n\n<p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。</p>\n\n<p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。</p>\n\n<p>而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>\n\n<h3 id=\"9-线程的-run-和-start-有什么区别\"><strong>9. 线程的 run() 和 start() 有什么区别？</strong></h3>\n\n<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>\n\n<h3 id=\"10-创建线程池有哪几种方式\"><strong>10. 创建线程池有哪几种方式？</strong></h3>\n\n<p>线程池创建有七种方式，最核心的是最后一种：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；\n\nnewCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；\n\nnewFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；\n\nnewSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；\n\nnewScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；\n\nnewWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；\n\nThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。\n</code></pre>  </div></div>\n\n<h3 id=\"11-线程池都有哪些状态\"><strong>11. 线程池都有哪些状态？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。\nSHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。\nSTOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。\nTIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。\nTERMINATED：terminated()方法结束后，线程池的状态就会变成这个。\n</code></pre>  </div></div>\n\n<h3 id=\"12-线程池中-submit-和-execute-方法有什么区别\"><strong>12. 线程池中 submit() 和 execute() 方法有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>execute()：只能执行 Runnable 类型的任务。\nsubmit()：可以执行 Runnable 和 Callable 类型的任务。\n</code></pre>  </div></div>\n\n<p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p>\n\n<h3 id=\"13-在-java-程序中怎么保证多线程的运行安全\"><strong>13. 在 Java 程序中怎么保证多线程的运行安全？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>方法一：使用安全类，比如 Java. util. concurrent 下的类。\n方法二：使用自动锁 synchronized。\n方法三：使用手动锁 Lock。\n</code></pre>  </div></div>\n\n<p>手动锁 Java 示例代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Lock lock = new ReentrantLock();\nlock.lock();\ntry {    \n\tSystem. out. println(\"获得锁\");\n} catch (Exception e) {    \n\t// TODO: handle exception\n} finally {    \n\tSystem. out. println(\"释放锁\");    \n\tlock. unlock();\n}\n</code></pre>  </div></div>\n\n<h3 id=\"14-多线程中-synchronized-锁升级的原理是什么\"><strong>14. 多线程中 synchronized 锁升级的原理是什么？</strong></h3>\n\n<p><strong>synchronized 锁升级原理</strong>：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>\n\n<p><strong>锁的升级的目的</strong>：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>\n\n<h3 id=\"15-什么是死锁\"><strong>15. 什么是死锁？</strong></h3>\n\n<p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>\n\n<h3 id=\"16-怎么防止死锁\"><strong>16. 怎么防止死锁？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。\n尽量使用 Java. util. concurrent 并发类代替自己手写锁。\n尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。\n尽量减少同步的代码块。\n</code></pre>  </div></div>\n\n<h3 id=\"17-threadlocal-是什么有哪些使用场景\"><strong>17. ThreadLocal 是什么？有哪些使用场景？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。\nThreadLocal 的经典使用场景是数据库连接和 session 管理等。\n</code></pre>  </div></div>\n\n<h3 id=\"18-说一下-synchronized-底层实现原理\"><strong>18. 说一下 synchronized 底层实现原理？</strong></h3>\n\n<p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>\n\n<h3 id=\"19-synchronized-和-volatile-的区别是什么\"><strong>19. synchronized 和 volatile 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。\nvolatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。\nvolatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\n</code></pre>  </div></div>\n\n<h3 id=\"20-synchronized-和-lock-有什么区别\"><strong>20. synchronized 和 Lock 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。\nsynchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\n</code></pre>  </div></div>\n\n<h3 id=\"21-synchronized-和-reentrantlock-区别是什么\"><strong>21. synchronized 和 ReentrantLock 区别是什么？</strong></h3>\n\n<p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。\n主要区别如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；\nReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；\nReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。\n</code></pre>  </div></div>\n\n<h3 id=\"22-说一下-atomic-的原理\"><strong>22. 说一下 atomic 的原理？</strong></h3>\n\n<p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>\n\n<h2 id=\"四-反射\">四. 反射</h2>\n\n<h3 id=\"1-什么是反射\"><strong>1. 什么是反射？</strong></h3>\n\n<p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>\n\n<h3 id=\"2-什么是-java-序列化什么情况下需要序列化\"><strong>2. 什么是 Java 序列化？什么情况下需要序列化？</strong></h3>\n\n<p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。\n以下情况需要使用 Java 序列化：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>想把的内存中的对象状态保存到一个文件中或者数据库中时候；\n想用套接字在网络上传送对象的时候；\n想通过RMI（远程方法调用）传输对象的时候。\n</code></pre>  </div></div>\n\n<h3 id=\"3-动态代理是什么有哪些应用\"><strong>3. 动态代理是什么？有哪些应用？</strong></h3>\n\n<p>动态代理是运行时动态生成代理类。</p>\n\n<p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>\n\n<h3 id=\"4-怎么实现动态代理\"><strong>4. 怎么实现动态代理？</strong></h3>\n\n<p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>\n\n<h2 id=\"五-对象拷贝\">五. 对象拷贝</h2>\n\n<h3 id=\"1-为什么要使用克隆\"><strong>1. 为什么要使用克隆？</strong></h3>\n\n<p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p>\n\n<h3 id=\"2-如何实现对象克隆\"><strong>2. 如何实现对象克隆？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。\n实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。\n</code></pre>  </div></div>\n\n<h3 id=\"3-深拷贝和浅拷贝区别是什么\"><strong>3. 深拷贝和浅拷贝区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。\n深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。\n</code></pre>  </div></div>\n","dir":"/blog/development/interview/java/","name":"2023-04-23_1.md","path":"blog/development/interview/java/2023-04-23_1.md","url":"/blog/development/interview/java/2023-04-23_1.html"},{"sort":1,"layout":"default","title":"Windows部署redis集群模式","content":"<h1 id=\"windows部署redis集群模式\">Windows部署redis集群模式</h1>\n\n<h2 id=\"安装环境\">安装环境</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>操作系统： win7\nredis版本：redis-5.0.10\n</code></pre>  </div></div>\n\n<h2 id=\"安装包\">安装包</h2>\n\n<p>redis官方没有Windows版本安装包，需在开源的GitHub下载</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>下载地址：https://github.com/tporadowski/redis/releases\n安装包：Redis-x64-5.0.10.zip\n</code></pre>  </div></div>\n\n<p>redis集群模式至少需要3主3从共集成6个redis节点</p>\n\n<p>在D盘创建redis集群目录redis-cluster，下载安装包后解压到该目录并复制5次，分别重命名为 redis-7001 至 redis-7006</p>\n\n<h2 id=\"配置文件\">配置文件</h2>\n\n<p>修改所有redis目录下的配置文件：redis.windows.conf</p>\n\n<blockquote>\n <p>注意：不同节点的端口号和集群配置文件不同，其他配置都相同</p>\n\n <p>端口号：将各个节点端口号分别修改为7001-7006</p>\n\n <p>集群配置文件：将文件名后面的6379改成各自节点的端口号</p>\n</blockquote>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 修改绑定IP，支持远程登录\nbind 0.0.0.0 \n# 修改端口号，将各个节点端口号分别修改为7001-7006\nport 7001 # 修改密码，6个节点的密码必须一致\n# 不设置密码也可以，登录时不需要密码\nrequirepass 123456 \n# 修改所属主节点密码\n# 若未设置密码则不需要修改\nmasterauth 123456 \n# 开启集群模式\ncluster-enabled yes \n# 集群超时配置\ncluster-node-timeout 15000 \n# 集群配置文件\n# 集群部署成功后会在该redis目录生成该文件\ncluster-config-file nodes-7001.conf \n# 开启AOF持久化\n# redis默认使用RDB持久化，将该配置修改为yes则使用AOF持久化\nappendonly yes\n</code></pre>  </div></div>\n\n<h2 id=\"启动脚本\">启动脚本</h2>\n\n<h3 id=\"一个文件\">一个文件</h3>\n<p>建立名字为<strong>RedisCluster.bat</strong>的脚本文件，后缀是bat。将下面内容复制进去，一次性全部启动起来。\n将路径改为redis位置的真实路径。</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>start \"Redis7001\" cmd  /c \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7001&amp;&amp;redis-server.exe redis.windows-service.conf\"\n\nstart \"Redis7002\" cmd  /k \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7002&amp;&amp;redis-server.exe redis.windows-service.conf\"\n\nstart \"Redis7003\" cmd  /k \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7003&amp;&amp;redis-server.exe redis.windows-service.conf\"\n\nstart \"Redis7004\" cmd  /k \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7004&amp;&amp;redis-server.exe redis.windows-service.conf\"\n\nstart \"Redis7005\" cmd  /k \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7005&amp;&amp;redis-server.exe redis.windows-service.conf\"\n\nstart \"Redis7006\" cmd  /k \"cd /d D:\\File\\Apache\\Redis\\cluster\\Redis-7006&amp;&amp;redis-server.exe redis.windows-service.conf\"\n</code></pre>  </div></div>\n<h3 id=\"分多个文件\">分多个文件</h3>\n\n<p>直接在redis-cluster目录下创建6个bat脚本，以 start-7001.bat 至 start-7006命名，分别启动6个redis节点\n。</p>\n\n<p>start-7001.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7001 cd ./redis-7001redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<p>start-7002.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7002 cd ./redis-7002redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<p>start-7003.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7003 cd ./redis-7003redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<p>start-7004.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7004 cd ./redis-7004redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<p>start-7005.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7005 cd ./redis-7005redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<p>start-7006.bat</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>title redis-cluster-7006 cd ./redis-7006redis-server redis.windows.conf\n</code></pre>  </div></div>\n\n<hr />\n\n<h2 id=\"创建集群\">创建集群</h2>\n\n<p>首先双击6个bat脚本启动所有redis节点</p>\n\n<p>然后到任意一个节点的reids目录下，启动cmd控制台。使用下面命令创建集群：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 无密码创建集群命令\nredis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 \n# 有密码创建集群命令\nredis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1   -a 123456\n</code></pre>  </div></div>\n\n<p>执行该命令后提示：Can I set the above configuration? (type ‘yes’ to accept): </p>\n\n<p>输入yes，回车，redis集群创建成功，各个redis节点下面会生成集群配置文件，如：nodes-7001.conf，nodes-7002.conf</p>\n\n<p>所有redis节点关闭后重新启动，无需再执行该命令创建集群</p>\n\n<h2 id=\"登录\">登录</h2>\n\n<p>登录redis集群的任意一个节点即可<br />\n一定要加上-c，不然使用get等命令时节点之间是无法自动跳转的</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 无密码登录\nredis-cli -c -h 127.0.0.1 -p 7001 \n# 密码登录\nredis-cli -c -h 127.0.0.1 -p 7001 -a 123456\n</code></pre>  </div></div>\n\n<p>cluster集群命令</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code># 查看当前节点信息\ncluster info \n# 查看当前集群信息\ncluster nodes\n</code></pre>  </div></div>\n","dir":"/blog/development/tool/redis/","name":"2023-04-30_1.md","path":"blog/development/tool/redis/2023-04-30_1.md","url":"/blog/development/tool/redis/2023-04-30_1.html"},{"sort":1,"layout":"default","title":"Maven推送本地jar包到仓库","content":"<h1 id=\"maven推送本地jar包到仓库\">Maven推送本地jar包到仓库</h1>\n<h2 id=\"一-maven推送本地jar包到仓库通用方式\">一. Maven推送本地jar包到仓库(通用方式)</h2>\n<p>要将本地的 JAR 包推送到 Maven 仓库，可以使用 Maven 的 deploy:deploy-file 插件目标。以下是推送本地 JAR 包到 Maven 仓库的通用方式，步骤：</p>\n\n<p><strong>第一步：</strong>在 Maven 项目的根目录下，打开终端或命令行窗口。</p>\n\n<p><strong>第二步：</strong>运行以下 Maven 命令，将 JAR 包推送到仓库：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mvn deploy:deploy-file -DgroupId=&lt;groupId&gt; -DartifactId=&lt;artifactId&gt; -Dversion=&lt;version&gt; -Dpackaging=jar -Dfile=&lt;path-to-jar&gt; -Durl=&lt;repository-url&gt; -DrepositoryId=&lt;repository-id&gt;\n</code></pre>  </div></div>\n<p>具体参数含义：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;groupId&gt;：项目的 Group ID。\n&lt;artifactId&gt;：项目的 Artifact ID。\n&lt;version&gt;：项目的版本号。\n&lt;path-to-jar&gt;：本地 JAR 包的路径。\n&lt;repository-url&gt;：Maven 仓库的 URL。\n&lt;repository-id&gt;：Maven 仓库的 ID。 根据实际情况替换上述命令中的占位符（\\&lt;groupId&gt;、\\&lt;artifactId&gt;、\\&lt;version&gt;、\\&lt;path-to-jar&gt;、\\&lt;repository-url&gt;、\\&lt;repository-id&gt;）为相应的值。\n</code></pre>  </div></div>\n\n<p><strong>第三步：</strong>运行命令后，Maven 将会将本地的 JAR 包推送到指定的 Maven 仓库。</p>\n\n<p>确保在运行命令之前已经正确配置了 Maven 的 settings.xml 文件中的 <servers> 部分，其中包含仓库的认证凭据（用户名和密码）。</servers></p>\n\n<p>注意：推送 JAR 包到远程 Maven 仓库需要有相应的权限和认证凭据。如果没有访问远程仓库的权限，可以考虑将 JAR 包安装到本地仓库（使用 mvn install:install-file 插件目标），或者搭建私有 Maven 仓库。</p>\n\n<h2 id=\"二-maven推送本地jar包到远程仓库\">二. Maven推送本地jar包到远程仓库</h2>\n\n<p>需要将功能打成打包推上远程nexus仓库,具体推送及操作记录一下：</p>\n\n<h3 id=\"1-配置pomxml\">1. 配置pom.xml</h3>\n<p>在pom文件中添加远程仓库的地址和id.名称可以不需要.当然具体根据实际操作.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!--配置远程仓库地址--&gt;\n&lt;distributionManagement&gt;\n\t\t&lt;repository&gt;\n\t\t\t&lt;id&gt;ceshi-id&lt;/id&gt;\n\t\t\t&lt;name&gt;名称&lt;/name&gt;\n\t\t\t&lt;url&gt;http://xxx.xxx.x.xx:8081/repository/ceshi-id/&lt;/url&gt;\n\t\t&lt;/repository&gt;\n\t&lt;/distributionManagement&gt;\n</code></pre>  </div></div>\n\n<h3 id=\"2-配置maven的settingxml\">2. 配置Maven的setting.xml</h3>\n\n<p>在maven配置文件中配置远程仓库的账号密码,id和pom文件中的必须一致.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;servers&gt;\n        &lt;server&gt;\n            &lt;id&gt;ceshi-id&lt;/id&gt;\n            &lt;username&gt;用户名&lt;/username&gt;\n            &lt;password&gt;密码&lt;/password&gt;\n        &lt;/server&gt;\n    &lt;/servers&gt;\n</code></pre>  </div></div>\n\n<h3 id=\"3-打包并推送到远程仓库\">3. 打包并推送到远程仓库</h3>\n<p>使用以下命令进行推送</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>maven clean deploy\n</code></pre>  </div></div>\n<p>如果使用IDE,右侧可以直接点击命令\n或者可以直接在命令栏使用命令推送.\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230428114825min.png\" alt=\"微信截图_20230428114825min\" /></p>\n\n<h2 id=\"maven的三个常用打包启动相关命令\">Maven的三个常用打包启动相关命令</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mvn clean package\n</code></pre>  </div></div>\n\n<p>依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等7个阶段。</p>\n\n<p>package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mvn clean install\n</code></pre>  </div></div>\n\n<p>依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install等8个阶段。</p>\n\n<p>install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>mvn clean deploy\n</code></pre>  </div></div>\n\n<p>依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy等9个阶段。</p>\n\n<p>deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库</p>\n\n<h3 id=\"其他maven命令\">其他maven命令:</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>编译：mvn compile\n清理：mvn clean\n测试：mvn test\n打包：mvn package\n安装到repository：mvn install(具有编译和打包的功能)\n部署到tomcat：mvn deploy\n</code></pre>  </div></div>\n\n","dir":"/blog/development/tool/maven/","name":"2023-04-27_1.md","path":"blog/development/tool/maven/2023-04-27_1.md","url":"/blog/development/tool/maven/2023-04-27_1.html"},{"sort":1,"permalink":"/blog/development/tool/git/","layout":"default","title":"Git","content":"<h1 id=\"git\">Git</h1>\n\n<ul>\n <li><a href=\"/blog/development/tool/git/2023-04-27_1.html\">最新Github创建仓库,将项目上传到GitHub</a></li>\n <li><a href=\"/blog/development/tool/git/2023-04-28_1.html\">Git一份代码同时提交两个Git仓库</a></li>\n <li><a href=\"/blog/development/tool/git/2023-05-12_1.html\">Git常用操作命令</a></li>\n</ul>\n","dir":"/blog/development/tool/git/","name":"README.md","path":"blog/development/tool/git/README.md","url":"/blog/development/tool/git/"},{"sort":1,"layout":"default","title":"最新Github创建仓库,将项目上传到GitHub","content":"<h1 id=\"最新github创建仓库将项目上传到github\">最新Github创建仓库,将项目上传到GitHub</h1>\n<blockquote>\n <p>最近进行项目学习,想将代码放在GitHub上,但是找了多个攻略,都不全,因此自己制作一份,将创建仓库的过程记录下来,大家共同学习下.适合新手,有什么问题可以在底下指出,</p>\n</blockquote>\n\n<h2 id=\"一登录github创建仓库\">一.登录GitHub,创建仓库</h2>\n<p>GitHub账号应该都有的,如果没有,可以上<a href=\"https://github.com/\">https://github.com/</a> 进行账号注册,这个就不细说了.下面上干货.</p>\n<h3 id=\"1创建新仓库\">1.创建新仓库</h3>\n<p>点击右上角的+号,选择创建新仓库</p>\n\n<h3 id=\"2填写仓库详细信息\">2.填写仓库详细信息</h3>\n<p>按照图片上注释写就ok,所有填完,点最底下的创建就好了</p>\n\n<h3 id=\"3看完成后的仓库结构\">3.看完成后的仓库结构</h3>\n<p>此处我创建的仓库交JPA-demo,因为是学习jpa做的小demo.因此名字和项目名统一.\n创建后的项目中有两个文件LICENSE和README\n没有的小伙伴看下上一步填写信息时是不是忘了勾选什么.</p>\n\n<h2 id=\"二将本地项目上传github\">二.将本地项目上传GitHub</h2>\n\n<blockquote>\n <p>注意:这里默认本地已经安装好Git了,如果没有安装的小伙伴点击<a href=\"http://git-scm.com/download/\">http://git-scm.com/download/</a>根据自己电脑的进行下载\n或者使用我这里提供的win10 64的版本:</p>\n</blockquote>\n\n<p>链接：https://pan.baidu.com/s/1Ms3Qn4Z4Z5tDMh2ajSjISw 提取码：i0w7</p>\n\n<p>安装步骤很简单,全都默认就可以了\n安装完,打开Git Bash 将用户名和邮箱设置下</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ git config  –global  user.name  \"用户名\"\n$ git config  –global  user.email  \"邮箱\"\n</code></pre>  </div></div>\n\n<h3 id=\"1在本地项目中打开git-bash\">1.在本地项目中打开Git Bash</h3>\n\n<p>比如此处我向上传bbs项目,在bbs项目中打开</p>\n\n<h3 id=\"2按照以下命令一条一条输入\">2.按照以下命令一条一条输入</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. git init //把这个目录变成Git可以管理的仓库\n\n2.  git add . //不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 \n\n3. git commit -m \"first commit\" //把文件提交到仓库的信息\n\n4. git remote add origin  克隆的地址use shh的 //关联远程仓库\n\n5 .git push -u origin master //把本地库的所有内容推送到远程库上\n</code></pre>  </div></div>\n\n<p>这里可能有点问题,在输入第五步时报权限不足</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Warning: Permanently added 'github.com,13.229.188.59' (RSA) to the list of known hosts.\nAgent admitted failure to sign using the key.\nPermission denied (publickey).\nfatal: Could not read from remote repository.\n</code></pre>  </div></div>\n\n<p>最后查找了下,是因为没有在GitHub上配置密钥的原因.\n以下解决步骤:</p>\n\n<p>1.打开.ssh文件夹,一般在C盘的用户下的用户名下\n看里面除了known_hosts 文件,是否还有其他文件,若没有,则代表你没有生成密钥,有的话最好重新生成下,不确定存在的能不能用.</p>\n\n<p>2.生成密钥\n在此文件夹下,打开Git Bash, 运行命令</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ssh-keygen -t rsa -C “你的邮箱”\n</code></pre>  </div></div>\n\n<p>会生成id_rsa 和 id_rsa_pub,这代表这密钥已经生成</p>\n\n<p>3.将公共密钥复制到GitHub\n以记事本的格式打开id_rsa_pub\n将其中的内容复制到</p>\n\n<p>打开</p>\n\n<p>创建新密钥</p>\n\n<p>名字就起项目名,复制的东西放入底下的那个框中,完成.</p>\n\n<p>回到刚才命令的第五步,重新进行第五步,发现报错</p>\n\n<p>使用</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git pull --rebase origin master 该命令的意思是把远程库中的更新合并到（pull=fetch+merge）本地库中，–-rebase的作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中 然后重新进行第五步,完成\n</code></pre>  </div></div>\n\n","dir":"/blog/development/tool/git/","name":"2023-04-27_1.md","path":"blog/development/tool/git/2023-04-27_1.md","url":"/blog/development/tool/git/2023-04-27_1.html"},{"sort":1,"layout":"default","title":"Django中url与path及re_path区别","content":"<h1 id=\"django中url与path及re_path区别\">Django中url与path及re_path区别</h1>\n<p>一般不能分清两者的区别,所这简单介绍下两者.首先,url是Django 1.x中的写法,p在Django2.1中，开始舍弃django1.x中的url写法。在django2.x中，描写url配置的有两个函数path和re_path.re_path()函数可以看做是django 1.x中得url函数,即可以在路径中使用正则.</p>\n\n<h2 id=\"一path和url的区别\">一.path和url的区别：</h2>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>django.urls path\ndjango.conf.urls url\n</code></pre>  </div></div>\n\n<p>path与url是两个不同的模块,效果都是响应返回页面, path调用的是python第三方模块或框架,而url则是自定义的模块,如Views下的def函数对应你url中的参数值.</p>\n\n<p>例如:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>url(r'^login',views.login)，\ndef login(request):\n    return render(request,'login.html')\n</code></pre>  </div></div>\n<h3 id=\"1-url旧版本使用\">1. url（旧版本使用）</h3>\n<p>在settings.py文件中有一个ROOT_URLCONF设置，设置的是在访问网址时通过哪一个url文件去匹配所请求的网址</p>\n\n<h4 id=\"url参数\">url参数</h4>\n<p>url或者re_path要复杂一些 （r’^blog/(?P[0-9]{4})/′）首先需要开始符和结尾符 '） 首先需要开始符^和结尾符 ′）首先需要开始符和结尾符,参数匹配一个 （）就是一个匹配参数，\n(?P<匹配的字段名>正则表达式)</匹配的字段名></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>用法：url(regex, view, kwargs=None, name=None)\n正则表达式：使用正则表达式进行URL匹配。\n参数 regex：指定要匹配的URL模式，可以使用正则表达式。\n参数 view：指定要调用的视图函数或处理程序。\n参数 kwargs：一个可选的关键字参数字典，用于传递额外的参数给视图函数或处理程序。\n参数 name：一个可选的URL名称，用于在模板中引用该URL。\n</code></pre>  </div></div>\n\n<p>进行匹配是不包括get或者post请求方式的参数及域名比如<a href=\"www.qq.com/blog?num=1\">www.qq.com/blog?num=1</a>并不会匹配？后边的字符</p>\n\n<p>可以给request参数设置一个默认值,最常见的分页url，比如</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    urlpatterns=[\n          url(r'^page/$',views.page),\n          url(r'^page(?P&lt;num&gt;[0-9]+)$',views.page)\n    ]\n    \n    #views\n    \n    def page(request,num='1'):\n         pass\n</code></pre>  </div></div>\n\n<p>自定义错误页面关键字handler400=blog.views.page_no_find</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    #urls.py\n    …\n    handler400=blog.views.page_no_find\n</code></pre>  </div></div>\n\n<h3 id=\"2path\">2、path</h3>\n<p>参数的使用方法path(‘blog/str:string/’) 简单了很多，就是尖括号，前边是str代表参数的类型，后面代表参数的名称</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>用法：path(route, view, kwargs=None, name=None)\n路径匹配：使用路径匹配规则进行URL匹配。\n参数 route：指定要匹配的URL模式，以字符串形式表示，不使用正则表达式。\n参数 view：指定要调用的视图函数或处理程序。\n参数 kwargs：一个可选的关键字参数字典，用于传递额外的参数给视图函数或处理程序。\n参数 name：一个可选的URL名称，用于在模板中引用该URL。\n</code></pre>  </div></div>\n\n<h4 id=\"path参数类型\">path参数类型</h4>\n<p>捕获url中的参数需要用到尖括号&lt;&gt; 指定尖括号中的值类型比如int:astr:link这个转换器还有许多类型比如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>int 匹配0和正整数\nstr 匹配任何空字符串但不包括/\nslug 可理解为注释 匹配任何ascii码包括连接线和下划线\nuuid 匹配一个uuid对象（该对象必须包括破折号—，所有字母必须小写）\npath 匹配所有的字符串 包括/（意思就是path前边和后边的所有）\n</code></pre>  </div></div>\n\n<h3 id=\"3re_path\">3.re_path</h3>\n<p>如果遇上路径和转换器语法都不足以定义的URL模式，那么就需要使用正则表达式，这时候就需要使用re_path()，而非path()。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>用法：re_path(regex, view, kwargs=None, name=None)\n正则表达式：使用正则表达式进行URL匹配，与 url 函数类似。\n参数 regex：指定要匹配的URL模式，可以使用正则表达式。\n参数 view：指定要调用的视图函数或处理程序。\n参数 kwargs：一个可选的关键字参数字典，用于传递额外的参数给视图函数或处理程序。\n参数 name：一个可选的URL名称，用于在模板中引用该URL。\n</code></pre>  </div></div>\n\n<p>举例：传递 数字结尾的参数</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    re_path(r'(\\d+)/$',views.peopleList,name='peopleList'),\n</code></pre>  </div></div>\n\n<h3 id=\"总结\">总结</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>url 使用正则表达式进行URL匹配，是较旧的方式。\npath 使用路径匹配规则进行URL匹配，是较新的方式。\nre_path 与 url 类似，也使用正则表达式进行URL匹配。 从Django 3.1版本开始，推荐使用 path 函数进行URL路由，因为它提供了更简单和更直观的语法。但是，如果需要更复杂的URL匹配，仍可以使用 re_path 或 url 函数。\n</code></pre>  </div></div>\n\n<h2 id=\"二python3中使用django2常见设置path问题\">二、python3中使用django2,常见设置path问题</h2>\n<h3 id=\"1django2中使用\">1.Django2中使用</h3>\n<p>在python3中使用django2的时候，在设置urls的时候，会遇到一些坑。这里做一下记录。\n系统的urls.py里，在1.X的时候，都是采用的url方式。如下</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    url(r'^', include(\"test1.urls\")),\n</code></pre>  </div></div>\n\n<p>在2.0中，它推荐使用的是path模块，所以这里就改写一下。引包</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    from django.urls import path\n    \n    path('', include(\"test1.urls\")),\n</code></pre>  </div></div>\n\n<p>注意:</p>\n<blockquote>\n <p>如果要使用正则，则要引入re_path，from django.urls import path, re_path\n这里面的正则写法，有点意思，一定要使用（）把正则包起来，然后用?P正式表达式 这种形式来表式</p>\n</blockquote>\n\n<h3 id=\"2app中使用path\">2.APP中使用path</h3>\n<p>1.x里面的写法是</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    url(r’^page=(\\d+)&amp;key=(\\w+)$’, views.detail, name=”detail”),\n</code></pre>  </div></div>\n<p>现在的写法</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    re_path('page=(?P&lt;page&gt;\\d+)&amp;key=(?P&lt;key&gt;\\w+)', views.detail, name=\"detail\"),\n</code></pre>  </div></div>\n<p>这样一对比就能明白了吧,使用的链接是http://127.0.0.1:8000/page=12&amp;key=abc</p>\n\n<h3 id=\"3系统的urlspy里的namespace的问题\">3.系统的urls.py里的namespace的问题</h3>\n<p>1.x中写法</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    url(r'^', include(\"test1.urls\", namespace='test1')),\n</code></pre>  </div></div>\n\n<p>可是在2.0中你这么写，会报错，说什么app_name的，这个自己可以看一下，怎么解决呢，其实很简单，只要在自己项目urls.py中加上这句就行了.如果不加的话可能报错,</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    app_name = 'test1'(你的APP名)\n</code></pre>  </div></div>\n\n<p>注:</p>\n<blockquote>\n <div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>使用url也是可以的,为了简便起见,尽量使用符合版本的字段,另外在写路径时应该严格按照语法,比如'^' 和/$就不能缺,不能前面写url,括号里面确按照path的写法,这样很容易出错,到了关键时刻,很难定位问题点,很浪费时间.\n</code></pre>  </div> </div>\n</blockquote>\n","dir":"/blog/development/python/django/","name":"2023-04-27_1.md","path":"blog/development/python/django/2023-04-27_1.md","url":"/blog/development/python/django/2023-04-27_1.html"},{"sort":1,"layout":"default","title":"Java中map常见操作集合","content":"<h1 id=\"java中map常见操作集合\">Java中map常见操作集合</h1>\n\n<h2 id=\"一-java中遍历map的几种常见方式\">一. Java中遍历Map的几种常见方式</h2>\n\n<p>在Java中，可以使用不同的方式来遍历Map，以下是常见的几种方式：</p>\n\n<h3 id=\"方式一使用迭代器遍历map\">方式一.使用迭代器遍历Map</h3>\n<p>使用Map.Entry对象的迭代器来遍历Map中的键值对，示例代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", 1);\nmap.put(\"B\", 2);\nmap.put(\"C\", 3);\n\nIterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = map.entrySet().iterator();\nwhile (iterator.hasNext()) {\n    Map.Entry&lt;String, Integer&gt; entry = iterator.next();\n    String key = entry.getKey();\n    Integer value = entry.getValue();\n    System.out.println(key + \": \" + value);\n}\n</code></pre>  </div></div>\n\n<h3 id=\"方式二使用foreach循环遍历map\">方式二.使用foreach循环遍历Map</h3>\n<p>使用foreach循环遍历Map中的键值对，示例代码如下：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", 1);\nmap.put(\"B\", 2);\nmap.put(\"C\", 3);\n\nfor (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {\n    String key = entry.getKey();\n    Integer value = entry.getValue();\n    System.out.println(key + \": \" + value);\n}\n</code></pre>  </div></div>\n\n<h3 id=\"方式三使用lambda表达式和stream-api遍历map\">方式三.使用Lambda表达式和Stream API遍历Map</h3>\n<p>使用Lambda表达式和Stream API遍历Map中的键值对，示例代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", 1);\nmap.put(\"B\", 2);\nmap.put(\"C\", 3);\n\nmap.entrySet().stream().forEach(entry -&gt; {\n    String key = entry.getKey();\n    Integer value = entry.getValue();\n    System.out.println(key + \": \" + value);\n});\n</code></pre>  </div></div>\n\n<h3 id=\"方式四使用java-8中的foreach方法遍历map\">方式四.使用Java 8中的forEach()方法遍历Map</h3>\n<p>使用Java 8中的forEach()方法遍历Map中的键值对，示例代码如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\nmap.put(\"A\", 1);\nmap.put(\"B\", 2);\nmap.put(\"C\", 3);\n\nmap.forEach((key, value) -&gt; System.out.println(key + \": \" + value));\n</code></pre>  </div></div>\n\n<p>需要注意的是，以上方式都是遍历Map中的键值对，如果只需要遍历Map中的键或值，也可以使用keySet()或values()方法来获取相应的集合，然后使用迭代器或Stream API遍历它们。</p>\n\n<h2 id=\"二-计算java中所有map值的总和\">二. 计算Java中所有Map值的总和</h2>\n<p>可以使用 values() 方法。现在任务简化为汇总集合中的所有值。这可以在 Java 中以多种方式完成：</p>\n\n<h3 id=\"1-使用-java-8\">1. 使用 Java 8</h3>\n<p>在 Java 8 或更高版本中，可以使用 Streams 轻松完成求和运算，而无需任何循环。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import java.util.HashMap;\nimport java.util.Map;\n \npublic class Main{\n    public static void main(String[] args){\n        Map&lt;String, Integer&gt; persons = new HashMap&lt;&gt;();\n \n        persons.put(\"John\", 25);\n        persons.put(\"Neil\", 15);\n        persons.put(\"Rosy\", 18);\n \n        int sum = persons.values().stream().mapToInt(Integer::intValue).sum();\n \n        System.out.println(sum);        // 58\n    }\n}\n</code></pre>  </div></div>\n\n<p>还可以使用 reduce() 方法。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import java.util.HashMap;\nimport java.util.Map;\n \npublic class Main\n{\n    public static void main(String[] args)\n    {\n        Map&lt;String, Integer&gt; persons = new HashMap&lt;&gt;();\n \n        persons.put(\"John\", 25);\n        persons.put(\"Neil\", 15);\n        persons.put(\"Rosy\", 18);\n \n        int sum = persons.values().stream().reduce(0, Integer::sum);\n \n        System.out.println(sum);        // 58\n    }\n}\n</code></pre>  </div></div>\n\n<h3 id=\"2使用for循环\">2.使用for循环</h3>\n\n<p>在 Java 8 之前，我们可以使用简单的 for 循环替换 Stream API 链：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>import java.util.HashMap;\nimport java.util.Map;\n \npublic class Main{\n    public static void main(String[] args){\n        Map&lt;String, Integer&gt; persons = new HashMap&lt;&gt;();\n \n        persons.put(\"John\", 25);\n        persons.put(\"Neil\", 15);\n        persons.put(\"Rosy\", 18);\n \n        int sum = 0;\n        for (int value: persons.values()) {\n            sum += value;\n        }\n \n        System.out.println(sum);        // 58\n    }\n}\n</code></pre>  </div></div>\n\n<p>这就是计算 a 中所有值的总和 Map&lt;?, Integer&gt; 在Java。</p>\n","dir":"/blog/development/java/basics/","name":"2023-04-24_1.md","path":"blog/development/java/basics/2023-04-24_1.md","url":"/blog/development/java/basics/2023-04-24_1.html"},{"sort":1,"layout":"default","title":"Windows端口常见问题解决","content":"<h1 id=\"windows端口常见问题解决\">Windows端口常见问题解决</h1>\n<p>在windows中启动项目经常会遇到各种问题，这里记录下解决方式</p>\n\n<h2 id=\"一-windows端口占用问题\">一. Windows端口占用问题</h2>\n<p>当要使用的端口已经被其他应用程序占用时，会导致新应用程序无法绑定该端口。解决方法包括关闭占用该端口的应用程序或更改新应用程序要使用的端口。</p>\n\n<h3 id=\"1根据被占用端口查询pid\">1.根据被占用端口查询pid</h3>\n<p>查看端口占用的进程号：netstat -ano|findstr “端口”</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>netstat -ano|findstr 8080\n</code></pre>  </div></div>\n<h3 id=\"2-根据查询的pid进程号删除进程\">2. 根据查询的pid进程号删除进程</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>taskkill /pid 8124  -t  -f\n</code></pre>  </div></div>\n","dir":"/blog/development/os/windows/","name":"2023-04-27_1.md","path":"blog/development/os/windows/2023-04-27_1.md","url":"/blog/development/os/windows/2023-04-27_1.html"},{"sort":1,"permalink":"/blog/development/os/linux/","layout":"default","title":"linux","content":"<h1 id=\"linux\">linux</h1>\n\n<ul>\n <li><a href=\"/blog/development/os/linux/2023-04-23_1.html\">Linux的上传和下载功能</a></li>\n</ul>\n","dir":"/blog/development/os/linux/","name":"README.md","path":"blog/development/os/linux/README.md","url":"/blog/development/os/linux/"},{"sort":1,"layout":"default","title":"Linux的上传和下载功能","content":"<h1 id=\"linux的上传和下载功能\">Linux的上传和下载功能</h1>\n\n<h2 id=\"linux-rz上传与sz下载\">linux rz上传与sz下载</h2>\n\n<p>对于经常使用Linux系统的人员来说，少不了将本地的文件上传到服务器或者从服务器上下载文件到本地，rz / sz命令很方便的帮我们实现了这个功能</p>\n\n<h3 id=\"1-sz命令发送文件到本地\">1. sz命令发送文件到本地</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. 在终端中进入要上传文件的目录。\n2. 运行 rz 命令。\n3. 选择要上传的文件，并在终端仿真软件的文件传输对话框中点击发送（或等效操作）。\n4. 文件将被传输到当前目录中。\n</code></pre>  </div></div>\n\n<p>代码如下:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>#下载一个文件  \nsz filename  \n#下载多个文件  \nsz filename1 filename2  \n#下载dir目录下的所有文件，不包含dir下的文件夹  \nsz dir/*\n</code></pre>  </div></div>\n<h3 id=\"2-rz命令本地上传文件到服务器\">2. rz命令本地上传文件到服务器</h3>\n\n<p> 在命令终端输入rz回车后，就会出现文件选择对话框，选择需要上传文件，一次可以指定多个文件，上传到服务器的路径为当前执行rz命令的目录。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. 在终端中进入要保存下载文件的目录。\n2. 运行 sz 命令，指定要下载的文件路径作为参数。例如：sz filename。\n3. 在终端仿真软件的文件传输对话框中选择保存文件的位置，并点击接收（或等效操作）。\n4. 文件将被下载到指定的目录中。\n</code></pre>  </div></div>\n\n<p><strong>注意：</strong>单独用rz会有两个问题：</p>\n\n<p>上传中断、上传文件变化（md5不同），解决办法是上传是用rz -be，并且去掉弹出的对话框中“Upload files as ASCII”前的勾选。<br />\n-b binary 用binary的方式上传下载，不解释字符为ascii<br />\n-e 强制escape 所有控制字符，比如Ctrl+x，DEL等。</p>\n\n<h3 id=\"3-目录说明\">3. 目录说明：</h3>\n\n<p>   打开SecureCRT软件 -&gt; Options -&gt; session options -&gt; X/Y/Zmodem 下可以设置上传和下载的目录</p>\n\n<p><strong>注意：</strong>为了能够使用 rz 和 sz 命令进行文件传输，需要在 Linux 系统中安装支持 Zmodem 协议的终端仿真软件，并且终端仿真软件与你的终端连接的另一端（例如远程服务器）支持相应的文件传输功能。</p>\n\n<p>此外，还可以使用其他工具和方法进行文件传输，例如 scp 命令、sftp 命令、FTP 客户端等，这些方法可能更常用和更灵活，特别是在与远程服务器进行文件传输时。</p>\n\n","dir":"/blog/development/os/linux/","name":"2023-04-23_1.md","path":"blog/development/os/linux/2023-04-23_1.md","url":"/blog/development/os/linux/2023-04-23_1.html"},{"sort":1,"layout":"default","title":"EASYEXCEL使用详解","content":"<h1 id=\"easyexcel使用详解\">EASYEXCEL使用详解</h1>\n\n<h2 id=\"easyexcel导出\">EASYEXCEL导出</h2>\n<p>两种方式RESPONSE返回文件流下载和保存到服务器返回下载链接</p>\n\n<h3 id=\"1response方式返回excel文件流\">1.response方式返回excel文件流</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>\t@GetMapping(\"/exportExcel\")\n    public void exportExcel(@RequestParam(value = \"menu\") String menu,\n                            @RequestParam(value = \"dwflglId\") int dwflglId,\n                            @RequestParam(value = \"qjCode\") String qjCode,\n                            HttpServletResponse response) throws IOException { //内容集合\n        List&lt;ZjlrysIndexView&gt; jthz = getJthz(dwflglId, qjCode); //表头集合\n        List&lt;ZjlrysTableHead&gt; header = getHeaderOfHz(dwflglId, qjCode);\n        response.setHeader(\"Content-Disposition\", \"attachment; filename=Zjlryshz.xlsx\"); // 响应类型,编码\n        response.setContentType(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n        String bigTitle = \"资金流入预算表\";\n        EasyExcel.write(response.getOutputStream()).head(getExcelHeader(header, bigTitle)).registerWriteHandler(new Custemhandler()).sheet(\"资金流入预算导出模板\").doWrite(getExportData(jthz));\n    }\n</code></pre>  </div></div>\n\n<h3 id=\"2通过在服务器中生成excel临时文件返回下载链接给前端下载\">2.通过在服务器中生成excel临时文件，返回下载链接给前端下载</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>// 获取当前时间\nString updTm = DateUtil.getAllTime(); //filePath为服务器存放临时文件的路径，本地开发环境的时候先可以用本地电脑的路径，比如c:users/，这里加上时间是因为不想被覆盖，也可以加uuid之类的\nFileOutputStream fileOutputStream = new FileOutputStream(filePath + \"xx导出模板\" + updTm + \".xlsx\");\n\nEasyExcel.write(fileOutputStream).head(getDownLoadExcelHead())\n        .registerWriteHandler(new CustomSheetWriteHandler(map)).registerWriteHandler(new Custemhandler())\n        .sheet(\"数据字典导出模板\").doWrite(downLoadExcelData); //url_prefix为服务器的域名之类的下载路径\nString url = url_prefix + \"xx导出模板\" + updTm + \".xlsx\"; /* \\* try {\n \\* \n \\* // 若不进行编码在IE下会乱码\n \\* \n \\* url = URLEncoder.encode(url, \"UTF-8\");\n \\* \n \\* } catch (UnsupportedEncodingException e) {\n \\* \n \\* e.printStackTrace();\n \\* \n \\* } */    \n</code></pre>  </div></div>\n<h3 id=\"3以流的形式上传到服务器\">3.以流的形式上传到服务器</h3>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>//创建流\nByteArrayOutputStream bos=new ByteArrayOutputStream();\n//生成easyexcel的流\nEasyExcel.write(bos).head(getHead()).sheet(sheetName).doWrite(getData());\n//然后把bos上传到服务器,这里我是写了上传工具类，返回下载链接\nString path=OssClientUtil.upload(fileName,bos.toByteArray());\n</code></pre>  </div></div>\n\n","dir":"/blog/development/java/tool/","name":"2023-05-12_1.md","path":"blog/development/java/tool/2023-05-12_1.md","url":"/blog/development/java/tool/2023-05-12_1.html"},{"sort":1,"layout":"default","title":"Java学习大纲路径","content":"<h1 id=\"java学习大纲路径\">Java学习大纲路径</h1>\n\n<p>本文介绍了Java的学习路径大纲，喜欢的朋友可以根据大纲去学习</p>\n\n<p>如果你是完全没有编程基础的新手，建议你先从基础的编程概念入手，比如变量、循环、条件语句、函数等，可以先学习 Python 或者 JavaScript 这样的入门语言，然后再转向 Java。</p>\n\n<p>以下是一个比较完整的 Java 学习路径：</p>\n\n<h2 id=\"一java-基础语法\">一.Java 基础语法</h2>\n<p>学习 Java 的基础语法，包括数据类型、变量、运算符、流程控制、循环语句等等。\n数据类型：包括整数类型、浮点数类型、布尔类型、字符类型等等。以下是 Java 基础语法的学习大纲：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.变量：定义变量的方式、变量的命名规则、变量的作用域等等。\n2.运算符：包括算术运算符、比较运算符、逻辑运算符等等。\n3.流程控制：包括 if 语句、switch 语句、for 循环、while 循环、do-while 循环等等。\n4.数组：定义数组的方式、数组的遍历、数组的排序等等。\n5.方法：定义方法的方式、方法的参数传递、方法的返回值等等。\n6.字符串：定义字符串的方式、字符串的常用方法、字符串的比较等等。\n7.输入输出：使用 Scanner 类读取控制台输入、使用 System.out.println() 输出等等。\n8.包和导入：将类组织成包、使用 import 语句导入类等等。\n9.注释：单行注释、多行注释、文档注释等等。\n</code></pre>  </div></div>\n\n<p>以上是 Java 基础语法的大纲，这些内容是 Java 编程的基础，掌握好这些内容可以让你写出简单的 Java 程序。</p>\n\n<h2 id=\"二面向对象编程\">二.面向对象编程</h2>\n<p>Java 是一门面向对象的语言，所以要学习面向对象编程的基本概念，包括类、对象、封装、继承、多态等等。\n以下是 Java 面向对象编程的学习大纲：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.类和对象：定义类、创建对象、类的构造方法、对象的属性和方法等等。\n2.封装：控制对象的属性访问权限、getter 和 setter 方法、访问修饰符等等。\n3.继承：子类和父类、super 关键字、方法重载和方法覆盖等等。\n4.多态：方法的重载和方法的覆盖、向上转型和向下转型、抽象类和接口等等。\n5.枚举类型：定义枚举类型、枚举类型的属性和方法等等。\n6.内部类：定义内部类、匿名内部类、静态内部类等等。\n7.泛型：定义泛型类、泛型方法、通配符等等。\n8.异常处理：try-catch-finally 语句、抛出异常、自定义异常等等。\n</code></pre>  </div></div>\n\n<p>以上是 Java 面向对象编程的大纲，这些内容是 Java 编程的核心，掌握好这些内容可以让你写出更加复杂的 Java 程序，并且使你的程序更加易于维护和扩展。</p>\n\n<h2 id=\"三异常处理\">三.异常处理</h2>\n<p>Java 中有很多异常类型，了解异常处理机制可以帮助你写出更健壮的代码。\n以下是 Java 异常处理的学习大纲：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.异常概述：异常的定义、异常分类、异常处理机制等等。\n2.try-catch-finally 语句：try 块、catch 块、finally 块的使用方法、多个 catch 块的顺序、异常的重新抛出等等。\n3.异常类和处理程序：自定义异常类、异常处理程序的编写方法等等。\n4.抛出异常：throw 关键字的使用方法、抛出自定义异常等等。\n5.异常处理的最佳实践：异常的记录和日志、避免空指针异常等等。\n</code></pre>  </div></div>\n\n<p>以上是 Java 异常处理的大纲，异常处理是 Java 程序开发的重要部分，合理的异常处理能够增强程序的健壮性和可靠性，减少程序出错的风险，使程序更加稳定。</p>\n\n<h2 id=\"四集合框架\">四.集合框架</h2>\n<p>Java 中的集合框架包括 List、Set、Map 等等，学习这些集合的用法可以帮助你更好地处理数据。\nJava集合框架是Java中的一个核心概念，用于管理和操作不同类型的数据。在学习Java集合框架时，可以按照以下大纲进行学习</p>\n\n<p>1.集合框架概述：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>了解Java集合框架的基本概念和架构\n了解Java集合框架中的接口和类\n学习Java集合框架中的常用数据结构 2.List集合：\n\n学习List集合的概念和特点\n学习ArrayList和LinkedList的使用方法和区别\n学习List集合的常用操作方法\n</code></pre>  </div></div>\n\n<p>3.Set集合：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习Set集合的概念和特点\n学习HashSet和TreeSet的使用方法和区别\n学习Set集合的常用操作方法\n</code></pre>  </div></div>\n\n<p>4.Map集合：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习Map集合的概念和特点\n学习HashMap和TreeMap的使用方法和区别\n学习Map集合的常用操作方法\n</code></pre>  </div></div>\n\n<p>5.Queue集合：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习Queue集合的概念和特点\n学习LinkedList和PriorityQueue的使用方法和区别\n学习Queue集合的常用操作方法\n</code></pre>  </div></div>\n\n<p>6.Collections工具类：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习Collections工具类的常用方法\n学习Collections工具类中的排序算法\n</code></pre>  </div></div>\n\n<p>7.Iterator迭代器：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习Iterator迭代器的概念和作用\n学习如何使用Iterator迭代器遍历集合\n</code></pre>  </div></div>\n\n<p>8.泛型；</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>学习泛型的概念和作用；\n学习如何使用泛型来增加代码的可读性和可维护性；\n</code></pre>  </div></div>\n\n<p>以上是Java集合框架的学习大纲，通过系统学习可以更好地掌握Java集合框架的使用和应用。</p>\n\n<h2 id=\"五io-流操作\">五.IO 流操作</h2>\n<p>Java 中有很多 IO 流，包括字节流和字符流，学习 IO 流可以帮助你更好地读写文件和网络数据。\nJava IO 流操作可以分为以下几个部分：</p>\n\n<p>1.Java IO 流概述：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Java IO 流的分类\n字节流和字符流的区别\n输入流和输出流的概念\n</code></pre>  </div></div>\n\n<p>2.字节流：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>InputStream 和 OutputStream\nFileInputStream 和 FileOutputStream\nByteArrayInputStream 和 ByteArrayOutputStream\nBufferedInputStream 和 BufferedOutputStream\nDataInputStream 和 DataOutputStream\nObjectInputStream 和 ObjectOutputStream\n</code></pre>  </div></div>\n\n<p>3.字符流：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Reader 和 Writer\nFileReader 和 FileWriter\nCharArrayReader 和 CharArrayWriter\nBufferedReader 和 BufferedWriter\nInputStreamReader 和 OutputStreamWriter\n</code></pre>  </div></div>\n\n<p>4.NIO：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NIO 的概念和使用\nChannel 和 Buffer 的概念和使用\nSelector 的概念和使用\n</code></pre>  </div></div>\n\n<p>5.文件操作：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>File 类的概念和使用\nFile 相关的输入输出流的使用\n文件的读写和复制\n</code></pre>  </div></div>\n\n<p>6.序列化和反序列化：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Serializable 接口和 Externalizable 接口\nObjectOutputStream 和 ObjectInputStream 的使用\ntransient 关键字的使用\n</code></pre>  </div></div>\n\n<p>7.其他：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>PipedInputStream 和 PipedOutputStream\nPrintStream 和 PrintWriter\nRandomAccessFile\n</code></pre>  </div></div>\n\n<p>以上是一个比较完整的 Java IO 流操作的学习大纲，可以按照这个大纲系统地学习 Java IO 流的相关知识点。在学习过程中，可以结合实际的项目需求和练习来加深理解和熟练掌握。</p>\n\n<h2 id=\"六多线程编程\">六.多线程编程</h2>\n<p>Java 支持多线程编程，学习多线程编程可以让你写出更高效的程序。以下是Java多线程编程的学习大纲：</p>\n\n<p>1.多线程基础：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>理解线程和进程的概念\n创建线程的方式：继承Thread类和实现Runnable接口\n线程的状态和状态转换：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED\n线程的优先级\n线程的同步与协作：synchronized关键字、wait()、notify()、notifyAll()方法\n线程池的使用\n</code></pre>  </div></div>\n\n<p>2.线程安全：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>理解线程安全的概念\n线程安全的实现方法：synchronized关键字、Lock对象、原子类、volatile关键字\n线程安全的集合类\n</code></pre>  </div></div>\n\n<p>3.高级多线程编程：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>线程的中断和停止：interrupt()、Thread.currentThread().isInterrupted()、Thread.interrupted()方法\n等待多个线程完成：CountDownLatch、CyclicBarrier、Semaphore\n线程间通信：Pipe、BlockingQueue、Exchanger\n同步器：ReentrantLock、ReadWriteLock、Condition\n</code></pre>  </div></div>\n\n<p>4.并发编程实践：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>原子性操作：AtomicInteger、AtomicBoolean、AtomicReference等\n死锁的解决方法\n线程的性能调优\n</code></pre>  </div></div>\n\n<p>5.Java 8的并发编程特性：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>并行流和并发流\nCompletableFuture类\n新的原子类\n</code></pre>  </div></div>\n\n<p>在学习的过程中，可以通过实践来巩固知识。例如，编写多线程的程序来实现一些并发任务，可以通过调试和测试来加深对多线程编程的理解。同时，也可以参考一些经典的多线程编程案例，例如生产者消费者问题、哲学家就餐问题等。</p>\n\n<h2 id=\"七数据库编程\">七.数据库编程</h2>\n<p>Java 中有很多数据库连接方式，比如 JDBC，学习数据库编程可以帮助你处理数据存储和查询的问题。\n以下是Java数据库编程的学习大纲：</p>\n\n<p>1.数据库基础知识</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>数据库的概念\n关系型数据库和非关系型数据库的区别\nSQL语言的基本语法和常用操作\n数据库事务的概念和特性\n</code></pre>  </div></div>\n\n<p>2.JDBC编程</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>JDBC的基本概念和原理\nJDBC的四大对象：Connection、Statement、ResultSet、PreparedStatement\nJDBC的数据类型映射\nJDBC的事务处理\nJDBC的元数据和批量处理\n</code></pre>  </div></div>\n\n<p>3.数据库连接池</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>连接池的概念和作用\n数据库连接池的实现原理\n常用的数据库连接池框架：C3P0、DBCP、HikariCP等\n连接池的配置和性能调优\n</code></pre>  </div></div>\n\n<p>4.ORM框架</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ORM的概念和作用\n常用的ORM框架：Hibernate、MyBatis等\nORM框架的配置和使用\nORM框架的性能调优\n</code></pre>  </div></div>\n\n<p>5.NoSQL数据库</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NoSQL数据库的概念和特点\n常用的NoSQL数据库：MongoDB、Redis、Cassandra等\nNoSQL数据库的Java编程实现\n</code></pre>  </div></div>\n\n<p>在学习的过程中，可以通过实践来巩固知识。例如，通过编写Java程序来连接数据库，进行增删改查等操作。同时，也可以参考一些经典的数据库案例，例如图书管理系统、学生成绩管理系统等，来加深对数据库编程的理解。</p>\n\n<h2 id=\"八web-开发\">八.Web 开发</h2>\n<p>Java 在 Web 开发方面也有很多优秀的框架，比如 Spring、Struts、Hibernate 等等，学习这些框架可以帮助你开发高效的 Web 应用。\n以下是JavaWeb开发的学习大纲：</p>\n\n<p>1.Web基础知识</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Web应用的概念和特点\nHTTP协议的基本原理和常用方法\nHTML、CSS、JavaScript等Web前端技术\n</code></pre>  </div></div>\n\n<p>2.Servlet编程</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Servlet的概念和生命周期\nServlet的请求处理和响应处理\nServlet的会话管理和Cookie技术\nServlet的过滤器和监听器\n</code></pre>  </div></div>\n\n<p>3.JSP编程</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>JSP的概念和原理\nJSP的标签和指令\nJSP的EL表达式和JSTL标签库\nJSP和Servlet的协作\n</code></pre>  </div></div>\n\n<p>4.MVC框架</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>MVC框架的概念和作用\n常用的MVC框架：Struts、Spring MVC等\nMVC框架的配置和使用\nMVC框架的性能调优\n</code></pre>  </div></div>\n\n<p>5.Web服务开发</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Web服务的概念和特点\nSOAP和RESTful两种Web服务架构\n常用的Web服务开发框架：CXF、Axis等\nWeb服务的安全性和性能优化\n</code></pre>  </div></div>\n\n<p>6.前后端分离开发</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>前后端分离开发的概念和特点\n常用的前端框架：Vue.js、React等\n常用的后端框架：Spring Boot、Spring Cloud等\n前后端数据交互方式：JSON、XML等\n</code></pre>  </div></div>\n\n<p>在学习的过程中，可以通过实践来巩固知识。例如，编写一个简单的Web应用程序，包括前端页面、后端服务和数据库的交互等。同时，也可以参考一些经典的Web开发案例，例如电商网站、博客系统等，来加深对JavaWeb开发的理解。\n以上是一个比较完整的 Java 学习路径，当然如果你只是想学习 Java 的一部分，可以根据自己的需求选择学习内容。</p>\n","dir":"/blog/development/java/jottings/","name":"2023-04-23_1.md","path":"blog/development/java/jottings/2023-04-23_1.md","url":"/blog/development/java/jottings/2023-04-23_1.html"},{"sort":1,"permalink":"/blog/development/java/jottings/","layout":"default","title":"随笔","content":"<h1 id=\"随笔\">随笔</h1>\n\n<ul>\n <li><a href=\"/blog/development/java/jottings/2023-04-23_1.html\">Java学习大纲路径</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_1.html\">Spring中的事务回滚机制</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_2.html\">Java开发环境安装配置JDK+Maven+Tomcat</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-05-12_1.html\">Restful风格开发方式</a></li>\n</ul>\n","dir":"/blog/development/java/jottings/","name":"README.md","path":"blog/development/java/jottings/README.md","url":"/blog/development/java/jottings/"},{"sort":1,"permalink":"/blog/","layout":"default","title":"JustMyFreedom","content":"<h1 id=\"justmyfreedom\">JustMyFreedom</h1>\n\n<ul>\n <li><a href=\"/blog/frontier/\">前沿</a>\n <ul>\n <li><a href=\"/blog/frontier/recommend/\">推荐</a>\n <ul>\n <li><a href=\"/blog/frontier/recommend/2023-04-27_1.html\">推荐几款好用的自用软件</a></li>\n <li><a href=\"/blog/frontier/recommend/2023-04-23_1.html\">Just My Socks 介绍，Just My Socks 是什么？</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/frontier/new/\">新闻</a>\n <ul>\n <li><a href=\"/blog/frontier/new/technology/\">科技</a>\n <ul>\n <li><a href=\"/blog/frontier/new/technology/2023-04-23_1.html\">ChatGpt</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/frontier/new/life/\">生活</a>\n <ul>\n <li><a href=\"/blog/frontier/new/life/2023-04-23_1.html\">2023年计划考试时间(全年)</a></li>\n </ul>\n </li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/\">开发随笔</a>\n <ul>\n <li><a href=\"/blog/development/interview/\">面试宝典</a>\n <ul>\n <li><a href=\"/blog/development/interview/java/\">Java面试题</a>\n <ul>\n <li><a href=\"/blog/development/interview/java/2023-04-23_1.html\">Java面试宝典一(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_2.html\">Java面试宝典二(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_3.html\">Java面试宝典三(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_4.html\">Java面试宝典四(2023最新Java面试题)</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/html/\">前端笔记</a>\n <ul>\n <li><a href=\"/blog/development/html/jottings/\">随笔</a>\n <ul>\n <li><a href=\"/blog/development/html/jottings/2023-04-21_1.html\">html页面如何设置适配移动端</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-04-27_1.html\">HTML页面中返回顶部的几种实现</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_1.html\">html表格导出excel有几种方式</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_2.html\">laydate渲染日期</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/html/seo/\">SEO优化</a>\n <ul>\n <li><a href=\"/blog/development/html/seo/2023-04-27_1.html\">NGINX强制使用https访问(http跳转到https)</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_2.html\">最新主流搜索引擎提交sitemap大全（网站地图）</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_3.html\">SEO实操小技巧关键字</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/html/webdesign/\">Jekyll网站开发</a>\n <ul>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_1.html\">Jekyll安装配置和使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_2.html\">七牛云对象存储(图床)免费使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-05-12_1.html\">免费的Jekyll静态网站发布平台</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/\">Java笔记</a>\n <ul>\n <li><a href=\"/blog/development/java/jottings/\">随笔</a>\n <ul>\n <li><a href=\"/blog/development/java/jottings/2023-04-23_1.html\">Java学习大纲路径</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_1.html\">Spring中的事务回滚机制</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_2.html\">Java开发环境安装配置JDK+Maven+Tomcat</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-05-12_1.html\">Restful风格开发方式</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/basics/\">Java基础</a>\n <ul>\n <li><a href=\"/blog/development/java/basics/2023-04-24_1.html\">Java中map常见操作集合</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_2.html\">Java中Json转换的常见操作方式</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_3.html\">Java中计算List求和或List对象中某个字段的总和</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-27_1.html\">Java中BigDecimal类型详解</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/tool/\">工具包</a>\n <ul>\n <li><a href=\"/blog/development/java/tool/2023-05-12_1.html\">EASYEXCEL使用详解</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/python/\">Python笔记</a>\n <ul>\n <li><a href=\"/blog/development/python/jottings/\">随笔</a></li>\n <li><a href=\"/blog/development/python/django/\">Django</a>\n <ul>\n <li><a href=\"/blog/development/python/django/2023-04-27_1.html\">Django中url与path及re_path区别</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/os/\">操作系统</a>\n <ul>\n <li><a href=\"/blog/development/os/linux/\">linux</a>\n <ul>\n <li><a href=\"/blog/development/os/linux/2023-04-23_1.html\">Linux的上传和下载功能</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/os/windows/\">windows</a>\n <ul>\n <li><a href=\"/blog/development/os/windows/2023-04-27_1.html\">Windows端口常见问题解决</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/\">工具</a>\n <ul>\n <li><a href=\"/blog/development/tool/redis/\">Redis</a>\n <ul>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_1.html\">Windows部署redis集群模式</a></li>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_2.html\">redis如何设置密码</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/git/\">Git</a>\n <ul>\n <li><a href=\"/blog/development/tool/git/2023-04-27_1.html\">最新Github创建仓库,将项目上传到GitHub</a></li>\n <li><a href=\"/blog/development/tool/git/2023-04-28_1.html\">Git一份代码同时提交两个Git仓库</a></li>\n <li><a href=\"/blog/development/tool/git/2023-05-12_1.html\">Git常用操作命令</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/maven/\">Java基础</a>\n <ul>\n <li><a href=\"/blog/development/tool/maven/2023-04-27_1.html\">Maven推送本地jar包到仓库</a></li>\n </ul>\n </li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/life/\">生活随笔</a>\n <ul>\n <li><a href=\"/blog/life/travel/\">趣事小记</a></li>\n <li><a href=\"/blog/life/poetry/\">诗词鉴赏</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/about/\">关于</a>\n <ul>\n <li><a href=\"/blog/about/website/\">网站</a>\n <ul>\n <li><a href=\"/blog/about/website/2023-04-23_1.html\">关于Justmyfreedom网站</a></li>\n </ul>\n </li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/","name":"README.md","path":"blog/README.md","url":"/blog/"},{"sort":2,"permalink":"/blog/development/","layout":"default","title":"开发随笔","content":"<h1 id=\"开发随笔\">开发随笔</h1>\n<p>编程开发过程中的随笔和总结</p>\n\n<ul>\n <li><a href=\"/blog/development/interview/\">面试宝典</a>\n <ul>\n <li><a href=\"/blog/development/interview/java/\">Java面试题</a>\n <ul>\n <li><a href=\"/blog/development/interview/java/2023-04-23_1.html\">Java面试宝典一(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_2.html\">Java面试宝典二(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_3.html\">Java面试宝典三(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_4.html\">Java面试宝典四(2023最新Java面试题)</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/html/\">前端笔记</a>\n <ul>\n <li><a href=\"/blog/development/html/jottings/\">随笔</a>\n <ul>\n <li><a href=\"/blog/development/html/jottings/2023-04-21_1.html\">html页面如何设置适配移动端</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-04-27_1.html\">HTML页面中返回顶部的几种实现</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_1.html\">html表格导出excel有几种方式</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_2.html\">laydate渲染日期</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/html/seo/\">SEO优化</a>\n <ul>\n <li><a href=\"/blog/development/html/seo/2023-04-27_1.html\">NGINX强制使用https访问(http跳转到https)</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_2.html\">最新主流搜索引擎提交sitemap大全（网站地图）</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_3.html\">SEO实操小技巧关键字</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/html/webdesign/\">Jekyll网站开发</a>\n <ul>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_1.html\">Jekyll安装配置和使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_2.html\">七牛云对象存储(图床)免费使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-05-12_1.html\">免费的Jekyll静态网站发布平台</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/\">Java笔记</a>\n <ul>\n <li><a href=\"/blog/development/java/jottings/\">随笔</a>\n <ul>\n <li><a href=\"/blog/development/java/jottings/2023-04-23_1.html\">Java学习大纲路径</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_1.html\">Spring中的事务回滚机制</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_2.html\">Java开发环境安装配置JDK+Maven+Tomcat</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-05-12_1.html\">Restful风格开发方式</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/basics/\">Java基础</a>\n <ul>\n <li><a href=\"/blog/development/java/basics/2023-04-24_1.html\">Java中map常见操作集合</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_2.html\">Java中Json转换的常见操作方式</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_3.html\">Java中计算List求和或List对象中某个字段的总和</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-27_1.html\">Java中BigDecimal类型详解</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/tool/\">工具包</a>\n <ul>\n <li><a href=\"/blog/development/java/tool/2023-05-12_1.html\">EASYEXCEL使用详解</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/python/\">Python笔记</a>\n <ul>\n <li><a href=\"/blog/development/python/jottings/\">随笔</a></li>\n <li><a href=\"/blog/development/python/django/\">Django</a>\n <ul>\n <li><a href=\"/blog/development/python/django/2023-04-27_1.html\">Django中url与path及re_path区别</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/os/\">操作系统</a>\n <ul>\n <li><a href=\"/blog/development/os/linux/\">linux</a>\n <ul>\n <li><a href=\"/blog/development/os/linux/2023-04-23_1.html\">Linux的上传和下载功能</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/os/windows/\">windows</a>\n <ul>\n <li><a href=\"/blog/development/os/windows/2023-04-27_1.html\">Windows端口常见问题解决</a></li>\n </ul>\n </li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/\">工具</a>\n <ul>\n <li><a href=\"/blog/development/tool/redis/\">Redis</a>\n <ul>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_1.html\">Windows部署redis集群模式</a></li>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_2.html\">redis如何设置密码</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/git/\">Git</a>\n <ul>\n <li><a href=\"/blog/development/tool/git/2023-04-27_1.html\">最新Github创建仓库,将项目上传到GitHub</a></li>\n <li><a href=\"/blog/development/tool/git/2023-04-28_1.html\">Git一份代码同时提交两个Git仓库</a></li>\n <li><a href=\"/blog/development/tool/git/2023-05-12_1.html\">Git常用操作命令</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/maven/\">Java基础</a>\n <ul>\n <li><a href=\"/blog/development/tool/maven/2023-04-27_1.html\">Maven推送本地jar包到仓库</a></li>\n </ul>\n </li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/","name":"README.md","path":"blog/development/README.md","url":"/blog/development/"},{"sort":2,"layout":"default","title":"Spring中的事务回滚机制","content":"<h1 id=\"spring中的事务回滚机制\">Spring中的事务回滚机制</h1>\n\n<p>在Spring框架中，事务管理是一项重要的功能。事务是一组相关操作的逻辑单元，要么全部成功执行，要么全部回滚。事务的回滚机制是指在事务执行过程中发生异常或满足特定条件时，将之前执行的操作全部回滚到事务开始之前的状态。</p>\n\n<p>Spring框架提供了多种方式来管理事务，包括基于注解的声明式事务管理和编程式事务管理。无论使用哪种方式，Spring的事务回滚机制都是基于AOP（面向切面编程）和数据库的事务支持。</p>\n\n<h2 id=\"一-声明式事务管理\">一. 声明式事务管理</h2>\n\n<p>在Spring中，声明式事务管理是一种方便的方式来管理事务，它允许使用注解或XML配置来声明事务的行为，而无需在业务代码中显式处理事务操作。</p>\n\n<p>声明式事务管理的关键是使用@Transactional注解。通过在方法或类上添加@Transactional注解，可以指定事务的传播行为、回滚规则等属性。当方法被调用时，Spring会自动为该方法开启事务，并在方法执行结束后根据注解的配置自动提交或回滚事务。</p>\n\n<p>下面是声明式事务管理的一些重要概念和使用方式：</p>\n\n<p><strong>@Transactional注解：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Transactional注解可应用于方法或类级别。\n当应用于方法时，它指示该方法应在事务范围内执行。\n当应用于类时，它指示该类中的所有公共方法都应在事务范围内执行。\n@Transactional注解可以设置多个属性，例如传播行为、隔离级别、回滚规则等。\n</code></pre>  </div></div>\n\n<p><strong>事务传播行为：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>事务传播行为定义了事务方法如何与已经存在的事务进行交互。\n一些常见的传播行为包括REQUIRED、REQUIRES_NEW、SUPPORTS、NOT_SUPPORTED、NEVER、MANDATORY等。\nREQUIRED是默认的传播行为，它指示方法应该在已经存在的事务中执行，如果没有事务则创建一个新事务。\n</code></pre>  </div></div>\n\n<p><strong>事务回滚规则：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>事务回滚规则定义了哪些异常触发事务回滚。\n默认情况下，Spring仅在遇到RuntimeException及其子类异常时才会回滚事务。\n可以使用@Transactional注解的rollbackFor属性指定需要回滚的异常类型，或者使用noRollbackFor属性指定不需要回滚的异常类型。\n</code></pre>  </div></div>\n\n<p><strong>XML配置方式：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>除了使用注解方式外，还可以使用XML配置声明式事务管理。\n在XML配置中，可以定义事务管理器、切面和事务通知等元素来实现声明式事务管理。\n</code></pre>  </div></div>\n\n<p>下面的示例展示了如何在Spring中使用声明式事务管理：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)\npublic void performTransaction() {\n    // 业务逻辑代码\n}\n\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void performAnotherTransaction() {\n    // 业务逻辑代码\n}\n\n</code></pre>  </div></div>\n<p>在示例中，performTransaction()方法将在已存在的事务中执行，如果没有事务则创建一个新事务。该方法在遇到任何Exception及其子类异常时都会触发事务回滚。而performAnotherTransaction()方法使用REQUIRES_NEW传播行为，它总是创建一个新事务并在方法执行结束后提交。</p>\n\n<p>通过声明式事务管理，可以将事务相关的代码与业务逻辑代码分开。</p>\n\n<h2 id=\"二-编程式事务管理\">二. 编程式事务管理</h2>\n<p>在Spring中，编程式事务管理是一种手动管理事务的方式，通过编写代码来控制事务的开始、提交和回滚。相对于声明式事务管理，编程式事务管理提供了更细粒度的事务控制。</p>\n\n<p>编程式事务管理涉及以下几个重要的组件和操作：</p>\n\n<p><strong>PlatformTransactionManager：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>PlatformTransactionManager是Spring框架中的事务管理器接口。\n它定义了开始事务、提交事务和回滚事务等操作的方法。\n</code></pre>  </div></div>\n\n<p><strong>TransactionDefinition：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>TransactionDefinition是用于定义事务的接口，它包含了事务的传播行为、隔离级别、超时时间等属性。\n通过TransactionDefinition，可以指定事务的行为方式。\n</code></pre>  </div></div>\n\n<p><strong>TransactionStatus：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>TransactionStatus是表示事务状态的接口。\n它包含了事务的当前状态信息，例如是否是一个新事务、是否已经完成等。\n</code></pre>  </div></div>\n\n<p><strong>TransactionTemplate：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>TransactionTemplate是Spring提供的简化编程式事务管理的工具类。\n它封装了事务的启动、提交和回滚等操作，简化了事务管理的代码编写。\n</code></pre>  </div></div>\n\n<p>示例展示了如何在Spring中使用编程式事务管理：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Autowired\nprivate PlatformTransactionManager transactionManager;\n\npublic void performTransaction() {\n    TransactionDefinition definition = new DefaultTransactionDefinition();\n    TransactionStatus status = transactionManager.getTransaction(definition);\n    \n    try {\n        // 业务逻辑代码\n        \n        transactionManager.commit(status);\n    } catch (Exception e) {\n        transactionManager.rollback(status);\n    }\n}\n\n</code></pre>  </div></div>\n<p>在示例中，首先通过@Autowired注解注入了PlatformTransactionManager事务管理器。然后创建一个TransactionDefinition对象来定义事务的属性。接下来，通过调用transactionManager.getTransaction(definition)方法获取一个TransactionStatus对象来表示当前事务的状态。</p>\n\n<p>在try块中，编写了业务逻辑代码。如果业务逻辑执行成功，调用transactionManager.commit(status)方法提交事务。如果在try块中抛出了异常，会进入catch块，调用transactionManager.rollback(status)方法回滚事务。</p>\n\n<p>通过编程式事务管理，可以在需要的时候手动控制事务的开始、提交和回滚，以满足更复杂的事务场景。然而，相对于声明式事务管理，编程式事务管理需要更多的手动操作和代码编写。</p>\n\n<h2 id=\"三-异常触发事务回滚\">三. 异常触发事务回滚</h2>\n<p>在Spring中的事务回滚机制中，异常的抛出是触发事务回滚的重要因素之一。当在事务内部抛出特定类型的异常时，Spring会自动回滚事务，将所有已执行的数据库操作恢复到事务开始之前的状态。</p>\n\n<p>以下是关于异常触发事务回滚的几个要点：</p>\n\n<p><strong>默认回滚规则：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>默认情况下，Spring只有在遇到RuntimeException及其子类异常时才会触发事务回滚。\nRuntimeException是未检查异常，它的抛出通常表示程序运行时出现了严重错误。\nChecked异常（非RuntimeException的异常）不会触发事务回滚。\n</code></pre>  </div></div>\n\n<p><strong>异常回滚规则配置：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>可以通过@Transactional注解的rollbackFor属性来配置需要触发事务回滚的异常类型。\n例如，@Transactional(rollbackFor = {Exception.class})指示任何异常（包括RuntimeException和Checked异常）都将触发事务回滚。\n</code></pre>  </div></div>\n\n<p><strong>手动触发事务回滚：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>在某些情况下，可能希望手动触发事务回滚，而不是依赖异常的抛出。\n在方法中，可以使用TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()来手动将事务标记为回滚状态。\n调用该方法后，事务将在方法执行结束时回滚。\n</code></pre>  </div></div>\n\n<p>下面示例展示了异常触发事务回滚的情况：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Transactional\npublic void performTransaction() {\n    // 业务逻辑代码\n    if (someCondition) {\n        throw new RuntimeException(\"Something went wrong\");\n    }\n}\n\n</code></pre>  </div></div>\n<p>在上面的示例中，performTransaction()方法使用@Transactional注解来声明一个事务。如果在业务逻辑代码中满足了某个条件，会抛出RuntimeException，这将导致事务回滚。所有在抛出异常之前执行的数据库操作都将被回滚，保持数据的一致性。</p>\n\n<p>通过异常触发事务回滚，可以在遇到错误或异常情况时保证数据的完整性，避免数据不一致的问题。同时，也可以通过手动触发事务回滚来处理一些特殊情况，以满足更灵活的事务控制需求。</p>\n\n<h2 id=\"四-事务传播行为\">四. 事务传播行为</h2>\n\n<p>在Spring中，事务传播行为定义了事务方法与已经存在的事务之间的交互方式。事务传播行为决定了在方法调用链中如何处理事务边界，以及如何管理事务的隔离性、并发控制等方面的行为。</p>\n\n<p>以下是Spring中常见的事务传播行为：</p>\n\n<p><strong>REQUIRED（默认）：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>REQUIRED传播行为指示方法应该在已经存在的事务中执行。如果当前没有事务存在，则创建一个新事务。\n如果方法被嵌套调用，那么内部方法将使用外部方法的事务。\n</code></pre>  </div></div>\n\n<p><strong>REQUIRES_NEW：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>REQUIRES_NEW传播行为指示方法应该创建一个新的事务，并在执行期间挂起当前事务（如果存在）。\n如果方法被嵌套调用，内部方法将挂起外部方法的事务并创建一个新的事务。\n</code></pre>  </div></div>\n\n<p><strong>SUPPORTS：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>SUPPORTS传播行为指示方法应该在事务存在的情况下以事务方式执行。如果当前没有事务存在，那么方法将以非事务方式执行。\n</code></pre>  </div></div>\n\n<p><strong>NOT_SUPPORTED：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NOT_SUPPORTED传播行为指示方法应该以非事务方式执行。如果当前存在事务，那么该事务将被挂起。\n</code></pre>  </div></div>\n\n<p><strong>NEVER：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NEVER传播行为指示方法不应该在事务内部执行。如果当前存在事务，则抛出异常。\n</code></pre>  </div></div>\n\n<p><strong>MANDATORY：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>MANDATORY传播行为指示方法应该在已经存在的事务中执行。如果当前没有事务存在，则抛出异常。\n</code></pre>  </div></div>\n\n<p><strong>NESTED：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NESTED传播行为指示方法应该在一个已经存在的事务中执行，但是作为嵌套事务的一部分。\n如果当前没有事务存在，则创建一个新的事务。如果外部事务提交，嵌套事务也会被提交。如果外部事务回滚，嵌套事务会回滚到保存点。\n</code></pre>  </div></div>\n\n<p>在使用@Transactional注解或编程式事务管理时，可以指定适合需求的事务传播行为。通过选择正确的传播行为，可以确保事务在方法调用链中的正确传播和管理，以保证数据的一致性和完整性。</p>\n\n<p>以下示例展示了如何在Spring中使用事务传播行为：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Transactional(propagation = Propagation.REQUIRED)\npublic void outerMethod() {\n    // 业务逻辑代码\n    innerMethod();\n}\n\n@Transactional(propagation = Propagation.REQUIRES_NEW)\npublic void innerMethod() {\n    // 业务逻辑代码\n}\n\n</code></pre>  </div></div>\n<p>在上面的示例中，outerMethod()方法使用REQUIRED传播行为，默认情况下将参与到外部方法的事务中。而innerMethod()方法使用REQUIRES_NEW传播行为，它会创建一个新的事务并独立执行。无论outerMethod()方法的事务提交还是回滚，innerMethod()方法都创建一个新的事务。</p>\n\n<p><strong>总结：</strong>\nSpring的事务回滚机制通过注解或编程的方式提供了灵活的事务管理。它基于AOP和数据库的事务支持，允许开发人员在方法或类级别声明事务，并根据业务需求进行配置。通过合理使用事务的传播行为和异常处理，可以确保数据的一致性和完整性。</p>\n","dir":"/blog/development/java/jottings/","name":"2023-04-27_1.md","path":"blog/development/java/jottings/2023-04-27_1.md","url":"/blog/development/java/jottings/2023-04-27_1.html"},{"sort":2,"permalink":"/blog/development/java/basics/","layout":"default","title":"Java基础","content":"<h1 id=\"java基础\">Java基础</h1>\n\n<ul>\n <li><a href=\"/blog/development/java/basics/2023-04-24_1.html\">Java中map常见操作集合</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_2.html\">Java中Json转换的常见操作方式</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_3.html\">Java中计算List求和或List对象中某个字段的总和</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-27_1.html\">Java中BigDecimal类型详解</a></li>\n</ul>\n","dir":"/blog/development/java/basics/","name":"README.md","path":"blog/development/java/basics/README.md","url":"/blog/development/java/basics/"},{"sort":2,"permalink":"/blog/development/html/","layout":"default","title":"前端笔记","content":"<h1 id=\"前端笔记\">前端笔记</h1>\n\n<ul>\n <li><a href=\"/blog/development/html/jottings/\">随笔</a>\n <ul>\n <li><a href=\"/blog/development/html/jottings/2023-04-21_1.html\">html页面如何设置适配移动端</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-04-27_1.html\">HTML页面中返回顶部的几种实现</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_1.html\">html表格导出excel有几种方式</a></li>\n <li><a href=\"/blog/development/html/jottings/2023-05-12_2.html\">laydate渲染日期</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/html/seo/\">SEO优化</a>\n <ul>\n <li><a href=\"/blog/development/html/seo/2023-04-27_1.html\">NGINX强制使用https访问(http跳转到https)</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_2.html\">最新主流搜索引擎提交sitemap大全（网站地图）</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_3.html\">SEO实操小技巧关键字</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/html/webdesign/\">Jekyll网站开发</a>\n <ul>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_1.html\">Jekyll安装配置和使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_2.html\">七牛云对象存储(图床)免费使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-05-12_1.html\">免费的Jekyll静态网站发布平台</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/html/","name":"README.md","path":"blog/development/html/README.md","url":"/blog/development/html/"},{"sort":2,"layout":"default","title":"redis如何设置密码","content":"<h1 id=\"redis如何设置密码\">redis如何设置密码</h1>\n\n<p>这里简单介绍一下redis如何设置密码，redis密码设置有三种种方式，<strong>一种在配置文件中设置密码，第二种在启动 Redis 时通过命令行参数设置密码，第三种使用 CONFIG 命令设置密码</strong></p>\n\n<h2 id=\"第一种在配置文件中设置密码\">第一种：在配置文件中设置密码</h2>\n\n<p><strong>第一步：</strong>打开 Redis 的配置文件。在大多数情况下，Redis 的配置文件名为 redis.conf，可以在 Redis 的安装目录中找到。</p>\n\n<p><strong>第二步：</strong>在配置文件中，找到 # requirepass 这一行。如果该行被注释掉了（以 # 开头），则需要取消注释。</p>\n\n<p><strong>第三步：</strong>在 # requirepass 后面的空格处，输入想要设置的密码。例如，requirepass YourPassword。</p>\n\n<p><strong>第四步：</strong>保存配置文件并重新启动 Redis 服务器，以使新的密码设置生效。</p>\n\n<h2 id=\"第二种在启动-redis-时通过命令行参数设置密码\">第二种：在启动 Redis 时通过命令行参数设置密码</h2>\n\n<p>可以在启动 Redis 服务器时通过命令行参数 -a 或 –requirepass 来设置密码。例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>redis-server --requirepass YourPassword\n</code></pre>  </div></div>\n\n<h2 id=\"第三种使用-config-命令设置密码\">第三种：使用 CONFIG 命令设置密码</h2>\n<p>在已经连接到 Redis 服务器的情况下，可以使用 CONFIG 命令来设置密码。使用命令来设置密码。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>config set requirepass 123456\n</code></pre>  </div></div>\n<p>无论使用哪种方式，设置密码后，连接到 Redis 服务器时都需要提供正确的密码才能进行操作。</p>\n\n<p><strong>注意事项：</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>设置密码后，请妥善保存密码，并确保密码的安全性。\n如果使用 Redis 的集群模式，需要在每个节点上设置相同的密码。\n当密码设置后，通过 CONFIG 命令或修改配置文件来更改密码。 请注意，以上方式是基于 Redis 的标准配置。如果你使用的是 Redis 的特定版本或扩展，可能会有其他方式来设置密码。建议参考相应版本的文档或官方指南以了解更多详细信息。\n</code></pre>  </div></div>\n","dir":"/blog/development/tool/redis/","name":"2023-04-30_2.md","path":"blog/development/tool/redis/2023-04-30_2.md","url":"/blog/development/tool/redis/2023-04-30_2.html"},{"sort":2,"layout":"default","title":"Java面试宝典二(2023最新Java面试题)","content":"<h1 id=\"java面试宝典二2023最新java面试题\">Java面试宝典二(2023最新Java面试题)</h1>\n\n<h2 id=\"一-java-web\"><strong>一. Java Web</strong></h2>\n\n<h3 id=\"1-jsp-和-servlet-有什么区别\"><strong>1. JSP 和 servlet 有什么区别？</strong></h3>\n\n<p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p>\n\n<h3 id=\"2-jsp-有哪些内置对象作用分别是什么\"><strong>2. JSP 有哪些内置对象？作用分别是什么？</strong></h3>\n\n<p>JSP 有 9 大内置对象：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；\nresponse：封装服务器对客户端的响应；\npageContext：通过该对象可以获取其他对象；\nsession：封装用户会话的对象；\napplication：封装服务器运行环境的对象；\nout：输出服务器响应的输出流对象；\nconfig：Web 应用的配置对象；\npage：JSP 页面本身（相当于 Java 程序中的 this）；\nexception：封装页面抛出异常的对象。\n</code></pre>  </div></div>\n\n<h3 id=\"3-说一下-jsp-的-4-种作用域\"><strong>3. 说一下 JSP 的 4 种作用域？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>page：代表与一个页面相关的对象和属性。\nrequest：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。\nsession：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。\napplication：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。\n</code></pre>  </div></div>\n\n<h3 id=\"4-session-和-cookie-有什么区别\"><strong>4. session 和 cookie 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。\n安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。\n容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。\n存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。\n</code></pre>  </div></div>\n\n<h3 id=\"5-说一下-session-的工作原理\"><strong>5. 说一下 session 的工作原理？</strong></h3>\n\n<p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。</p>\n\n<p>这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p>\n\n<h3 id=\"6-如果客户端禁止-cookie-能实现-session-还能用吗\"><strong>6. 如果客户端禁止 cookie 能实现 session 还能用吗？</strong></h3>\n\n<p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p>\n\n<h3 id=\"7-spring-mvc-和-struts-的区别是什么\"><strong>7. spring mvc 和 struts 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。\n数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。\n拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。\n对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。\n</code></pre>  </div></div>\n\n<h3 id=\"8-如何避免-sql-注入\"><strong>8. 如何避免 SQL 注入？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>使用预处理 PreparedStatement。\n使用正则表达式过滤掉字符中的特殊字符。\n</code></pre>  </div></div>\n\n<h3 id=\"9-什么是-xss-攻击如何避免\"><strong>9. 什么是 XSS 攻击，如何避免？</strong></h3>\n\n<p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p>\n\n<p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p>\n\n<h3 id=\"10-什么是-csrf-攻击如何避免\"><strong>10. 什么是 CSRF 攻击，如何避免？</strong></h3>\n\n<p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p>\n\n<p>防御手段：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>验证请求来源地址；\n关键操作添加验证码；\n在请求地址添加 token 并验证。\n</code></pre>  </div></div>\n\n<h2 id=\"二-异常\"><strong>二. 异常</strong></h2>\n\n<h3 id=\"1-throw-和-throws-的区别\"><strong>1. throw 和 throws 的区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>throw：是真实抛出一个异常。\nthrows：是声明可能会抛出一个异常。\n</code></pre>  </div></div>\n\n<h3 id=\"2-finalfinallyfinalize-有什么区别\"><strong>2. final、finally、finalize 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。\nfinally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。\nfinalize：是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。\n</code></pre>  </div></div>\n\n<h3 id=\"3-try-catch-finally-中哪个部分可以省略\"><strong>3. try-catch-finally 中哪个部分可以省略？</strong></h3>\n\n<p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>\n\n<h3 id=\"4-try-catch-finally-中如果-catch-中-return-了finally-还会执行吗\"><strong>4. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong></h3>\n\n<p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>\n\n<h3 id=\"5-常见的异常类有哪些\"><strong>5. 常见的异常类有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>NullPointerException 空指针异常\nClassNotFoundException 指定类不存在\nNumberFormatException 字符串转换为数字异常\nIndexOutOfBoundsException 数组下标越界异常\nClassCastException 数据类型转换异常\nFileNotFoundException 文件未找到异常\nNoSuchMethodException 方法不存在异常\nIOException IO 异常\nSocketException Socket 异常\n</code></pre>  </div></div>\n\n<h2 id=\"三-网络\"><strong>三. 网络</strong></h2>\n\n<h3 id=\"1-http-响应码-301-和-302-代表的是什么有什么区别\"><strong>1. http 响应码 301 和 302 代表的是什么？有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>301：永久重定向。\n\n302：暂时重定向。\n</code></pre>  </div></div>\n\n<p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>\n\n<h3 id=\"2-forward-和-redirect-的区别\"><strong>2. forward 和 redirect 的区别？</strong></h3>\n\n<p>forward 是转发 和 redirect 是重定向：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；\n数据共享：forward 可以共享 request 里的数据，redirect 不能共享；\n效率：forward 比 redirect 效率高。\n</code></pre>  </div></div>\n\n<h3 id=\"3-简述-tcp-和-udp的区别\"><strong>3. 简述 tcp 和 udp的区别？</strong></h3>\n\n<p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>\n\n<p>两者的区别大致如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；\ntcp 提供可靠的服务（数据传输），udp 无法保证；\ntcp 面向字节流，udp 面向报文；\ntcp 数据传输慢，udp 数据传输快；\n</code></pre>  </div></div>\n\n<h3 id=\"4-tcp-为什么要三次握手两次不行吗为什么\"><strong>4. tcp 为什么要三次握手，两次不行吗？为什么？</strong></h3>\n\n<p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p>\n\n<h3 id=\"5-说一下-tcp-粘包是怎么产生的\"><strong>5. 说一下 tcp 粘包是怎么产生的？</strong></h3>\n\n<p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；\n接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。\n</code></pre>  </div></div>\n\n<h3 id=\"6-osi-的七层模型都有哪些\"><strong>6. OSI 的七层模型都有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。\n数据链路层：负责建立和管理节点间的链路。\n网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。\n传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。\n会话层：向两个实体的表示层提供建立和使用连接的方法。\n表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。\n应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。\n</code></pre>  </div></div>\n\n<h3 id=\"7-get-和-post-请求有哪些区别\"><strong>7. get 和 post 请求有哪些区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>get 请求会被浏览器主动缓存，而 post 不会。\nget 传递参数有大小限制，而 post 没有。\npost 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。\n</code></pre>  </div></div>\n\n<h3 id=\"8-如何实现跨域\"><strong>8. 如何实现跨域？</strong></h3>\n\n<p>实现跨域有以下几种方案：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>服务器端运行跨域 设置 CORS 等于 *；\n在单个接口使用注解 @CrossOrigin 运行跨域；\n使用 jsonp 跨域；\n</code></pre>  </div></div>\n\n<h3 id=\"9-说一下-jsonp-实现原理\"><strong>9. 说一下 JSONP 实现原理？</strong></h3>\n\n<p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p>\n\n<h2 id=\"四-设计模式\"><strong>四. 设计模式</strong></h2>\n\n<h3 id=\"1-说一下你熟悉的设计模式\"><strong>1. 说一下你熟悉的设计模式？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>单例模式：保证被创建一次，节省系统开销。\n工厂模式（简单工厂、抽象工厂）：解耦代码。\n观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。\n外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。\n模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。\n状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。\n</code></pre>  </div></div>\n\n<h3 id=\"2-简单工厂和抽象工厂有什么区别\"><strong>2. 简单工厂和抽象工厂有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。\n工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。\n抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。\n</code></pre>  </div></div>\n","dir":"/blog/development/interview/java/","name":"2023-04-23_2.md","path":"blog/development/interview/java/2023-04-23_2.md","url":"/blog/development/interview/java/2023-04-23_2.html"},{"sort":2,"permalink":"/blog/development/tool/maven/","layout":"default","title":"Java基础","content":"<h1 id=\"java基础\">Java基础</h1>\n\n<ul>\n <li><a href=\"/blog/development/tool/maven/2023-04-27_1.html\">Maven推送本地jar包到仓库</a></li>\n</ul>\n","dir":"/blog/development/tool/maven/","name":"README.md","path":"blog/development/tool/maven/README.md","url":"/blog/development/tool/maven/"},{"sort":2,"layout":"default","title":"Java中Json转换的常见操作方式","content":"<h1 id=\"java中json转换的常见操作方式\">Java中Json转换的常见操作方式</h1>\n\n<h2 id=\"一-利用阿里巴巴封装的fastjson来转换json字符串\">一. 利用阿里巴巴封装的FastJSON来转换json字符串</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>package com.zkn.newlearn.json;\n \nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport java.util.Map;\n \n/**\n * JSON字符串自动转换\n * Created by zkn on 2016/8/22.\n */\npublic class JsonToMapTest01 {\n \n    public static void main(String[] args){\n \n        String str = \"{\\\"0\\\":\\\"zhangsan\\\",\\\"1\\\":\\\"lisi\\\",\\\"2\\\":\\\"wangwu\\\",\\\"3\\\":\\\"maliu\\\"}\";\n        //第一种方式\n        Map maps = (Map)JSON.parse(str);\n        System.out.println(\"这个是用JSON类来解析JSON字符串!!!\");\n        for (Object map : maps.entrySet()){\n            System.out.println(((Map.Entry)map).getKey()+\"     \" + ((Map.Entry)map).getValue());\n        }\n        //第二种方式\n        Map mapTypes = JSON.parseObject(str);\n        System.out.println(\"这个是用JSON类的parseObject来解析JSON字符串!!!\");\n        for (Object obj : mapTypes.keySet()){\n            System.out.println(\"key为：\"+obj+\"值为：\"+mapTypes.get(obj));\n        }\n        //第三种方式\n        Map mapType = JSON.parseObject(str,Map.class);\n        System.out.println(\"这个是用JSON类,指定解析类型，来解析JSON字符串!!!\");\n        for (Object obj : mapType.keySet()){\n            System.out.println(\"key为：\"+obj+\"值为：\"+mapType.get(obj));\n        }\n        //第四种方式\n        /**\n         * JSONObject是Map接口的一个实现类\n         */\n        Map json = (Map) JSONObject.parse(str);\n        System.out.println(\"这个是用JSONObject类的parse方法来解析JSON字符串!!!\");\n        for (Object map : json.entrySet()){\n            System.out.println(((Map.Entry)map).getKey()+\"  \"+((Map.Entry)map).getValue());\n        }\n        //第五种方式\n        /**\n         * JSONObject是Map接口的一个实现类\n         */\n        JSONObject jsonObject = JSONObject.parseObject(str);\n        System.out.println(\"这个是用JSONObject的parseObject方法来解析JSON字符串!!!\");\n        for (Object map : json.entrySet()){\n            System.out.println(((Map.Entry)map).getKey()+\"  \"+((Map.Entry)map).getValue());\n        }\n        //第六种方式\n        /**\n         * JSONObject是Map接口的一个实现类\n         */\n        Map mapObj = JSONObject.parseObject(str,Map.class);\n        System.out.println(\"这个是用JSONObject的parseObject方法并执行返回类型来解析JSON字符串!!!\");\n        for (Object map: json.entrySet()){\n            System.out.println(((Map.Entry)map).getKey()+\"  \"+((Map.Entry)map).getValue());\n        }\n        System.out.println(json);\n    }\n}\n</code></pre>  </div></div>\n","dir":"/blog/development/java/basics/","name":"2023-04-24_2.md","path":"blog/development/java/basics/2023-04-24_2.md","url":"/blog/development/java/basics/2023-04-24_2.html"},{"sort":2,"permalink":"/blog/development/os/windows/","layout":"default","title":"windows","content":"<h1 id=\"windows\">windows</h1>\n\n<ul>\n <li><a href=\"/blog/development/os/windows/2023-04-27_1.html\">Windows端口常见问题解决</a></li>\n</ul>\n","dir":"/blog/development/os/windows/","name":"README.md","path":"blog/development/os/windows/README.md","url":"/blog/development/os/windows/"},{"sort":2,"layout":"default","title":"HTML页面中返回顶部的几种实现","content":"<h1 id=\"html页面中返回顶部的几种实现\">HTML页面中返回顶部的几种实现</h1>\n\n<p>最近在开发网站需要制作返回顶部按钮,但是我平时主要做后端开发,对前端不太熟练,经过网上资料查询,制作出了返回顶部的按钮,下面是两种简单的方式,记录一下.喜欢<a href=\"https://justmyfreedom.com/\">本网站</a>的朋友可以收藏下,会不定期更新学习资料.</p>\n\n<h2 id=\"第一种引用外部jquery\">第一种:引用外部jQuery</h2>\n\n<p>新建HTML页面,将下面代码复制保存,通过浏览器打开,即可看到效果.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;title&gt;doc&lt;/title&gt;\n&lt;style&gt;\n    .arrow{\n        border: 9px solid transparent;\n        border-bottom-color: #3DA0DB;\n        width: 0px;\n        height: 0px;\n        top:0px\n    }\n    .stick{\n        width: 8px;\n        height: 14px;\n        border-radius: 1px;\n        background-color: #3DA0DB;\n        top:15px;\n    }\n    #back_top div{\n        position: absolute;\n        margin: auto;\n        right: 0px;\n        left: 0px;\n    }\n    #back_top{\n        background-color: #dddddd;\n        height: 38px;\n        width: 38px;\n        border-radius: 3px;\n        display: block;\n        cursor: pointer;\n        position: fixed;\n        right: 50px;\n        bottom: 100px;\n        display: none;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div id=\"article\"&gt;&lt;/div&gt;\n&lt;div id=\"back_top\"&gt;\n&lt;div class=\"arrow\"&gt;&lt;/div&gt;\n&lt;div class=\"stick\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;script src=\"http://cdn.staticfile.org/jquery/1.11.1-rc2/jquery.min.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n$(function(){\n    for(var i =0 ;i &lt;100;i++){\n        $(\"#article\").append(\"&lt;p&gt;xxxxxxxxxx&lt;br&gt;&lt;/p&gt;\")\n    }\n\n})\n&lt;/script&gt;\n&lt;script&gt;\n$(function(){\n    $(window).scroll(function(){  //只要窗口滚动,就触发下面代码\n        var scrollt = document.documentElement.scrollTop + document.body.scrollTop; //获取滚动后的高度\n        if( scrollt &gt;200 ){  //判断滚动后高度超过200px,就显示\n            $(\"#back_top\").fadeIn(400); //淡入\n        }else{\n            $(\"#back_top\").stop().fadeOut(400); //如果返回或者没有超过,就淡出.必须加上stop()停止之前动画,否则会出现闪动\n        }\n    });\n    $(\"#back_top\").click(function(){ //当点击标签的时候,使用animate在200毫秒的时间内,滚到顶部\n        $(\"html,body\").animate({scrollTop:\"0px\"},200);\n    }); \n});\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>  </div></div>\n\n<h2 id=\"第二种使用css及特殊图标进行设置\">第二种:使用css及特殊图标进行设置</h2>\n<p>全代码打造简洁美观回到顶部按钮,同上,将代码复制进HTML文件中,打开即可看到效果.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;title&gt;doc&lt;/title&gt;\n&lt;style&gt;\n    #back_top{ \n\tdisplay:block;  \n\twidth:60px; \n\theight:60px;\n\tposition:fixed;  \n\tbottom:50px;  \n\tright:40px; \n\tborder-radius:10px 10px 10px 10px;   \n\ttext-decoration:none;  \n\tdisplay:none;  \n\tbackground-color:#999999;     \n\t}\n\t#back_top span{ \n\t\tdisplay:block; \n\t\twidth:60px; \n\t\tcolor:#dddddd; \n\t\tfont-size:40px; \n\t\ttext-align:center; \n\t\tmargin-top:4px;\n\t} \n\t#back_top span:hover{ \n\t\tcolor:#cccccc; \n\t} \n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div id=\"article\"&gt;&lt;/div&gt;\n&lt;a id=\"back_top\" href=\"script:;\"&gt;   \n  &lt;span&gt;⌆&lt;/span&gt; \n&lt;/a&gt;\n&lt;/div&gt;\n&lt;script&gt;\n$(function(){\n    for(var i =0 ;i &lt;100;i++){\n        $(\"#article\").append(\"&lt;p&gt;xxxxxxxxxx&lt;br&gt;&lt;/p&gt;\")\n    }\n})\n&lt;/script&gt;\n&lt;script&gt;\n$(function(){\n\t$(window).scroll(function(){  //只要窗口滚动,就触发下面代码 \n\t\tvar scrollt = document.documentElement.scrollTop + document.body.scrollTop; //获取滚动后的高度 \n\t\tif( scrollt &gt;200 ){  //判断滚动后高度超过200px,就显示  \n\t\t\t$(\"#back_top\").fadeIn(400); //淡出     \n\t\t}else{      \n\t\t\t$(\"#back_top\").stop().fadeOut(400); //如果返回或者没有超过,就淡入.必须加上stop()停止之前动画,否则会出现闪动   \n\t\t}\n\t});\n\t$(\"#back_top\").click(function(){ //当点击标签的时候,使用animate在200毫秒的时间内,滚到顶部\n\t\t\t$(\"html,body\").animate({scrollTop:\"0px\"},200);\n\t});\n});\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>  </div></div>\n<h2 id=\"第三种使用锚点链接\">第三种：使用锚点链接</h2>\n\n<p>在页面的底部或任意位置添加一个返回顶部的锚点链接，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;a href=\"#top\"&gt;返回顶部&lt;/a&gt;\n</code></pre>  </div></div>\n<p>然后在页面的顶部添加一个带有id属性为”top”的元素，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;div id=\"top\"&gt;&lt;/div&gt;\n</code></pre>  </div></div>\n<p>当用户点击返回顶部的链接时，页面将滚动到带有相应id的顶部元素。</p>\n\n<h2 id=\"第四种使用javascript滚动效果\">第四种：使用JavaScript滚动效果</h2>\n\n<p>可以使用JavaScript来实现平滑滚动到页面顶部的效果。例如，通过添加以下代码实现：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;button onclick=\"scrollToTop()\"&gt;返回顶部&lt;/button&gt;\n&lt;script&gt;\nfunction scrollToTop() {\n  window.scrollTo({\n    top: 0,\n    behavior: \"smooth\"\n  });\n}\n&lt;/script&gt;\n\n</code></pre>  </div></div>\n\n<p>当用户点击返回顶部的按钮时，页面将平滑滚动回顶部位置。</p>\n\n<p>以上是几种常见的实现返回顶部功能的方法。可以根据项目需求和个人喜好选择其中一种或结合使用。</p>\n","dir":"/blog/development/html/jottings/","name":"2023-04-27_1.md","path":"blog/development/html/jottings/2023-04-27_1.md","url":"/blog/development/html/jottings/2023-04-27_1.html"},{"sort":2,"layout":"default","title":"七牛云对象存储(图床)免费使用","content":"<h1 id=\"七牛云对象存储图床免费使用\">七牛云对象存储(图床)免费使用</h1>\n\n<h2 id=\"一-使用七牛云空间对象存储并设置自定义域名\">一. 使用七牛云空间对象存储并设置自定义域名</h2>\n<p>相信很多人都有搭建个人技术博客。但是在写博客时遇到的一个普遍问题是：在用 MarkDown格式语法写文章时，图片的上传和引用让人头疼，想要在文章里面插图片，但不知道放哪。</p>\n\n<p>这里给大家介绍一个存储图片的好地方，七牛云。</p>\n\n<p>七牛云是一家提供对象存储服务的云计算公司，其对象存储服务可以用来存储各种类型的文件，包括图片、视频、文档等等。其中，七牛云的对象存储服务还可以用来搭建图床，为博客、社交媒体等网站提供图片存储和分享服务。本文将介绍七牛云对象存储图床的使用方式和注意事项。</p>\n\n<p>最关键的是，注册就会有10G标准存储免费空间。下来介绍下使用方式。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424200055min.png\" alt=\"微信截图_20230424200055min\" /></p>\n<h3 id=\"1注册七牛云账号\">1.注册七牛云账号</h3>\n<p>首先需要注册一个七牛云账号，注册后可以获得AccessKey和SecretKey，这两个密钥是使用七牛云对象存储服务的关键。</p>\n\n<p>注册后从右上角进入个人中心\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424200351min.png\" alt=\"微信截图_20230424200351min\" /></p>\n\n<h3 id=\"2创建存储空间\">2.创建存储空间</h3>\n<p>登录七牛云控制台后，可以创建一个存储空间，用于存储图片等文件。在创建存储空间时，需要选择存储区域和存储类型等参数，根据自己的需求进行设置。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424200638min.png\" alt=\"微信截图_20230424200638min\" /></p>\n\n<h3 id=\"3上传图片\">3.上传图片</h3>\n<p>在存储空间中上传图片，可以通过七牛云控制台、SDK、API等方式进行上传。上传成功后，会获得一个图片的URL地址。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424200850min.png\" alt=\"微信截图_20230424200850min\" /></p>\n\n<h3 id=\"4使用图片\">4.使用图片</h3>\n<p>点击复制外链即可获得的图片URL地址，在需要的地方引用图片。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424201021min.png\" alt=\"微信截图_20230424201021min\" /></p>\n\n<h2 id=\"二-七牛云自定义域名配置\">二. 七牛云自定义域名配置</h2>\n<p>注意：七牛云提供的外链域名会在30天内过期，如果想要长期使用，需要绑定自己域名，示例中用到的域名是在阿里服务商申请的</p>\n\n<h3 id=\"1配置自定义域名\">1.配置自定义域名</h3>\n<h4 id=\"七牛云空间新增自定义域名\">七牛云空间新增自定义域名</h4>\n<p>点击域名管理，绑定域名\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424201600min.png\" alt=\"微信截图_20230424201600min\" /></p>\n\n<p>在圈红的地方填写自己申请的域名即可，例如：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>image.justmyfreedom.com/\n</code></pre>  </div></div>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424201709min.png\" alt=\"微信截图_20230424201709min\" /></p>\n\n<p>获取获取CNAME值\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424202414min.png\" alt=\"微信截图_20230424202414min\" /></p>\n\n<h4 id=\"配置域名映射\">配置域名映射</h4>\n<p>取域名服务商即域名申请网站配置，这里是在阿里云申请的，因此去阿里云配置。</p>\n\n<p>在阿里云的域名控制台中在域名的后面点击解析（七牛云的空间配置的哪个域名点击哪个域名的解析）</p>\n\n<p><img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424202917min.png\" alt=\"微信截图_20230424202917min\" /></p>\n\n<p>添加记录的主机记录中请注意，如果你在绑定七牛云域名时直接用的域名，比如你注册的域名为</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>aaa.com\n</code></pre>  </div></div>\n\n<p>然后你在七牛云绑定域名时也是用的 aaa.com，那么在主机记录这里直接选择 @ 即可。如果在 aaa.com 的前面加了二级域名，比如是这样</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>bbb.aaa.com\n</code></pre>  </div></div>\n\n<p>那么主机记录这里添加 bbb 即可。\n @ 符代表直接解析主域名（不过一般不推荐直接使用 @，因为域名本身有一个A记录值，这样的话CNAME会和A记录值冲突）\n 主机记录添加 bbb，域名解析后就是 bbb.aaa.com</p>\n\n<p>按照圈起来的那条进行配置即可，因为我给域名增加了前缀，因此主机记录这里是image\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424203050min.png\" alt=\"微信截图_20230424203050min\" /></p>\n\n<h4 id=\"查看配置cname是否成功\">查看配置CNAME是否成功</h4>\n<p>返回七牛云的域名管理，如图状态那里显示成功即可，然后在文件管理中复制一个图片外链，在浏览器中打开看是否成功。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424201600min.png\" alt=\"微信截图_20230424201600min\" /></p>\n\n<h3 id=\"2-七牛云自定义域名配置阿里云ssl证书\">2. 七牛云自定义域名配置阿里云SSL证书</h3>\n\n<p> 配置证书前需要在七牛云的空间管理中配置了一个使用阿里云域名进行访问的空间。</p>\n\n<h4 id=\"获取阿里云域名证书\">获取阿里云域名证书</h4>\n\n<p>1、直接在阿里云的SSL证书中创建一个免费的证书即可<br />\n2、然后下载pem格式的证书文件（我下载的是pem的证书，其它的证书格式的没有试过，感兴趣的可以试试）<br />\n3、下载完证书之后然后解压，会出现两个文件，一个是<code class=\"language-plaintext highlighter-rouge\">.pem</code>结尾的文件，另一个是<code class=\"language-plaintext highlighter-rouge\">.key</code>结尾的文件</p>\n\n<h4 id=\"七牛云配置证书提升https访问\">七牛云配置证书（提升HTTPS访问）</h4>\n\n<p>1、在域名管理中找到HTTPS配置<br />\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424204122min.png\" alt=\"微信截图_20230424204122min\" />\n2、配置证书</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>证书的备注名填写你需要配置的域名；例如：img.image.com（我是用的是二级域名）\n证书内容直接将`.pem`文件中的内容全部复制粘贴进去即可\n证书私钥也是直接将`.key`文件中的内容全部复制粘贴进去\n填好之后点击确定输入你账号的密码即可，之后会有几小时等待审核的时间，快的话十几分钟。 点击配置后，根据以上步骤配置即可 ![微信截图_20230424204156min](https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230424204156min.png)\n</code></pre>  </div></div>\n\n<h2 id=\"注意事项\">注意事项：</h2>\n\n<p>1.安全问题：由于七牛云存储的是公开的文件，因此需要注意保护图片的安全性。可以通过设置存储空间的访问权限、使用图片防盗链等方式来加强图片的安全性。</p>\n\n<p>2.存储空间的容量和使用限制：七牛云的对象存储服务有一定的容量和使用限制，需要根据自己的需求进行选择和设置。</p>\n\n<p>3.文件命名和管理：在上传文件时，需要注意文件的命名和管理，以便于后续的使用和维护。建议使用有意义的文件名，并且对于大量的图片需要进行分类和整理。</p>\n\n<p>4.数据备份：由于存储在云端的数据可能会受到各种因素的影响，因此需要进行数据备份，以保障数据的安全性和可靠性。</p>\n\n","dir":"/blog/development/html/webdesign/","name":"2023-04-24_2.md","path":"blog/development/html/webdesign/2023-04-24_2.md","url":"/blog/development/html/webdesign/2023-04-24_2.html"},{"sort":2,"permalink":"/blog/frontier/new/","layout":"default","title":"新闻","content":"<h1 id=\"新闻\">新闻</h1>\n\n<ul>\n <li><a href=\"/blog/frontier/new/technology/\">科技</a>\n <ul>\n <li><a href=\"/blog/frontier/new/technology/2023-04-23_1.html\">ChatGpt</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/frontier/new/life/\">生活</a>\n <ul>\n <li><a href=\"/blog/frontier/new/life/2023-04-23_1.html\">2023年计划考试时间(全年)</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/frontier/new/","name":"README.md","path":"blog/frontier/new/README.md","url":"/blog/frontier/new/"},{"sort":2,"layout":"default","title":"最新主流搜索引擎提交sitemap大全（网站地图）","content":"<h1 id=\"最新主流搜索引擎提交sitemap大全网站地图\">最新主流搜索引擎提交sitemap大全（网站地图）</h1>\n\n<p>做网站优化我们除了要做好站内和站外优化之外，还需要关注各大搜索引擎提交的入口，因为有的时候网站太多，蜘蛛一时间无法抓取过来，这时候我们需要采取主动出击，而不是被动的接受蜘蛛自己来抓取。</p>\n\n<p>搜索引擎提交sitemap大全（网站地图）,各个站长管理平台.</p>\n\n<p>  对于SEO优化人员来说，都有那些可以提交的入口呢？今天就为大家汇总一下提交sitemap大全。</p>\n\n<h2 id=\"一百度\">一.百度</h2>\n<p>百度sitemap提交：老地址是：<a href=\"http://sitemap.baidu.com/\">http://sitemap.baidu.com/</a> 百度站长平台，我相信这是很多站长都非常熟悉的。</p>\n\n<p>最新地址：<a href=\"https://ziyuan.baidu.com/\">https://ziyuan.baidu.com/</a>，注册登录账号。在站点管理中进行新增网址验证。\n<img src=\"https://image.justmyfreedom.com//static/assets/blog_img/微信截图_20230427145844min.png\" alt=\"微信截图_20230427145844min\" />\n注意：gitpage网站无法正常被百度收录，需要其他处理方法。</p>\n\n<h2 id=\"二google\">二.Google</h2>\n<p>  Google：<a href=\"https://www.google.com/webmasters/tools/\">https://www.google.com/webmasters/tools/</a> 可谓最强大的网站管理员工具，提交sitemap当然是最基本的。</p>\n\n<p>进行站点验证后，可刷新页面，点击左上角网站进行提交sitemap.xml提交</p>\n\n<h2 id=\"三360\">三.360</h2>\n<p>  360sitemap提交：<a href=\"http://zhanzhang.so.com/?m=Sitemap&amp;a=listSite\">http://zhanzhang.so.com/?m=Sitemap&amp;a=listSite</a> 有助于360更全面、更快速地对网站进行抓取。</p>\n\n<p>注：gitpage网站验证失败</p>\n<h2 id=\"四搜狗\">四.搜狗</h2>\n<p>  搜狗sitemap提交：<a href=\"http://zhanzhang.sogou.com/index.php/sitemap/index/type/sitemap\">http://zhanzhang.sogou.com/index.php/sitemap/index/type/sitemap</a> 可帮助sogou爬虫抓取你的网站，目前采用邀请制,目前不支持sitemap批量方式.</p>\n\n<p>注：验证时需要备案过的域名</p>\n\n<h2 id=\"五bing\">五.Bing</h2>\n<p>  Bing：<a href=\"http://www.bing.com/toolbox/webmaster/\">http://www.bing.com/toolbox/webmaster/</a> 微软的强力产品，在美国市场占有一定搜索份额。管理员工具功能也很强大。</p>\n\n<h2 id=\"六yandex\">六.Yandex</h2>\n<p>  Yandex：<a href=\"http://webmaster.yandex.com/\">http://webmaster.yandex.com/</a> Yandex是俄罗斯最大的搜索引擎，相对于俄罗斯的百度。管理员工具提供了类似Google Webmaster的功能，非常强大。</p>\n\n<h2 id=\"七让头条搜索收录网站\">七.让头条搜索收录网站</h2>\n\n<p>注册头条站长平台：https://zhanzhang.toutiao.com/</p>\n\n<h2 id=\"七让神马搜索收录网站\">七.让神马搜索收录网站</h2>\n\n<p>神马平台：https://zhanzhang.sm.cn/open/webcheck/web/14787346</p>\n\n<p>两种方式都验证失败，放弃神马收录</p>\n\n<p>除了上述距离比较近的主流搜索引擎.另外雅虎中国已经关闭,神马搜索设置了下,无法验证网站成功,其他Ask等可以选择性提交.</p>\n\n<p>  最后，在robots.txt文件中添加sitemap，搜索引擎抓取robots.txt的时候就可以获取sitemap。方法非常简单，只要在robots.txt的第一行或者最后一行按以下格式加入sitemap地址即可。即：Sitemap: http://www.example.com/sitemap.xml当发现蜘蛛已经很久没有来我们网站的时候，可以适当地提交网站地图，这样可以让蜘蛛优先抓取和收录。</p>\n","dir":"/blog/development/html/seo/","name":"2023-04-27_2.md","path":"blog/development/html/seo/2023-04-27_2.md","url":"/blog/development/html/seo/2023-04-27_2.html"},{"sort":2,"layout":"default","title":"Git一份代码同时提交两个Git仓库","content":"<h1 id=\"git一份代码同时提交两个git仓库\">Git一份代码同时提交两个Git仓库</h1>\n\n<h2 id=\"查看git仓库\">查看Git仓库</h2>\n\n<p>首先查看Git代码绑定了哪些Git仓库</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git remote -v\n</code></pre>  </div></div>\n\n<p>如果当前代码没有绑定远端Git仓库，需要先确定Pull会从哪个仓库Pull，之后运行如下命令</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git remote add orgin https://gitee.com/test/test123.git\n</code></pre>  </div></div>\n<h2 id=\"绑定多个远端仓库\">绑定多个远端仓库</h2>\n\n<p>之后再绑定另外一个远端仓库，使Push的时候能同时Push两个仓库</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git remote set-url --add origin https://github.com/test/test123.git\n</code></pre>  </div></div>\n<p>这个时候查看远端仓库信息会有两个Push的远程仓库</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ git remote -v\norgin   https://github.com/test/test123.git (fetch)\norgin   https://github.com/test/test123.git (push)\norgin   https://gitee.com/test/test123.git (push)\n</code></pre>  </div></div>\n<p>之后再进行add commit push即可，会将代码同时Push到两个远程仓库中</p>\n\n<h2 id=\"移除指定远端仓库\">移除指定远端仓库</h2>\n<p>git绑定多个远端仓库后，要移除 Git 中绑定的指定远程仓库，可以使用以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git remote remove &lt;remote-name&gt;\n</code></pre>  </div></div>\n<p>其中，<remote-name> 是要移除的远程仓库的名称。例如上一步用的分支是“orgin”，这块就填orgin。\n步骤如下：</remote-name></p>\n\n<p><strong>第一步：</strong>打开终端或命令行窗口，进入包含 Git 仓库的目录。</p>\n\n<p><strong>第二步：</strong>运行上述命令，将 <remote-name> 替换为要移除的远程仓库的名称。例如，如果要移除名为 \"origin\" 的远程仓库绑定，可以运行：</remote-name></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git remote remove origin\n</code></pre>  </div></div>\n<p><strong>第三步：</strong>运行命令后，Git 将会移除指定的远程仓库绑定。此时如果所有远程仓库的分支都是一个，那么得重新配置仓库了</p>\n\n<p><strong>注意：</strong>移除远程仓库绑定并不会删除远程仓库本身，它只是从本地 Git 仓库的配置中移除对应的远程仓库绑定信息。</p>\n","dir":"/blog/development/tool/git/","name":"2023-04-28_1.md","path":"blog/development/tool/git/2023-04-28_1.md","url":"/blog/development/tool/git/2023-04-28_1.html"},{"sort":3,"permalink":"/blog/development/interview/java/","layout":"default","title":"Java面试题","content":"<h1 id=\"java面试题\">Java面试题</h1>\n\n<ul>\n <li><a href=\"/blog/development/interview/java/2023-04-23_1.html\">Java面试宝典一(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_2.html\">Java面试宝典二(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_3.html\">Java面试宝典三(2023最新Java面试题)</a></li>\n <li><a href=\"/blog/development/interview/java/2023-04-23_4.html\">Java面试宝典四(2023最新Java面试题)</a></li>\n</ul>\n","dir":"/blog/development/interview/java/","name":"README.md","path":"blog/development/interview/java/README.md","url":"/blog/development/interview/java/"},{"sort":3,"layout":"default","title":"SEO实操小技巧关键字","content":"<h1 id=\"seo实操小技巧关键字\">SEO实操小技巧关键字</h1>\n\n<h2 id=\"一-seo关键字优化十大技巧\">一. SEO关键字优化十大技巧</h2>\n<p>关键字在搜索引擎优化（SEO）中扮演重要角色，以下是关于关键字的一些SEO技巧：</p>\n\n<p><strong>1. 关键字研究：</strong>进行关键字研究，找到与你网站内容相关且受众搜索频率较高的关键字。使用关键字研究工具（如Google关键字规划工具、SEMrush、Moz等）来确定适合你网站的关键字。</p>\n\n<p><strong>2. 关键字密度：</strong>在网页内容中合理使用关键字。关键字密度是指关键字在内容中的出现频率，但不应过度堆砌关键字。确保关键字的使用自然流畅，对读者有意义。</p>\n\n<p><strong>3. 标题和描述：</strong>将关键字包含在页面标题（title）和元描述（meta description）标签中。这有助于搜索引擎了解页面内容，并向用户展示相关的搜索结果。</p>\n\n<p><strong>4. URL 结构：</strong>优化页面的URL结构，将关键字包含在URL中。简洁、清晰的URL有助于搜索引擎理解页面内容，并提供更好的用户体验。</p>\n\n<p><strong>5. 内部链接：</strong>在网站内部创建有关键字的内部链接，这可以增加页面之间的相关性和导航性，也有助于搜索引擎索引和理解你的网站。</p>\n\n<p><strong>6. 图像标签：</strong>为网站中的图像添加描述性的Alt标签，其中包括关键字。这有助于搜索引擎理解图像内容，并为图像搜索结果提供机会。</p>\n\n<p><strong>7. 高质量内容：</strong>编写高质量、有价值的内容，并围绕关键字进行优化。优质内容吸引用户，并增加网站在搜索引擎中的可信度和排名。</p>\n\n<p><strong>8. 用户体验：</strong>提供优秀的用户体验，包括页面加载速度、移动友好性和易用性。这些因素对于搜索引擎排名和用户满意度都很重要。</p>\n\n<p><strong>9. 外部链接：</strong>获取高质量的外部链接，来自其他网站指向你的网站。这些外部链接可以增加你网站的可信度和权威性，对搜索引擎排名有积极影响。</p>\n\n<p><strong>10. 持续优化：</strong>定期监测和分析关键字的效果，根据数据调整和优化你的SEO策略。SEO是一个持续的过程，随着搜索引擎算法的变化，你需要不断调整和改进。</p>\n\n<h2 id=\"二-seo关键词研究seo关键词优化方式\">二. SEO关键词研究（SEO关键词优化方式）</h2>\n\n<p>关键词研究是任何一个SEO项目的第一步。\n如果你不知道用户在你的领域中到底搜索什么关键词的话，那么你的SEO决策一定是基于运气，而非数据驱动。这样是没有办法去运营你的业务的.</p>\n\n<h3 id=\"1-确保你优化的是正确的目标关键词\">1. 确保你优化的是正确的目标关键词</h3>\n\n<p>大多数人在设立目标关键词的时候，经常犯以下三个错误的一个。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>没有优化任何关键词；\n尝试优化过多的关键词；\n优化不相关的关键词。\n</code></pre>  </div></div>\n\n<p>你可以通过这一点来解决前两个问题：\n每一个页面或文章，只需要设定一个特定的主关键词或者是关键词主题。</p>\n\n<h5 id=\"小提示\">小提示:</h5>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>尝试避免在多个网页上定位相同的关键字也很重要。这是因为谷歌通常只会选择对其中一个页面进行排名，而这个页面，可能不是你希望他们排名的页面！\n\n选择正确关键字，一个好办法是：将你的页面发送给朋友并询问：“这个页面的内容是什么？”\n\n他们的答案通常会为你提供最佳的关键词或主题创意。但是，在确定之前，你一定要通过谷歌去搜索这个关键词。\n\n为什么？因为搜索结果可以帮助你了解谷歌是如何看某个特定关键词的。谷歌展现的是该特定关键字的最佳结果。如果大多数结果与你尝试排名的内容大不相同，那么它可能不是一个好的目标关键词。\n\n在谷歌中，关键词 “Outreach（外联）” 排名前3位的网页。这些结果与我们的内容大不相同，意味着这不是最佳目标关键词。\n具有大量SERP功能的关键词也是一样的（例如精选片段，Adwords广告，购物结果等）。\n\n因为这些功能效果会把10个自然的有机排名结果向下推，大大的降低了自然排名的点击率，降低了可以获取到的流量。那么，这个关键词很可能也不是最佳的目标关键词。\n</code></pre>  </div></div>\n\n<h3 id=\"2-通过关键词意图分析避免出现有独角兽特征的关键词\">2. 通过关键词意图分析，避免出现有“独角兽特征”的关键词</h3>\n\n<p>有时在进行研究时，你可能会发现一个搜索量特别多的关键词。但仅仅因为一个关键词具有较高的搜索量，并不代表它将是最佳的目标关键词。</p>\n\n<p>你必须考虑关键词背后的“搜索意图”（用户搜这个词是想找到什么）。</p>\n\n<p><strong>例子</strong>：“Google Analytics（谷歌分析）” 似乎是一个很好的关键字，乍一看，似乎可以尝试去排名。</p>\n\n<p>在美国，这个词每个月有100万的搜索量！但是,这些搜索中，绝大多数的人只是希望登录谷歌分析工具。他们可能甚至都不会注意到排名第二的页面。</p>\n\n<p>这就是所谓的关键词“独角兽”特征，看起来挺不错，但你几乎不能排到第一，就算你做到了，用户也不会点击你。</p>\n\n<p>现在，如果我们向下找找，我们可能会找到 “How to use Google Analytics （如何使用Google分析）” 这个词。</p>\n\n<p>这个词，每月有1,900次的搜索。这个多半是用户希望寻找谷歌分析工具的使用指南，这意味着它可能是一个非常不错的关键词，值得去追逐。</p>\n\n<p><strong>但请记住，并非所有的关键词设定都是看搜索量的（除非你做广告联盟）。</strong></p>\n\n<p>你最终是希望，让能够为业务带来价值的关键字参与排名（即那些能带来流量，并转化为潜在客户的关键词）。因此，你必须去定位那些搜索意图相关的关键词。</p>\n\n<p>以下是一些问题，有助于你去识别那些有 “独角兽特征”的关键词：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>搜索此关键词的人，是否可能想要购买你销售的产品？\n是否有明确的方法将此关键词的流量转换为销售线索？\n从业务角度来看，关键词是否有足够高的搜索量？\n搜索量是否来自你的目标国家或地区？ （即你的客户所在地）\n</code></pre>  </div></div>\n\n<p>如果这些问题的答案都是“不”，那么你可能是找到了一个有 “独角兽特征”的关键词。言下之意，不值得去追逐。</p>\n\n<h3 id=\"3-新域名权威性低找到低难度关键词快速排名\">3. 新域名权威性低？找到低难度关键词快速排名！</h3>\n\n<p>在用一个权威性低的新域名做网站,这样意味着很难把有竞争力的关键字拍上去。</p>\n\n<p>当然，在后期是可以做到排名的，但这并不容易。你可能需要创造非常优质的的内容，然后疯狂的的推广它（以获得曝光和外链）。</p>\n\n<p>所以，新站优先针对竞争力较弱的关键字进行优化，是有道理的。这是新站增长搜索流量最快的方式。</p>\n\n<h4 id=\"例子\">例子：</h4>\n\n<p>与 “Search Engine Optimization”（搜索引擎优化）相关的大多数关键词，具有非常高的关键词难度。\n但是，有一个关键词难度非常的低的词汇，似乎更容易排名.…..</p>\n\n<p><em>“What does SEO stand for”（SEO的意思是什么）</em></p>\n\n<h3 id=\"4-找到竞争对手的大流量入口关键词同时把它们偷过来\">4. 找到竞争对手的大流量入口关键词，同时把它们“偷”过来！</h3>\n\n<p>如果你能确切了解竞争对手排名的关键字，以及这些关键字带来的搜索流量，那会不会很酷？</p>\n\n<p>当然，你可以获取根据网上工具获取到这些关键词并进行分析。</p>\n\n<h4 id=\"小提示-1\">小提示:</h4>\n\n<p>Ahrefs普通账户（Lite Account）可以获得20名以前的，标准账户（Standard Account）可以获取到50名之前的，高级或机构账户（Advanced/Agency）则可以获取到100名以前的关键词。</p>\n\n<h3 id=\"5-设置竞争对手新关键词排名实时提醒\">5. 设置竞争对手新关键词排名实时提醒</h3>\n\n<p>通过监控竞争对手新的关键字排名，就可以关注到竞争对手采用的内容策略。</p>\n\n<p>为什么？因为如果你的竞争对手开始追逐一个新的关键词，那么说不定你也需要追逐它。</p>\n\n<p>这样做非常简单，但是非常的有效！</p>\n\n<h3 id=\"6-通过特定关键词排名第一的页面了解特定页面的流量潜力\">6. 通过特定关键词排名第一的页面，了解特定页面的“流量潜力”</h3>\n\n<p>大多数页面不单单只有特定关键词参与排名，同时会有很多长尾词也参与排名。</p>\n\n<p><strong>例如</strong> “<em>Keyword research”</em>（关键字研究）即主关键词，是有排名的。同时，它还参与了 “<em>How to do keyword research</em>”（如何做关键词研究），“<em>SEO Keyword research</em>”（SEO关键词研究）以及许多其他词的排名。</p>\n\n<p>因此，查看主关键字的搜索量，不会告诉我们这个页面的真实流量潜力。</p>\n\n<p>那么，如何判断关键字的流量潜力呢？检查排名第一的页面能够获得多少流量就可以了！</p>\n\n<p><strong>比如</strong>：关键词 “best VPN”（最好的VPN）的搜索量为105K。</p>\n\n<p>但是，在实际中，你会看到排名第一的页面，每月可能获得约180K+次的自然访问量。</p>\n\n<p>由于该页面针对许多长尾词都拥有对应的排名，因此关键词“Best VPN”（最好的VPN）的真实流量潜力，会远远超过报告的搜索量。</p>\n\n<h3 id=\"7-找到自己与竞争对手的内容差距并补充这些内容\">7. 找到自己与竞争对手的内容差距，并补充这些内容！</h3>\n\n<p>“Content Gap”（内容差距机会），指的是，竞争对手参与的关键词排名，而你没有参与的部分。</p>\n\n<p>这个是很糟糕,为了快速找到自己和竞争对手之间的内容差距，你可以通过网上搜索工具进行查询分析.</p>\n\n<h3 id=\"8-找到和主题相关的问题类关键词然后通过产出内容来回答这些问题\">8. 找到和主题相关的问题类关键词，然后通过产出内容来回答这些问题</h3>\n\n<p>问答网站（例如Quora）是一个非常好的获取关键字、以及内容创意的地方。</p>\n\n<p>其中的诀窍是，寻找多次被问过的问题，这个表明目前在谷歌上找不到好的答案。</p>\n\n<p>还有另外一个技巧,如果你发现谷歌中的某个关键词Quora排名前三，那么该关键字很有可能竞争度不高。如果它不是很有竞争力，作为目标词汇是个不错的选择！</p>\n","dir":"/blog/development/html/seo/","name":"2023-04-27_3.md","path":"blog/development/html/seo/2023-04-27_3.md","url":"/blog/development/html/seo/2023-04-27_3.html"},{"sort":3,"layout":"default","title":"Git常用操作命令","content":"<h1 id=\"git常用操作命令\">Git常用操作命令</h1>\n\n<h2 id=\"git配置gitignore操作\">git配置.gitignore操作</h2>\n<h3 id=\"git移除指定目录版本控制\">git移除指定目录版本控制</h3>\n<p>如果你想要移除 Git 版本控制系统中的某个指定目录，可以按照以下步骤进行操作：</p>\n\n<p>1.通过 cd 命令进入该 Git 仓库所在的目录。</p>\n\n<p>2.执行以下命令，将需要移除版本控制的目录添加到 .gitignore 文件中，例如，如果你想要移除名为 example 的目录，可以执行以下命令：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>echo \"example/\" &gt;&gt; .gitignore\n</code></pre>  </div></div>\n<p>注意，如果 .gitignore 文件还不存在，可以通过以下命令创建：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>touch .gitignore\n</code></pre>  </div></div>\n<p>3.执行以下命令，删除版本库中的指定目录，但不删除本地文件：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git rm -r --cached example\n</code></pre>  </div></div>\n<p>这条命令会将 example 目录从 Git 版本库中删除，并从 Git 跟踪列表中删除。注意，使用 –cached 选项来仅仅删除 Git 跟踪列表，而不会删除本地文件。</p>\n\n<p>4.执行以下命令，提交修改：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git commit -m \"Remove example directory from version control\"\n</code></pre>  </div></div>\n<p>这条命令会提交修改并添加一个提交信息，告诉 Git 你已经从版本控制中移除了 example 目录。</p>\n\n<p>5.执行以下命令，推送修改：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git push\n</code></pre>  </div></div>\n<p>这条命令会将修改推送到远程仓库。</p>\n\n<p>现在，example 目录已经被从版本控制中移除了。注意，这些操作不会删除本地文件，只会从 Git 版本控制系统中移除指定目录。如果需要删除本地文件，可以手动删除它们。</p>\n\n<h3 id=\"只忽略指定目录下的文件不忽略目录\">只忽略指定目录下的文件，不忽略目录</h3>\n<p>在.gitignore文件中，可以忽略指定目录下的文件，不忽略目录。但是，如果该目录下没有任何文件被跟踪，Git将不会包括该目录。在Git中，只有跟踪的文件才会被提交。</p>\n\n<p>如果你想要提交一个空目录，可以在该目录中添加一个.gitkeep文件，并将其添加到版本控制中。.gitkeep文件不需要任何内容，它只是作为一个标记来确保Git跟踪该目录。</p>\n\n<p>举个例子，在.gitignore中，忽略指定目录下的所有文件，但不忽略该目录下的：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/my_directory/*\n!/my_directory/.gitkeep\n</code></pre>  </div></div>\n<p>这样，在提交时，my_directory目录和.gitkeep文件将被包括在版本控制中。</p>\n\n<h2 id=\"git分支操作\">git分支操作</h2>\n<h3 id=\"git删除远程分支\">git删除远程分支</h3>\n<p>要删除 Git 远程分支，可以使用以下命令：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git push &lt;remote_name&gt; --delete &lt;branch_name&gt;\n</code></pre>  </div></div>\n<p>其中，<remote_name> 是你的远程仓库名称，一般为 origin；<branch_name> 是你要删除的分支名称。</branch_name></remote_name></p>\n\n<p>例如，要删除名为 my-feature-branch 的远程分支，可以使用以下命令：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>git push origin --delete my-feature-branch\n</code></pre>  </div></div>\n<p>执行完毕后，该分支就会被从远程仓库中删除。</p>\n","dir":"/blog/development/tool/git/","name":"2023-05-12_1.md","path":"blog/development/tool/git/2023-05-12_1.md","url":"/blog/development/tool/git/2023-05-12_1.html"},{"sort":3,"permalink":"/blog/development/java/","layout":"default","title":"Java笔记","content":"<h1 id=\"java笔记\">Java笔记</h1>\n\n<ul>\n <li><a href=\"/blog/development/java/jottings/\">随笔</a>\n <ul>\n <li><a href=\"/blog/development/java/jottings/2023-04-23_1.html\">Java学习大纲路径</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_1.html\">Spring中的事务回滚机制</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-04-27_2.html\">Java开发环境安装配置JDK+Maven+Tomcat</a></li>\n <li><a href=\"/blog/development/java/jottings/2023-05-12_1.html\">Restful风格开发方式</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/basics/\">Java基础</a>\n <ul>\n <li><a href=\"/blog/development/java/basics/2023-04-24_1.html\">Java中map常见操作集合</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_2.html\">Java中Json转换的常见操作方式</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-24_3.html\">Java中计算List求和或List对象中某个字段的总和</a></li>\n <li><a href=\"/blog/development/java/basics/2023-04-27_1.html\">Java中BigDecimal类型详解</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/java/tool/\">工具包</a>\n <ul>\n <li><a href=\"/blog/development/java/tool/2023-05-12_1.html\">EASYEXCEL使用详解</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/java/","name":"README.md","path":"blog/development/java/README.md","url":"/blog/development/java/"},{"sort":3,"layout":"default","title":"Java面试宝典三(2023最新Java面试题)","content":"<h1 id=\"java面试宝典三2023最新java面试题\">Java面试宝典三(2023最新Java面试题)</h1>\n\n<h2 id=\"一-springspring-mvc\"><strong>一. Spring/Spring MVC</strong></h2>\n\n<h3 id=\"1-为什么要使用-spring\"><strong>1. 为什么要使用 spring？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。\nspring 提供了事务支持，使得事务操作变的更加方便。\nspring 提供了面向切片编程，这样可以更方便的处理某一类的问题。\n更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。\n</code></pre>  </div></div>\n\n<h3 id=\"2-解释一下什么是-aop\"><strong>2. 解释一下什么是 aop？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。\n</code></pre>  </div></div>\n\n<p>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p>\n\n<h3 id=\"3-解释一下什么是-ioc\"><strong>3. 解释一下什么是 ioc？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。\n</code></pre>  </div></div>\n\n<p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p>\n\n<h3 id=\"4-spring-有哪些主要模块\"><strong>4. spring 有哪些主要模块？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。\nspring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。\nspring dao：Data Access Object 提供了JDBC的抽象层。\nspring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。\nspring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。\nspring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。\n</code></pre>  </div></div>\n\n<h3 id=\"5-spring-常用的注入方式有哪些\"><strong>5. spring 常用的注入方式有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>setter 属性注入\n构造方法注入\n注解方式注入\n</code></pre>  </div></div>\n\n<h3 id=\"6-spring-中的-bean-是线程安全的吗\"><strong>6. spring 中的 bean 是线程安全的吗？</strong></h3>\n\n<p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>\n\n<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>有状态就是有数据存储功能。\n无状态就是不会保存数据。\n</code></pre>  </div></div>\n\n<h3 id=\"7-spring-支持几种-bean-的作用域\"><strong>7. spring 支持几种 bean 的作用域？</strong></h3>\n\n<p>spring 支持 5 种作用域，如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；\nprototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；\n</code></pre>  </div></div>\n\n<p>Web 环境下的作用域：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>request：每次 http 请求都会创建一个 bean；\nsession：同一个 http session 共享一个 bean 实例；\nglobal-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。\n</code></pre>  </div></div>\n\n<p><strong>「注意：」</strong> 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>\n\n<h3 id=\"8-spring-自动装配-bean-有哪些方式\"><strong>8. spring 自动装配 bean 有哪些方式？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。\nbyName：它根据 bean 的名称注入对象依赖项。\nbyType：它根据类型注入对象依赖项。\n构造函数：通过构造函数来注入依赖项，需要设置大量的参数。\nautodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。\n</code></pre>  </div></div>\n\n<h3 id=\"9-spring-事务实现方式有哪些\"><strong>9. spring 事务实现方式有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。\n编码方式：提供编码的形式管理和维护事务。\n</code></pre>  </div></div>\n\n<h3 id=\"10-说一下-spring-的事务隔离\"><strong>10. 说一下 spring 的事务隔离？</strong></h3>\n\n<p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；\nISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；\nISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；\nISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；\nISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n「脏读」 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。\n「不可重复读」 ：是指在一个事务内，多次读同一数据。\n「幻读」 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。\n</code></pre>  </div></div>\n\n<h3 id=\"11-说一下-spring-mvc-运行流程\"><strong>11. 说一下 spring mvc 运行流程？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring mvc 先将请求发送给 DispatcherServlet。\nDispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。\nDispatcherServlet 再把请求提交到对应的 Controller。\nController 进行业务逻辑处理后，会返回一个ModelAndView。\nDispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。\n视图对象负责渲染返回给客户端。\n</code></pre>  </div></div>\n\n<h3 id=\"12-spring-mvc-有哪些组件\"><strong>12. spring mvc 有哪些组件？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>前置控制器 DispatcherServlet。\n映射控制器 HandlerMapping。\n处理器 Controller。\n模型和视图 ModelAndView。\n视图解析器 ViewResolver。\n</code></pre>  </div></div>\n\n<h3 id=\"13-requestmapping-的作用是什么\"><strong>13. @RequestMapping 的作用是什么？</strong></h3>\n\n<p>将 http 请求映射到相应的类/方法上。</p>\n\n<h3 id=\"14-autowired-的作用是什么\"><strong>14. @Autowired 的作用是什么？</strong></h3>\n\n<p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p>\n\n<h2 id=\"二-spring-bootspring-cloud\"><strong>二. Spring Boot/Spring Cloud</strong></h2>\n\n<h3 id=\"1-什么是-spring-boot\"><strong>1. 什么是 spring boot？</strong></h3>\n\n<p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p>\n\n<h3 id=\"2-为什么要用-spring-boot\"><strong>2. 为什么要用 spring boot？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>配置简单\n独立运行\n自动装配\n无代码生成和 xml 配置\n提供应用监控\n易上手\n提升开发效率\n</code></pre>  </div></div>\n\n<h3 id=\"3-spring-boot-核心配置文件是什么\"><strong>3. spring boot 核心配置文件是什么？</strong></h3>\n\n<p>spring boot 核心的两个配置文件：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；\napplication (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。\n</code></pre>  </div></div>\n\n<h3 id=\"4-spring-boot-配置文件有哪几种类型它们有什么区别\"><strong>4. spring boot 配置文件有哪几种类型？它们有什么区别？</strong></h3>\n\n<p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</p>\n\n<p>. properties 配置如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring.RabbitMQ.port=5672\n</code></pre>  </div></div>\n\n<p>. yml 配置如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>spring:    \n\tRabbitMQ:        \n\t\tport: 5672\n</code></pre>  </div></div>\n\n<p>yml 格式不支持 @PropertySource 注解导入。</p>\n\n<h3 id=\"5-spring-boot-有哪些方式可以实现热部署\"><strong>5. spring boot 有哪些方式可以实现热部署？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；\n使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。\n</code></pre>  </div></div>\n\n<h3 id=\"6-什么是-spring-cloud\"><strong>6. 什么是 spring cloud？</strong></h3>\n\n<p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p>\n\n<h3 id=\"7-spring-cloud-断路器的作用是什么\"><strong>7. spring cloud 断路器的作用是什么？</strong></h3>\n\n<p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>\n\n<h3 id=\"8-spring-cloud-的核心组件有哪些\"><strong>8. spring cloud 的核心组件有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Eureka：服务注册于发现。\nFeign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。\nRibbon：实现负载均衡，从一个服务的多台机器中选择一台。\nHystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。\nZuul：网关管理，由 Zuul 网关转发请求给对应的服务。\n</code></pre>  </div></div>\n\n<h2 id=\"三-hibernate\"><strong>三. Hibernate</strong></h2>\n\n<h3 id=\"1-为什么要使用-hibernate\"><strong>1. 为什么要使用 hibernate？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。\nhibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。\n可以很方便的进行数据库的移植工作。\n提供了缓存机制，是程序执行更改的高效。\n</code></pre>  </div></div>\n\n<h3 id=\"2-什么是-orm-框架\"><strong>2. 什么是 ORM 框架？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。\n</code></pre>  </div></div>\n\n<p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p>\n\n<h3 id=\"3-hibernate-中如何在控制台查看打印的-sql-语句\"><strong>3. hibernate 中如何在控制台查看打印的 SQL 语句？</strong></h3>\n\n<p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p>\n\n<h3 id=\"4-hibernate-有几种查询方式\"><strong>4. hibernate 有几种查询方式？</strong></h3>\n\n<p>三种：hql、原生 SQL、条件查询 Criteria。</p>\n\n<h3 id=\"5-hibernate-实体类可以被定义为-final-吗\"><strong>5. hibernate 实体类可以被定义为 final 吗？</strong></h3>\n\n<p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p>\n\n<h3 id=\"6-在-hibernate-中使用-integer-和-int-做映射有什么区别\"><strong>6. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？</strong></h3>\n\n<p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p>\n\n<h3 id=\"7-hibernate-是如何工作的\"><strong>7. hibernate 是如何工作的？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>读取并解析配置文件。\n读取并解析映射文件，创建 SessionFactory。\n打开 Session。\n创建事务。\n进行持久化操作。\n提交事务。\n关闭 Session。\n关闭 SessionFactory。\n</code></pre>  </div></div>\n\n<h3 id=\"8-get和-load的区别\"><strong>8. get()和 load()的区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。\nload()支持延迟加载；get() 不支持延迟加载。\n</code></pre>  </div></div>\n\n<h3 id=\"9-说一下-hibernate-的缓存机制\"><strong>9. 说一下 hibernate 的缓存机制？</strong></h3>\n\n<p>hibernate 常用的缓存有一级缓存和二级缓存：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；\n\n二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。\n</code></pre>  </div></div>\n\n<h3 id=\"10-hibernate-对象有哪些状态\"><strong>10. hibernate 对象有哪些状态？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。\n持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。\n游离状态：Session 关闭之后对象就是游离状态。\n</code></pre>  </div></div>\n\n<h3 id=\"11-在-hibernate-中-getcurrentsession-和-opensession-的区别是什么\"><strong>11. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>getCurrentSession 会绑定当前线程，而 openSession 则不会。\ngetCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。\n</code></pre>  </div></div>\n\n<h3 id=\"12-hibernate-实体类必须要有无参构造函数吗为什么\"><strong>12. hibernate 实体类必须要有无参构造函数吗？为什么？</strong></h3>\n\n<p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p>\n\n<h3 id=\"13-jpa-和-hibernate-有什么区别\"><strong>13. jpa 和 hibernate 有什么区别？</strong></h3>\n\n<p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p>\n\n<h2 id=\"四-mybatis\"><strong>四. MyBatis</strong></h2>\n\n<h3 id=\"1-mybatis-中-和-的区别是什么\"><strong>1. MyBatis 中 #{}和 ${}的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>`#{}`是预编译处理\n`${}`是字符替换。 在使用 `#{}`时，MyBatis 会将 SQL 中的 `#{}`替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。\n</code></pre>  </div></div>\n\n<h3 id=\"2-mybatis-有几种分页方式\"><strong>2. MyBatis 有几种分页方式？</strong></h3>\n\n<p>分页方式：逻辑分页和物理分页。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>「逻辑分页：」** 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。\n\n「物理分页：」** 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。\n</code></pre>  </div></div>\n\n<h3 id=\"3-rowbounds-是一次性查询全部结果吗为什么\"><strong>3. RowBounds 是一次性查询全部结果吗？为什么？</strong></h3>\n\n<p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>\n\n<h3 id=\"4-mybatis-逻辑分页和物理分页的区别是什么\"><strong>4. MyBatis 逻辑分页和物理分页的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。\n\n物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。\n</code></pre>  </div></div>\n\n<h3 id=\"5-mybatis-是否支持延迟加载延迟加载的原理是什么\"><strong>5. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。\n</code></pre>  </div></div>\n\n<p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。</p>\n\n<p>比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p>\n\n<h3 id=\"6-说一下-mybatis-的一级缓存和二级缓存\"><strong>6. 说一下 MyBatis 的一级缓存和二级缓存？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。\n二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。\n</code></pre>  </div></div>\n\n<p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>\n\n<p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>\n\n<h3 id=\"7-mybatis-和-hibernate-的区别有哪些\"><strong>7. MyBatis 和 hibernate 的区别有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。\n可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。\n学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。\n二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。\n</code></pre>  </div></div>\n\n<h3 id=\"8-mybatis-有哪些执行器executor\"><strong>8. MyBatis 有哪些执行器（Executor）？</strong></h3>\n\n<p>MyBatis 有三种基本的Executor执行器：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；\nReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；\nBatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。\n</code></pre>  </div></div>\n\n<h3 id=\"9-mybatis-分页插件的实现原理是什么\"><strong>9. MyBatis 分页插件的实现原理是什么？</strong></h3>\n\n<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>\n\n<h3 id=\"10-mybatis-如何编写一个自定义插件\"><strong>10. MyBatis 如何编写一个自定义插件？</strong></h3>\n\n<p><strong>「自定义插件实现原理」</strong></p>\n\n<p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；\nStatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；\n\nParameterHandler：拦截参数的处理；\nResultSetHandler：拦截结果集的处理。\n</code></pre>  </div></div>\n\n<p><strong>「自定义插件实现关键」</strong></p>\n\n<p>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>public interfaceInterceptor{      \n\tObject intercept(Invocation invocation) throws Throwable;\n\t\n\tObject plugin(Object target);\n\t\n\tvoidsetProperties(Properties properties);\n}\n\nsetProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；\nplugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；\nintercept 方法就是要进行拦截的时候要执行的方法。\n</code></pre>  </div></div>\n\n<p><strong>「自定义插件实现示例」</strong></p>\n\n<p>官方插件实现：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>@Intercepts({@Signature(type = Executor.class, method= \"query\", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})})\npublic class TestInterceptor implements Interceptor{   \n\tpublic Object intercept(Invocation invocation) throws Throwable {     \n\t\tObject target = invocation.getTarget(); //被代理对象     \n\t\tMethod method = invocation.getMethod(); //代理方法     \n\t\tObject[] args = invocation.getArgs(); //方法参数     \n\t\t// do something . . . . . .  方法拦截前执行代码块     \n\t\tObject result = invocation. proceed();     \n\t\t// do something . . . . . . . 方法拦截后执行代码块     \n\t\treturn result;   \n\t}  \n\tpublic Object plugin(Object target){     \n\t\treturn Plugin. wrap(target, this);   \n\t}\n}\n</code></pre>  </div></div>\n","dir":"/blog/development/interview/java/","name":"2023-04-23_3.md","path":"blog/development/interview/java/2023-04-23_3.md","url":"/blog/development/interview/java/2023-04-23_3.html"},{"sort":3,"layout":"default","title":"Java中计算List求和或List对象中某个字段的总和","content":"<h1 id=\"java中计算list求和或list对象中某个字段的总和\">Java中计算List求和或List对象中某个字段的总和</h1>\n\n<h2 id=\"一-使用循环遍历list对象累加求和\">一. 使用循环遍历List对象，累加求和</h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nint sum = 0;\nfor (int number : numbers) {\n    sum += number;\n}\nSystem.out.println(\"List总和：\" + sum);\n\n</code></pre>  </div></div>\n<p>如果要计算List中某个字段的总和，假设有一个包含Person对象的List，每个Person对象有一个age字段：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Person&gt; persons = Arrays.asList(\n    new Person(\"John\", 25),\n    new Person(\"Jane\", 30),\n    new Person(\"Mike\", 35)\n);\nint sum = 0;\nfor (Person person : persons) {\n    sum += person.getAge();\n}\nSystem.out.println(\"年龄总和：\" + sum);\n\n</code></pre>  </div></div>\n\n<h2 id=\"二-java-8的stream-apilist-stream计算对象list中某个字段的总和\">二. Java 8的Stream API，list stream:计算对象List中某个字段的总和</h2>\n\n<h3 id=\"计算一个number类型的list对象总和\">计算一个number类型的List对象总和</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\nint sum = numbers.stream().mapToInt(Integer::intValue).sum();\nSystem.out.println(\"List总和：\" + sum);\n</code></pre>  </div></div>\n<p>或者</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Integer[] integerArray = {1, 3, 5, 10, 18};\n\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(integerArray));\n\nIntSummaryStatistics summaryStatistics = list.stream().mapToInt((s) -&gt; s).summaryStatistics();\nSystem.out.println(\"总和：\" + summaryStatistics.getSum());\nSystem.out.println(\"平均数：\" + summaryStatistics.getAverage());\nSystem.out.println(\"总个数：\" + summaryStatistics.getCount());\nSystem.out.println(\"最大值：\" + summaryStatistics.getMax());\nSystem.out.println(\"最小值：\" + summaryStatistics.getMin());\n</code></pre>  </div></div>\n\n<h3 id=\"计算一个list对象中某个字段总和\">计算一个List对象中某个字段总和</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;Person&gt; persons = Arrays.asList(\n    new Person(\"John\", 25),\n    new Person(\"Jane\", 30),\n    new Person(\"Mike\", 35)\n);\nint sum = persons.stream().mapToInt(Person::getAge).sum();\nSystem.out.println(\"年龄总和：\" + sum);\n</code></pre>  </div></div>\n<p>或者</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>List&lt;User&gt; userList = new ArrayList&lt;&gt;();\nUser user1 = new User();\nuser1.setAge(10);\nuserList.add(user1);\nUser user2 = new User();\nuser2.setAge(20);\nuserList.add(user2);\nUser user3 = new User();\nuser3.setAge(25);\nuserList.add(user3);\n\nint ageSum = userList.stream().collect(Collectors.summingInt(User::getAge));\nSystem.out.println(\"年龄总和 ：\" + ageSum);\n</code></pre>  </div></div>\n\n<h3 id=\"java-stream-计算总和-stream聚合函数对bigdecimal求和\">Java Stream 计算总和 Stream聚合函数对BigDecimal求和</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> BigDecimal sum = selectList.stream().map(SxLoss::getLossAmount).reduce(BigDecimal.ZERO, BigDecimal::add);\n</code></pre>  </div></div>\n<p>注意：有可能会报错，因为对象中某个值为空，因此需要增加判断</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> BigDecimal sum = selectList.stream().map(SxLoss::getLossAmount).filter(lossAmount -&gt; lossAmount != null).reduce(BigDecimal.ZERO, BigDecimal::add);\n</code></pre>  </div></div>\n\n<p><strong>注：</strong>以上几种方法都可以计算List的总和或List对象中某个字段的总和。选择使用哪种方法取决于具体的需求和使用的Java版本。</p>\n","dir":"/blog/development/java/basics/","name":"2023-04-24_3.md","path":"blog/development/java/basics/2023-04-24_3.md","url":"/blog/development/java/basics/2023-04-24_3.html"},{"sort":3,"layout":"default","title":"Java中BigDecimal类型详解","content":"<h1 id=\"java中bigdecimal类型详解\">Java中BigDecimal类型详解</h1>\n\n<p>在使用BigDecimal类型时,非常容易用错,Java中的简单浮点数类型float和double直接运算，精度不准，推荐使用 BigDecimal 计算。</p>\n\n<p>BigDecimal 是 Java 中用于高精度计算的类，它提供了精确的数值运算，避免了浮点数计算时的精度丢失问题。</p>\n\n<h2 id=\"一-bigdecimal构造\">一. BigDecimal构造</h2>\n<h3 id=\"构造方法\">构造方法</h3>\n<p>BigDecimal 可以通过多种方式进行实例化，包括使用整数、浮点数、字符串或字符数组等作为参数。例如：</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>BigDecimal value = new BigDecimal(10); 使用整数实例化 BigDecimal。\nBigDecimal value = new BigDecimal(\"3.14159\"); 使用字符串实例化 BigDecimal。\n</code></pre>  </div></div>\n<p><strong>不可变性：</strong>BigDecimal 对象是不可变的，一旦创建就不能修改其值。每次运算操作都会返回一个新的 BigDecimal 对象，保证了线程安全性。</p>\n\n<h2 id=\"二-bigdecimal类型的加减乘除bigdecimal高精度计算\">二. BigDecimal类型的加减乘除(BigDecimal高精度计算)</h2>\n<p>高精度计算：BigDecimal 可以处理任意位数的整数和小数，因此可以进行高精度的数值计算，避免了浮点数运算的精度损失问题。</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>BigDecimal bignum1 = new BigDecimal(10.0);  \nBigDecimal bignum2 = new BigDecimal(10.0);\n</code></pre>  </div></div>\n<h3 id=\"加法\">加法</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>add =  bignum1.add(bignum2);\n</code></pre>  </div></div>\n<h3 id=\"减法\">减法</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>subtract = bignum1.subtract(bignum2);\n</code></pre>  </div></div>\n<h3 id=\"乘法\">乘法</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>multiply = bignum1.multiply(bignum2);\n</code></pre>  </div></div>\n<h3 id=\"除法\">除法</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>divide = bignum1.divide(bignum2);\n\n.divide(new BigDecimal(18),2, BigDecimal.ROUND_HALF_UP) // &gt;=5 四舍五入\n</code></pre>  </div></div>\n<p><em>注意</em>:除法的时候一定要在divide方法中传递第二个参数，定义精确到小数点后几位，否则在不整除的情况下，结果是无限循环小数时，就会抛出异常：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result。\n</code></pre>  </div></div>\n<p>一个简单的测试类：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    @Test\n    public void redisTestjisuan(){\n        BigDecimal benjin = new BigDecimal(100000.00);\n        int qishu = 3;\n        BigDecimal lilv = new BigDecimal(0.015);\n        // 每月还款额=[贷款本金×月利率×（1+月利率）^还款月数]÷[（1+月利率）^还款月数－1]\n        BigDecimal big = (lilv.add(new BigDecimal(1.0)).pow(qishu)).subtract(new BigDecimal(1));\n        BigDecimal divide = (benjin.multiply(lilv).multiply(lilv.add(new BigDecimal(1.0)).pow(qishu))).divide(big,2,RoundingMode.HALF_UP);\n        logger.info(\"每月还款额=\"+divide);\n \n    }\n</code></pre>  </div></div>\n<h3 id=\"精度和舍入\">精度和舍入</h3>\n<p>BigDecimal 可以指定精度和舍入模式来进行运算。精度表示小数部分的位数，舍入模式定义了舍入时的规则。常见的舍入模式包括 ROUND_UP（向上舍入）、ROUND_DOWN（向下舍入）和 ROUND_HALF_UP（四舍五入）等。</p>\n\n<h3 id=\"比较操作\">比较操作</h3>\n<p>BigDecimal 提供了比较操作来判断两个 BigDecimal 对象的大小关系。可以使用 compareTo 方法来进行比较，返回值为负数、零或正数，分别表示小于、等于或大于。</p>\n\n<h3 id=\"格式化和转换\">格式化和转换</h3>\n<p>BigDecimal 支持格式化输出和字符串转换，可以根据需要将 BigDecimal 对象转换为字符串或其他数值类型。</p>\n\n","dir":"/blog/development/java/basics/","name":"2023-04-27_1.md","path":"blog/development/java/basics/2023-04-27_1.md","url":"/blog/development/java/basics/2023-04-27_1.html"},{"sort":3,"permalink":"/blog/life/","layout":"default","title":"生活随笔","content":"<h1 id=\"生活随笔\">生活随笔</h1>\n<p>生活随笔</p>\n\n<ul>\n <li><a href=\"/blog/life/travel/\">趣事小记</a></li>\n <li><a href=\"/blog/life/poetry/\">诗词鉴赏</a></li>\n</ul>\n","dir":"/blog/life/","name":"README.md","path":"blog/life/README.md","url":"/blog/life/"},{"sort":3,"layout":"default","title":"html表格导出excel有几种方式","content":"<h1 id=\"html表格导出excel有几种方式\">html表格导出excel有几种方式</h1>\n\n<h2 id=\"一-前后端结合\">一. 前后端结合</h2>\n<p>利用 JavaScript 将表格内容转换为 Excel 文件格式，然后通过 Ajax 请求将文件数据发送给后台，再由后台返回该文件数据流，前端再通过浏览器下载功能将其下载。这种方式可以使用第三方 JavaScript 库如 SheetJS、xlsx-populate、Export-Excel 等来简化操作。</p>\n\n<h2 id=\"二-后台解析返回前端下载\">二. 后台解析，返回前端下载</h2>\n<p>使用服务端技术如 Java、Python、PHP 等，读取前端提交的表格数据，将其转换为 Excel 文件并返回给前端进行下载。</p>\n\n<h2 id=\"前端插件解析\">前端插件解析</h2>\n<p>使用前端插件如 jQuery Export Table Plugin、Bootstrap Table Export、TableExport 等，直接将表格导出为 Excel 文件并在浏览器中下载。这种方式通常需要在页面中引入插件相关的 JavaScript 库。</p>\n\n<h3 id=\"三-使用js-xlsx插件导出excel\">三. 使用js-xlsx插件导出excel</h3>\n<p>官方github：https://github.com/SheetJS/js-xlsx</p>\n\n<h4 id=\"1-将html页面中一个table导出excel\">1. 将html页面中一个table导出excel</h4>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>function exportToExcel(tableId, fileName) {\n  var wb = XLSX.utils.table_to_book(document.getElementById(tableId));\n  var wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'binary' });\n\n  function s2ab(s) {\n    var buf = new ArrayBuffer(s.length);\n    var view = new Uint8Array(buf);\n    for (var i = 0; i &lt; s.length; i++) {\n      view[i] = s.charCodeAt(i) &amp; 0xff;\n    }\n    return buf;\n  }\n\n  saveAs(new Blob([s2ab(wbout)], { type: 'application/octet-stream' }), fileName);\n}\n</code></pre>  </div></div>\n\n<p>saveAs() 函数是由 FileSaver.js 库提供的，它可以将一个 Blob 或者 File 对象保存到本地文件系统。在示例中，我们将该函数挂载到了 window 对象上，可以在任何地方调用。如果需要使用该函数，需要先引入 FileSaver.js 库，可以通过以下方式获取：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js\"&gt;&lt;/script&gt;\n</code></pre>  </div></div>\n\n<p>使用示例：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;!-- html表格 --&gt;\n&lt;table id=\"myTable\"&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Name&lt;/th&gt;\n      &lt;th&gt;Age&lt;/th&gt;\n      &lt;th&gt;Country&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;td&gt;John&lt;/td&gt;\n      &lt;td&gt;25&lt;/td&gt;\n      &lt;td&gt;USA&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Jane&lt;/td&gt;\n      &lt;td&gt;30&lt;/td&gt;\n      &lt;td&gt;Canada&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Bob&lt;/td&gt;\n      &lt;td&gt;35&lt;/td&gt;\n      &lt;td&gt;Australia&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n\n&lt;!-- 导出按钮 --&gt;\n&lt;button onclick=\"exportToExcel('myTable', 'myFile.xlsx')\"&gt;Export to Excel&lt;/button&gt;\n</code></pre>  </div></div>\n\n<p>在上面的示例中，exportToExcel函数接受两个参数：表格的ID和导出的文件名。该函数使用js-xlsx插件将表格转换为Excel文件，并使用FileSaver.js库将生成的文件下载到本地计算机。</p>\n\n<h4 id=\"2-将html页面中两个table导出到一个excel\">2. 将html页面中两个table导出到一个excel</h4>\n<p>将js代码修改为</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>FleetCost.export = function () {\n    var wb1 = XLSX.utils.table_to_book(document.getElementById(\"table1\"));\n    var wb2 = XLSX.utils.table_to_book(document.getElementById(\"table2\"));\n    var workbook = XLSX.utils.book_new();\n    XLSX.utils.book_append_sheet(workbook, wb1.Sheets[wb1.SheetNames[0]], \"Table1\");\n    XLSX.utils.book_append_sheet(workbook, wb2.Sheets[wb2.SheetNames[0]], \"Table2\");\n    var wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'binary' });\n\n    function s2ab(s) {\n        var buf = new ArrayBuffer(s.length);\n        var view = new Uint8Array(buf);\n        for (var i = 0; i &lt; s.length; i++) {\n            view[i] = s.charCodeAt(i) &amp; 0xff;\n        }\n        return buf;\n    }\n    saveAs(new Blob([s2ab(wbout)], { type: 'application/octet-stream' }), \"myFile.xlsx\");\n}\n\n</code></pre>  </div></div>\n<p>其中，table1和table2是两个html中的table元素。这里先分别将它们转化为workbook，再使用XLSX.utils.book_new()创建一个新的workbook，然后使用XLSX.utils.book_append_sheet()将两个表格分别添加到workbook中，最后使用XLSX.write()将workbook转换为二进制数据，保存为excel文件即可。</p>\n","dir":"/blog/development/html/jottings/","name":"2023-05-12_1.md","path":"blog/development/html/jottings/2023-05-12_1.md","url":"/blog/development/html/jottings/2023-05-12_1.html"},{"sort":3,"layout":"default","title":"免费的Jekyll静态网站发布平台","content":"<h1 id=\"免费的jekyll静态网站发布平台\">免费的Jekyll静态网站发布平台</h1>\n<p>Jekyll是一款基于Ruby的静态网站生成器，可以将纯文本文件转化为静态网页，不需要数据库和服务器端脚本。以下是一些免费的Jekyll静态网站发布平台</p>\n\n<h2 id=\"github-pages\">GitHub Pages</h2>\n<p><a href=\"https://pages.github.com/\">GitHub Pages</a>是一个由GitHub提供的免费托管静态网站的服务，支持使用Jekyll作为网站生成器，可以在自己的GitHub仓库中发布Jekyll网站。</p>\n\n<h2 id=\"vercel\">Vercel</h2>\n<p><a href=\"https://vercel.com/\">Vercel</a> 是一个云端 Serverless 部署平台，它允许开发者在没有服务器的情况下部署和扩展应用程序。它支持多种编程语言和框架，包括 Next.js、Nuxt.js、React、Angular、Vue 等，提供高性能和可扩展性，可以轻松扩展应用程序。</p>\n\n<p>Vercel 提供了一个简单易用的用户界面和 CLI 工具，使得开发者可以轻松地在几分钟内部署他们的应用程序。它还提供了强大的自动化工具，如持续集成、自动部署和自动缩放，使得开发者可以专注于编写代码而不用担心基础设施的维护和管理。</p>\n\n<p>Vercel 的优点包括快速、易用、高性能、自动化和弹性扩展，它是构建现代 Web 应用程序的一种优秀选择。</p>\n\n<h2 id=\"netlify\">Netlify</h2>\n<p><a href=\"https://app.netlify.com/\">Netlify</a>是一款功能强大的静态网站发布平台，支持Jekyll和其他静态网站生成器，可以将网站发布到自定义域名或Netlify提供的子域名上。</p>\n\n<h2 id=\"gitlab-pages\">GitLab Pages</h2>\n<p><a href=\"https://gitlab.com/\">GitLab Pages</a>是一个由GitLab提供的类似GitHub Pages的静态网站托管服务，支持使用Jekyll作为网站生成器。</p>\n\n<h2 id=\"surge\">Surge</h2>\n<p><a href=\"https://surge.sh/\">Surge</a>是一款快速、简单的静态网站托管服务，支持使用Jekyll作为网站生成器，并提供快速的网站部署和更新功能。</p>\n\n<p>这些平台都提供了免费的静态网站托管服务，并且都支持使用Jekyll作为网站生成器。用户可以根据自己的需求和喜好选择合适的平台。</p>\n","dir":"/blog/development/html/webdesign/","name":"2023-05-12_1.md","path":"blog/development/html/webdesign/2023-05-12_1.md","url":"/blog/development/html/webdesign/2023-05-12_1.html"},{"sort":3,"layout":"default","title":"Java开发环境安装配置JDK+Maven+Tomcat","content":"<h1 id=\"java开发环境安装配置jdkmaventomcat\">Java开发环境安装配置JDK+Maven+Tomcat</h1>\n\n<p>配置环境:Windows10专业版\n注:建议为专业版,其他版本权限有可能有缺失.</p>\n\n<h2 id=\"一安装jdk18\">一.安装JDK1.8</h2>\n<h3 id=\"安装jdk\">安装JDK</h3>\n<p>进行java开发，首先要安装jdk，安装了jdk后还要进行环境变量配置：</p>\n<h4 id=\"1-下载jdkhttpswwworaclecomtechnetworkjavajavasedownloadsindexhtml\">1. 下载jdk（https://www.oracle.com/technetwork/java/javase/downloads/index.html).</h4>\n<p>此处提供:jdk-8u181-windows-x64<br />\n链接：https://pan.baidu.com/s/1c9vh7TRak5uhDstMO7TtxQ \n提取码：pm4c</p>\n\n<p>在下载页面中你需要选择接受许可，并根据自己的系统选择对应的版本,EXE和zip都可以,两种不同的安装方式而已.</p>\n\n<h4 id=\"2-安装\">2. 安装</h4>\n<p>安装过程中会出现两次 安装提示 :\n第一次是安装 jdk ，第二次是安装 jre 。\n建议两个都安装在同一个java文件夹中的不同文件夹中。（不能都安装在java文件夹的根目录下，jdk和jre安装在同一文件夹会出错）</p>\n\n<h3 id=\"进行环境变量配置\">进行环境变量配置</h3>\n<p>计算机→属性→高级系统设置→高级→环境变量</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>JAVA_HOME:\t此处根据自己安装的路径写\nPath:\t%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;（注意变量值之间用“;”隔开）\nCLASSPATH :\t.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar\n</code></pre>  </div></div>\n\n<p>注:前面有英文句号.不能缺少</p>\n<h3 id=\"3-检验\">3. 检验</h3>\n<p>1.是否配置成功 运行cmd 输入 java -version （java 和 -version 之间有空格）\n若如图所示 显示版本信息 则说明安装和配置成功。</p>\n\n<p>2.补充环境变量的解析:\nJAVA_HOME:jdk的安装路径\nclasspath:java加载类路径，只有类在classpath中java命令才能识别，在路径前加了个”.”表示当前路径。\npath：系统在任何路径下都可以识别java,javac命令</p>\n\n<p>3.注:若显示报错,解决方案:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.详细检查安装路径及书写路径\n2.将路径中的%JAVA_HOME%都改为JAVA_HOME路径:C:\\Java\\jdk1.7.0(此处根据自己地址)\n若还未解决,请百度解决.\n</code></pre>  </div></div>\n\n<h2 id=\"二安装maven\">二.安装maven</h2>\n<p>链接：https://pan.baidu.com/s/1GRHFyAnXrF09cJ7frsCvww \n提取码：gasy</p>\n\n<h3 id=\"1-安装\">1. 安装</h3>\n<p>选择安装目录,解压,\n进入conf文件夹,配置项目maven库地址,阿里或公司的私服.\nsettings.xml</p>\n\n<h3 id=\"2-配置环境变量\">2. 配置环境变量</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>MAVEN_HOME      安装目录\nPath    %MAVEN_HOME%\\bin\\;\n</code></pre>  </div></div>\n\n<h3 id=\"3-检测\">3. 检测</h3>\n<p>cmd输入mvn -v或mvn验证是否配置成功\n自动生成两个文件夹:C:\\Users\\Administrator.m2\\repository –&gt; 本地仓库目录</p>\n\n<p>注意：如果觉得在中央仓库下载jar的时候很慢，可以试试阿里云提供的maven仓库\n在settings.xml文件里的mirrors节点添加如下子节点：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;mirror&gt;  \n    &lt;id&gt;nexus-aliyun&lt;/id&gt;  \n    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    \n    &lt;name&gt;Nexus aliyun&lt;/name&gt;  \n    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;  \n&lt;/mirror&gt; \n</code></pre>  </div></div>\n\n<p>此处提供已经配置好的配置文件,需要的可以直接下载:\n链接：https://pan.baidu.com/s/1QNjWeP1vJVptpG40Wwq-SA \n提取码：yz5d</p>\n\n<h2 id=\"三安装tomcat\">三.安装Tomcat</h2>\n<p>此处提供下载apache-tomcat-7.0.92:\n链接：https://pan.baidu.com/s/1zUyWTIRfYqVbczKyZtMVOw \n提取码：jgrs</p>\n\n<p>下载tomcat后解压到自己想要安装的位置，同Java环境变量的配置，新建以下四个变量（已存在则进行编辑）：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>TOMCAT_HOME：C:\\Program Files\\tomcat　　　　//tomcat安装路径，到bin上一层。\n\nCATALINA_HOME：C:\\Program Files\\tomcat　　　　//同上\n\nPath：%CATALINA_HOME%\\bin\n\nCLASSPATH：%CATALINA_HOME%\\lib\\servlet-api.jar\n</code></pre>  </div></div>\n\n<p>　　配置好以后，在cmd下cd到C:\\Program Files\\tomcat\\bin(你的安装目录)，运行“service install Tomcat7”命令即可。\n　　在浏览器地址栏输入“http://localhost”出现以下画面即使安装成功了：</p>\n\n<p>tomcat的默认端口是8080，若是想修改端口，在“conf”文件夹下找到“server.xml”，将文件中的“Connector port=’8088’”的8080修改为自己要的端口号，保存后重启tomcat即可。</p>\n","dir":"/blog/development/java/jottings/","name":"2023-04-27_2.md","path":"blog/development/java/jottings/2023-04-27_2.md","url":"/blog/development/java/jottings/2023-04-27_2.html"},{"sort":4,"layout":"default","title":"Java面试宝典四(2023最新Java面试题)","content":"<h1 id=\"java面试宝典四2023最新java面试题\">Java面试宝典四(2023最新Java面试题)</h1>\n\n<h2 id=\"一-rabbitmq\"><strong>一. RabbitMQ</strong></h2>\n\n<h3 id=\"1-rabbitmq-的使用场景有哪些\"><strong>1. RabbitMQ 的使用场景有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>抢购活动：削峰填谷，防止系统崩塌。\n延迟信息处理：比如 10 分钟之后给下单未付款的用户发送邮件提醒。\n解耦系统：对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。\n</code></pre>  </div></div>\n\n<h3 id=\"2-rabbitmq-有哪些重要的角色\"><strong>2. RabbitMQ 有哪些重要的角色？</strong></h3>\n\n<p>RabbitMQ中重要的角色有：生产者、消费者和代理：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>生产者：消息的创建者，负责创建和推送数据到消息服务器；\n消费者：消息的接收方，用于处理数据和确认消息；\n代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。\n</code></pre>  </div></div>\n\n<h3 id=\"3-rabbitmq-有哪些重要的组件\"><strong>3. RabbitMQ 有哪些重要的组件？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。\nChannel（信道）：消息推送使用的通道。\nExchange（交换器）：用于接受、分配消息。\nQueue（队列）：用于存储生产者的消息。\nRoutingKey（路由键）：用于把生成者的数据分配到交换器上。\nBindingKey（绑定键）：用于把交换器的消息绑定到队列上。\n</code></pre>  </div></div>\n\n<h3 id=\"4-rabbitmq-中-vhost-的作用是什么\"><strong>4. RabbitMQ 中 vhost 的作用是什么？</strong></h3>\n\n<p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p>\n\n<h3 id=\"5-rabbitmq-的消息是怎么发送的\"><strong>5. RabbitMQ 的消息是怎么发送的？</strong></h3>\n\n<p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>\n\n<h3 id=\"6-rabbitmq-怎么保证消息的稳定性\"><strong>6. RabbitMQ 怎么保证消息的稳定性？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>提供了事务的功能。\n通过将 channel 设置为 confirm（确认）模式。\n</code></pre>  </div></div>\n\n<h3 id=\"7-rabbitmq-怎么避免消息丢失\"><strong>7. RabbitMQ 怎么避免消息丢失？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>把消息持久化磁盘，保证服务器重启消息不丢失。\n每个集群中至少有一个物理磁盘，保证消息落入磁盘。\n</code></pre>  </div></div>\n\n<h3 id=\"8-要保证消息持久化成功的条件有哪些\"><strong>8. 要保证消息持久化成功的条件有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>声明队列必须设置持久化 durable 设置为 true.\n消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。\n消息已经到达持久化交换器。\n消息已经到达持久化队列。\n</code></pre>  </div></div>\n\n<p>以上四个条件都满足才能保证消息持久化成功。</p>\n\n<h3 id=\"9-rabbitmq-持久化有什么缺点\"><strong>9. RabbitMQ 持久化有什么缺点？</strong></h3>\n\n<p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p>\n\n<h3 id=\"10-rabbitmq-有几种广播类型\"><strong>10. RabbitMQ 有几种广播类型？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。\nheaders：与 direct 类似，只是性能很差，此类型几乎用不到。\nfanout：分发模式，把消费分发给所有订阅者。\ntopic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。\n</code></pre>  </div></div>\n\n<h3 id=\"11-rabbitmq-怎么实现延迟消息队列\"><strong>11. RabbitMQ 怎么实现延迟消息队列？</strong></h3>\n\n<p>延迟队列的实现有两种方式：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；\n使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。\n</code></pre>  </div></div>\n\n<h3 id=\"12-rabbitmq-集群有什么用\"><strong>12. RabbitMQ 集群有什么用？</strong></h3>\n\n<p>集群主要有以下两个用途：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；\n高容量：集群可以承载更多的消息量。\n</code></pre>  </div></div>\n\n<h3 id=\"13-rabbitmq-节点的类型有哪些\"><strong>13. RabbitMQ 节点的类型有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>磁盘节点：消息会存储到磁盘。\n内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。\n</code></pre>  </div></div>\n\n<h3 id=\"14-rabbitmq-集群搭建需要注意哪些问题\"><strong>14. RabbitMQ 集群搭建需要注意哪些问题？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>各节点之间使用“--link”连接，此属性不能忽略。\n各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。\n整个集群中必须包含一个磁盘节点。\n</code></pre>  </div></div>\n\n<h3 id=\"15-rabbitmq-每个节点是其他节点的完整拷贝吗为什么\"><strong>15. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</strong></h3>\n\n<p>不是，原因有以下两个：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；\n性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。\n</code></pre>  </div></div>\n\n<h3 id=\"16-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况\"><strong>16. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</strong></h3>\n\n<p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>不能创建队列\n不能创建交换器\n不能创建绑定\n不能添加用户\n不能更改权限\n不能添加和删除集群节点\n</code></pre>  </div></div>\n\n<p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p>\n\n<h3 id=\"17-rabbitmq-对集群节点停止顺序有要求吗\"><strong>17. RabbitMQ 对集群节点停止顺序有要求吗？</strong></h3>\n\n<p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>\n\n<h2 id=\"二-kafka\"><strong>二. Kafka</strong></h2>\n\n<h3 id=\"1-kafka-可以脱离-zookeeper-单独使用吗为什么\"><strong>1. kafka 可以脱离 zookeeper 单独使用吗？为什么？</strong></h3>\n\n<p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>\n\n<h3 id=\"2-kafka-有几种数据保留的策略\"><strong>2. kafka 有几种数据保留的策略？</strong></h3>\n\n<p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>\n\n<h3 id=\"3-kafka-同时设置了-7-天和-10g-清除数据到第五天的时候消息达到了-10g这个时候-kafka-将如何处理\"><strong>3. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</strong></h3>\n\n<p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>\n\n<h3 id=\"4-什么情况会导致-kafka-运行变慢\"><strong>4. 什么情况会导致 kafka 运行变慢？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>cpu 性能瓶颈\n磁盘读写瓶颈\n网络瓶颈\n</code></pre>  </div></div>\n\n<h3 id=\"5-使用-kafka-集群需要注意什么\"><strong>5. 使用 kafka 集群需要注意什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。\n集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。\n</code></pre>  </div></div>\n\n<h2 id=\"三-zookeeper\"><strong>三. Zookeeper</strong></h2>\n\n<h3 id=\"1-zookeeper-是什么\"><strong>1. zookeeper 是什么？</strong></h3>\n\n<p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>\n\n<h3 id=\"2-zookeeper-都有哪些功能\"><strong>2. zookeeper 都有哪些功能？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.集群管理：监控节点存活状态、运行请求等。\n2.主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。\n3.分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。\n4.命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。\n</code></pre>  </div></div>\n\n<h3 id=\"3-zookeeper-有几种部署模式\"><strong>3. zookeeper 有几种部署模式？</strong></h3>\n\n<p>zookeeper 有三种部署模式：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>单机部署：一台集群上运行；\n集群部署：多台集群运行；\n伪集群部署：一台集群启动多个 zookeeper 实例运行。\n</code></pre>  </div></div>\n\n<h3 id=\"4-zookeeper-怎么保证主从节点的状态同步\"><strong>4. zookeeper 怎么保证主从节点的状态同步？</strong></h3>\n\n<p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。</p>\n\n<p>zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>\n\n<h3 id=\"5-集群中为什么要有主节点\"><strong>5. 集群中为什么要有主节点？</strong></h3>\n\n<p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>\n\n<h3 id=\"6-集群中有-3-台服务器其中一个节点宕机这个时候-zookeeper-还可以使用吗\"><strong>6. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</strong></h3>\n\n<p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>\n\n<h3 id=\"7-说一下-zookeeper-的通知机制\"><strong>7. 说一下 zookeeper 的通知机制？</strong></h3>\n\n<p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>\n\n<h2 id=\"四-mysql\"><strong>四. MySQL</strong></h2>\n\n<h3 id=\"1-数据库的三范式是什么\"><strong>1. 数据库的三范式是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。\n第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。\n第三范式：任何非主属性不依赖于其它非主属性。\n</code></pre>  </div></div>\n\n<h3 id=\"2-一张自增表里面总共有-7-条数据删除了最后-2-条数据重启-mysql-数据库又插入了一条数据此时-id-是几\"><strong>2. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>表类型如果是 MyISAM ，那 id 就是 8。\n表类型如果是 InnoDB，那 id 就是 6。\n</code></pre>  </div></div>\n\n<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>\n\n<h3 id=\"3-如何获取当前数据库版本\"><strong>3. 如何获取当前数据库版本？</strong></h3>\n\n<p>使用 select version() 获取当前 MySQL 数据库版本。</p>\n\n<h3 id=\"4-说一下-acid-是什么\"><strong>4. 说一下 ACID 是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。\n\nConsistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。\n\nIsolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\n\nDurability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n</code></pre>  </div></div>\n\n<h3 id=\"5-char-和-varchar-的区别是什么\"><strong>5. char 和 varchar 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>「char(n)」：固定长度类型，比如订阅 char(10)，当你输入\"abc\"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。\n</code></pre>  </div></div>\n\n<p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>「varchar(n)」：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。\n</code></pre>  </div></div>\n\n<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>\n\n<h3 id=\"6-float-和-double-的区别是什么\"><strong>6. float 和 double 的区别是什么？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。\ndouble 最可可以存储 16 位的十进制数，并在内存中占 8 字节。\n</code></pre>  </div></div>\n\n<h3 id=\"7-mysql-的内连接左连接右连接有什么区别\"><strong>7. MySQL 的内连接、左连接、右连接有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>内连接关键字：inner join；\n左连接：left join；\n右连接：right join。\n</code></pre>  </div></div>\n\n<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>\n\n<h3 id=\"8-mysql-索引是怎么实现的\"><strong>8. MySQL 索引是怎么实现的？</strong></h3>\n\n<p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>\n\n<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>\n\n<h3 id=\"9-怎么验证-mysql-的索引是否满足需求\"><strong>9. 怎么验证 MySQL 的索引是否满足需求？</strong></h3>\n\n<p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>explain 语法：explain select * from table where type=1。\n</code></pre>  </div></div>\n\n<h3 id=\"10-说一下数据库的事务隔离\"><strong>10. 说一下数据库的事务隔离？</strong></h3>\n\n<p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>transaction-isolation = REPEATABLE-READ  \n</code></pre>  </div></div>\n\n<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。\nREAD-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。\nREPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。\nSERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n「脏读」 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。\n\n「不可重复读」 ：是指在一个事务内，多次读同一数据。\n\n「幻读」 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。\n</code></pre>  </div></div>\n\n<h3 id=\"11-说一下-mysql-常用的引擎\"><strong>11. 说一下 MySQL 常用的引擎？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。\n\nMyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。\n</code></pre>  </div></div>\n\n<h3 id=\"12-说一下-mysql-的行锁和表锁\"><strong>12. 说一下 MySQL 的行锁和表锁？</strong></h3>\n\n<p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。\n行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。\n</code></pre>  </div></div>\n\n<h3 id=\"13-说一下乐观锁和悲观锁\"><strong>13. 说一下乐观锁和悲观锁？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。\n悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。\n</code></pre>  </div></div>\n\n<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>\n\n<h3 id=\"14-mysql-问题排查都有哪些手段\"><strong>14. MySQL 问题排查都有哪些手段？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>使用 show processlist 命令查看当前所有连接信息。\n使用 explain 命令查询 SQL 语句执行计划。\n开启慢查询日志，查看慢查询的 SQL。\n</code></pre>  </div></div>\n\n<h3 id=\"15-如何做-mysql-的性能优化\"><strong>15. 如何做 MySQL 的性能优化？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>为搜索字段创建索引。\n避免使用 select *，列出需要查询的字段。\n垂直分割分表。\n选择正确的存储引擎。\n</code></pre>  </div></div>\n\n<h2 id=\"五-redis\"><strong>五. Redis</strong></h2>\n\n<h3 id=\"1-redis-是什么都有哪些使用场景\"><strong>1. Redis 是什么？都有哪些使用场景？</strong></h3>\n\n<p>Redis 是一个使用 C 语言开发的高速缓存数据库。</p>\n\n<p>Redis 使用场景：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>记录帖子点赞数、点击数、评论数；\n缓存近期热帖；\n缓存文章详情信息；\n记录用户会话信息。\n</code></pre>  </div></div>\n\n<h3 id=\"2-redis-有哪些功能\"><strong>2. Redis 有哪些功能？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>数据缓存功能\n分布式锁的功能\n支持数据持久化\n支持事务\n支持消息队列\n</code></pre>  </div></div>\n\n<h3 id=\"3-redis-和-memcache-有什么区别\"><strong>3. Redis 和 memcache 有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。\n数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。\n使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。\nvalue 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。\n</code></pre>  </div></div>\n\n<h3 id=\"4-redis-为什么是单线程的\"><strong>4. Redis 为什么是单线程的？</strong></h3>\n\n<p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>\n\n<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n\n<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>\n\n<h3 id=\"5-什么是缓存穿透怎么解决\"><strong>5. 什么是缓存穿透？怎么解决？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。\n\n解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n</code></pre>  </div></div>\n\n<h3 id=\"6-redis-支持的数据类型有哪些\"><strong>6. Redis 支持的数据类型有哪些？</strong></h3>\n\n<p>Redis 支持的数据类型：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。\n</code></pre>  </div></div>\n\n<h3 id=\"7-redis-支持的-java-客户端都有哪些\"><strong>7. Redis 支持的 Java 客户端都有哪些？</strong></h3>\n\n<p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p>\n\n<h3 id=\"8-jedis-和-redisson-有哪些区别\"><strong>8. jedis 和 Redisson 有哪些区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jedis：提供了比较全面的 Redis 命令的支持。\nRedisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。\n</code></pre>  </div></div>\n\n<h3 id=\"9-怎么保证缓存和数据库数据的一致性\"><strong>9. 怎么保证缓存和数据库数据的一致性？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>合理设置缓存的过期时间。\n新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。\n</code></pre>  </div></div>\n\n<h3 id=\"10-redis-持久化有几种方式\"><strong>10. Redis 持久化有几种方式？</strong></h3>\n\n<p>Redis 的持久化有两种方式，或者说有两种策略：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。\nAOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。\n</code></pre>  </div></div>\n\n<h3 id=\"11-redis-怎么实现分布式锁\"><strong>11. Redis 怎么实现分布式锁？</strong></h3>\n\n<p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>\n\n<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>\n\n<h3 id=\"12-redis-分布式锁有什么缺陷\"><strong>12. Redis 分布式锁有什么缺陷？</strong></h3>\n\n<p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>\n\n<h3 id=\"13-redis-如何做内存优化\"><strong>13. Redis 如何做内存优化？</strong></h3>\n\n<p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p>\n\n<h3 id=\"14-redis-淘汰策略有哪些\"><strong>14. Redis 淘汰策略有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>volatile-lru：从已设置过期时间的数据集（server. db\\[i\\]. expires）中挑选最近最少使用的数据淘汰。\nvolatile-ttl：从已设置过期时间的数据集（server. db\\[i\\]. expires）中挑选将要过期的数据淘汰。\nvolatile-random：从已设置过期时间的数据集（server. db\\[i\\]. expires）中任意选择数据淘汰。\nallkeys-lru：从数据集（server. db\\[i\\]. dict）中挑选最近最少使用的数据淘汰。\nallkeys-random：从数据集（server. db\\[i\\]. dict）中任意选择数据淘汰。\nno-enviction（驱逐）：禁止驱逐数据。\n</code></pre>  </div></div>\n\n<h3 id=\"15-redis-常见的性能问题有哪些该如何解决\"><strong>15. Redis 常见的性能问题有哪些？该如何解决？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。\n\nRedis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。\n</code></pre>  </div></div>\n\n<h2 id=\"六-jvm\"><strong>六. JVM</strong></h2>\n\n<h3 id=\"1-说一下-jvm-的主要组成部分及其作用\"><strong>1. 说一下 JVM 的主要组成部分？及其作用？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>类加载器（ClassLoader）\n运行时数据区（Runtime Data Area）\n执行引擎（Execution Engine）\n本地库接口（Native Interface）\n\n「组件的作用」：首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。\n</code></pre>  </div></div>\n\n<h3 id=\"2-说一下-jvm-运行时数据区\"><strong>2. 说一下 JVM 运行时数据区？</strong></h3>\n\n<p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；\n\nJava 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；\n\n本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；\n\nJava 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；\n\n方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\n</code></pre>  </div></div>\n\n<h3 id=\"3-说一下堆栈的区别\"><strong>3. 说一下堆栈的区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>功能方面：堆是用来存放对象的，栈是用来执行程序的。\n共享性：堆是线程共享的，栈是线程私有的。\n空间大小：堆大小远远大于栈。\n</code></pre>  </div></div>\n\n<h3 id=\"4-队列和栈是什么有什么区别\"><strong>4. 队列和栈是什么？有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>队列和栈都是被用来预存储数据的。\n\n队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。\n\n栈和队列很相似，但它运行对元素进行后进先出进行检索。\n</code></pre>  </div></div>\n\n<h3 id=\"5-什么是双亲委派模型\"><strong>5. 什么是双亲委派模型？</strong></h3>\n\n<p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>\n\n<p>类加载器分类：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；\n\n其他类加载器：\n扩展类加载器（Extension ClassLoader）：负责加载&lt;java_home style=\"box-sizing: border-box; outline: 0px !important;\"&gt;libext目录或Java. ext. dirs系统变量指定的路径中的所有类库；\n应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。\n</code></pre>  </div></div>\n\n<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>\n\n<h3 id=\"6-说一下类装载的执行过程\"><strong>6. 说一下类装载的执行过程？</strong></h3>\n\n<p>类装载分为以下 5 个步骤：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>加载：根据查找路径找到相应的 class 文件然后导入；\n检查：检查加载的 class 文件的正确性；\n准备：给类中的静态变量分配内存空间；\n解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；\n初始化：对静态变量和静态代码块执行初始化工作。\n</code></pre>  </div></div>\n\n<h3 id=\"7-怎么判断对象是否可以被回收\"><strong>7. 怎么判断对象是否可以被回收？</strong></h3>\n\n<p>一般有两种方法来判断：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；\n可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。\n</code></pre>  </div></div>\n\n<h3 id=\"8-java-中都有哪些引用类型\"><strong>8. Java 中都有哪些引用类型？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>强引用：发生 gc 的时候不会被回收。\n软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。\n弱引用：有用但不是必须的对象，在下一次GC时会被回收。\n虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。\n</code></pre>  </div></div>\n\n<h3 id=\"9-说一下-jvm-有哪些垃圾回收算法\"><strong>9. 说一下 JVM 有哪些垃圾回收算法？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。\n标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。\n\n复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。\n\n分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。\n</code></pre>  </div></div>\n\n<h3 id=\"10-说一下-jvm-有哪些垃圾回收器\"><strong>10. 说一下 JVM 有哪些垃圾回收器？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Serial：最早的单线程串行垃圾回收器。\nSerial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。\nParNew：是 Serial 的多线程版本。\nParallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。\nParallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。\nCMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。\nG1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。\n</code></pre>  </div></div>\n\n<h3 id=\"11-详细介绍一下-cms-垃圾回收器\"><strong>11. 详细介绍一下 CMS 垃圾回收器？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。\n\nCMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。\n</code></pre>  </div></div>\n\n<h3 id=\"12-新生代垃圾回收器和老生代垃圾回收器都有哪些有什么区别\"><strong>12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>新生代回收器：Serial、ParNew、Parallel Scavenge\n老年代回收器：Serial Old、Parallel Old、CMS\n整堆回收器：G1\n</code></pre>  </div></div>\n\n<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>\n\n<h3 id=\"13-简述分代垃圾回收器是怎么工作的\"><strong>13. 简述分代垃圾回收器是怎么工作的？</strong></h3>\n\n<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>\n\n<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>把 Eden + From Survivor 存活的对象放入 To Survivor 区；\n清空 Eden 和 From Survivor 分区；\nFrom Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。\n</code></pre>  </div></div>\n\n<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>\n\n<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>\n\n<h3 id=\"14-说一下-jvm-调优的工具\"><strong>14. 说一下 JVM 调优的工具？</strong></h3>\n\n<p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>jconsole：用于对 JVM 中的内存、线程和类等进行监控；\njvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。\n</code></pre>  </div></div>\n\n<h3 id=\"15-常用的-jvm-调优的参数都有哪些\"><strong>15. 常用的 JVM 调优的参数都有哪些？</strong></h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-Xms2g：初始化推大小为 2g；\n-Xmx2g：堆最大内存为 2g；\n-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；\n-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；\n–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；\n-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；\n-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；\n-XX:+PrintGC：开启打印 gc 信息；\n-XX:+PrintGCDetails：打印 gc 详细信息。\n</code></pre>  </div></div>\n","dir":"/blog/development/interview/java/","name":"2023-04-23_4.md","path":"blog/development/interview/java/2023-04-23_4.md","url":"/blog/development/interview/java/2023-04-23_4.html"},{"sort":4,"layout":"default","title":"Restful风格开发方式","content":"<h1 id=\"restful风格开发方式\">Restful风格开发方式</h1>\n\n<h2 id=\"一概念\">一.概念</h2>\n\n<p>一种软件架构风格、设计风格，而<strong>不是</strong>标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>\n\n<h3 id=\"1url定义\">1.URL定义</h3>\n\n<p>资源：互联网所有的事物都可以被抽象为资源 <br />\n资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 <br />\n分别对应 添加、 删除、修改、查询。 </p>\n\n<h3 id=\"2传统方式操作资源\">2.传统方式操作资源 </h3>\n<p><a href=\"http://127.0.0.1/item/queryItem.action?id=1\">http://127.0.0.1/item/queryUser.action?id=1</a>   查询,GET <br />\n<a href=\"http://127.0.0.1/item/saveItem.action\">http://127.0.0.1/item/save</a><a href=\"http://127.0.0.1/item/queryItem.action?id=1\">User</a><a href=\"http://127.0.0.1/item/saveItem.action\">.action</a>             新增,POST <br />\n<a href=\"http://127.0.0.1/item/updateItem.action\">http://127.0.0.1/item/update</a><a href=\"http://127.0.0.1/item/queryItem.action?id=1\">User</a><a href=\"http://127.0.0.1/item/updateItem.action\">.action</a>          更新,POST <br />\n<a href=\"http://127.0.0.1/item/deleteItem.action?id=1\">http://127.0.0.1/item/delete</a><a href=\"http://127.0.0.1/item/queryItem.action?id=1\">User</a><a href=\"http://127.0.0.1/item/deleteItem.action?id=1\">.action?id=1</a>  删除,GET或POST</p>\n\n<h3 id=\"3请求方式\">3.请求方式</h3>\n\n<p>可以通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。其中，GET 用于查询资源，POST 用于创建资源，PUT 用于更新服务端的资源的全部信息，PATCH 用于更新服务端的资源的部分信息，DELETE 用于删除服务端的资源。</p>\n\n<p>这里使用“用户”的案例进行回顾通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。</p>\n\n<h2 id=\"二使用restful操作资源\">二.使用RESTful操作资源 </h2>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>【GET】 /users # 查询用户信息列表`\n\n【GET】 /users/1001 # 查看某个用户信息`\n\n【POST】 /users # 新建用户信息`\n\n【PUT】 /users/1001 # 更新用户信息(全部字段)`\n\n【PATCH】 /users/1001 # 更新用户信息(部分字段)`\n\n【DELETE】 /users/1001 # 删除用户信息`\n</code></pre>  </div></div>\n\n<p><strong>之前的操作是没有问题的,大神认为是有问题的,有什么问题呢?你每次请求的接口或者地址,都在做描述,例如查询的时候用了</strong>queryUser<strong>,新增的时候用了</strong>saveUser<strong> ，修改</strong>的时候用了<strong>updateUser</strong>,其实完全没有这个必要,我使用了get请求,就是查询.使用post请求,就是新增的请求,PUT就是修改，delete就是删除，我的意图很明显,完全没有必要做描述,这就是为什么有了restful.**</p>\n\n<h2 id=\"三api设计风格基本规则\">三.API设计风格基本规则</h2>\n\n<h3 id=\"1使用名词而不是动词\">1.使用名词而不是动词</h3>\n\n<p>不要使用：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/getAllUsers  \n/createNewUser  \n/deleteAllUser\n</code></pre>  </div></div>\n\n<h3 id=\"2get方法和查询参数不应该涉及状态改变\">2.Get方法和查询参数不应该涉及状态改变</h3>\n\n<p>使用<strong>PUT, POST</strong> 和<strong>DELETE</strong> 方法 而不是<strong> GET</strong> 方法来改变状态，不要使用<strong>GET</strong> 进行状态改变:</p>\n\n<h3 id=\"3使用复数名词\">3.使用复数名词</h3>\n\n<p>不要混淆名词单数和复数，为了保持简单，只对所有资源使用复数。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/cars 而不是 /car  \n/users 而不是 /user  \n/products 而不是 /product  \n/settings 而部署 /setting\n</code></pre>  </div></div>\n\n<h3 id=\"4-使用子资源表达关系\">4. 使用子资源表达关系</h3>\n\n<p>如果一个资源与另外一个资源有关系，使用子资源：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GET /cars/711/drivers/ 返回 car 711的所有司机  \nGET /cars/711/drivers/4 返回 car 711的4号司机\n</code></pre>  </div></div>\n\n<h3 id=\"5使用http头声明序列化格式\">5.使用Http头声明序列化格式</h3>\n\n<p>在客户端和服务端，双方都要知道通讯的格式，格式在HTTP-Header中指定</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Content-Type 定义请求格式  \nAccept 定义系列可接受的响应格式\n</code></pre>  </div></div>\n\n<h3 id=\"6为集合提供过滤-排序-选择和分页等功能\">6.为集合提供<strong>过滤 排序 选择和分页等功能</strong></h3>\n\n<p><strong>Filtering过滤</strong>:</p>\n\n<p>使用唯一的查询参数进行过滤：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GET /cars?color=red 返回红色的cars  \nGET /cars?seats&lt;=2 返回小于两座位的cars集合\n</code></pre>  </div></div>\n\n<p><strong>Sorting</strong>排序:</p>\n\n<p>允许针对多个字段排序</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GET /cars?sort=-manufactorer,+model\n</code></pre>  </div></div>\n\n<p>这是返回根据生产者降序和模型升序排列的car集合</p>\n\n<p><strong>Field selection</strong></p>\n\n<p>移动端能够显示其中一些字段，它们其实不需要一个资源的所有字段，给API消费者一个选择字段的能力，这会降低网络流量，提高API可用性。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GET /cars?fields=manufacturer,model,id,color\n</code></pre>  </div></div>\n\n<p><strong>Paging分页</strong></p>\n\n<p>使用 limit 和offset.实现分页，缺省limit=20 和offset=0；</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GET /cars?offset=10&amp;limit=5\n</code></pre>  </div></div>\n\n<p>为了将总数发给客户端，使用订制的HTTP头： X-Total-Count.</p>\n\n<p>链接到下一页或上一页可以在HTTP头的link规定，遵循Link规定:</p>\n\n<p>Link: <a href=\"https://justmyfreedom.com/blog/frontier/new/technology/2023-04-23_1.html\">https://justmyfreedom.com/blog/frontier/new/technology/2023-04-23_1.html</a>; rel=”next”,<br />\n<a href=\"https://justmyfreedom.com/blog/development/interview/java/2023-04-23_1.html\">https://justmyfreedom.com/blog/development/interview/java/2023-04-23_1.html</a>; rel=”last”,<br />\n<a href=\"https://justmyfreedom.com/blog/development/interview/java/2023-04-23_4.html\">https://justmyfreedom.com/blog/development/interview/java/2023-04-23_4.html</a>; rel=”first”,<br />\n<a href=\"https://justmyfreedom.com/blog/development/html/jottings/2023-04-21_1.html\">https://justmyfreedom.com/blog/development/html/jottings/2023-04-21_1.html</a>; rel=”prev”,</p>\n\n<h3 id=\"7版本化你的api\">7.版本化你的API</h3>\n\n<p>使得API版本变得强制性，不要发布无版本的API，使用简单数字，避免小数点如2.5.</p>\n\n<p>一般在Url后面使用?v</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/blog/api/v1\n</code></pre>  </div></div>\n\n<h3 id=\"8-使用http状态码处理错误\">8. 使用Http状态码处理错误</h3>\n\n<p>如果你的API没有错误处理是很难的，只是返回500和出错堆栈不一定有用</p>\n\n<p>Http状态码提供70个出错，我们只要使用10个左右：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>200 – OK – 一切正常  \n201 – OK – 新的资源已经成功创建  \n204 – OK – 资源已经成功擅长\n\n304 – Not Modified – 客户端使用缓存数据\n\n400 – Bad Request – 请求无效，需要附加细节解释如 \"JSON无效\"  \n401 – Unauthorized – 请求需要用户验证  \n403 – Forbidden – 服务器已经理解了请求，但是拒绝服务或这种请求的访问是不允许的。  \n404 – Not found – 没有发现该资源  \n422 – Unprocessable Entity – 只有服务器不能处理实体时使用，比如图像不能被格式化，或者重要字段丢失。\n\n500 – Internal Server Error – API开发者应该避免这种错误。\n</code></pre>  </div></div>\n\n<p>使用详细的错误包装错误：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>{\n\n  \"errors\": \\[\n\n   {\n\n    \"userMessage\": \"Sorry, the requested resource does not exist\",\n\n    \"internalMessage\": \"No car found in the database\",\n\n    \"code\": 34,\n\n    \"more info\": \"http://dev.mwaysolutions.com/blog/api/v1/errors/12345\"\n\n   }\n\n  \\]\n\n}\n</code></pre>  </div></div>\n\n<h3 id=\"9允许覆盖http方法\">9.允许覆盖http方法</h3>\n\n<p>一些代理只支持<strong>POST</strong> 和 <strong>GET方法，</strong> 为了使用这些有限方法支持RESTful API，需要一种办法覆盖http原来的方法。</p>\n\n<p>使用订制的HTTP头 <strong>X-HTTP-Method-Override</strong> 来覆盖POST 方法.</p>\n\n<p>总而言之restful是一种旧技术新风格</p>\n","dir":"/blog/development/java/jottings/","name":"2023-05-12_1.md","path":"blog/development/java/jottings/2023-05-12_1.md","url":"/blog/development/java/jottings/2023-05-12_1.html"},{"sort":4,"permalink":"/blog/development/python/","layout":"default","title":"Python笔记","content":"<h1 id=\"python笔记\">Python笔记</h1>\n\n<ul>\n <li><a href=\"/blog/development/python/jottings/\">随笔</a></li>\n <li><a href=\"/blog/development/python/django/\">Django</a>\n <ul>\n <li><a href=\"/blog/development/python/django/2023-04-27_1.html\">Django中url与path及re_path区别</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/python/","name":"README.md","path":"blog/development/python/README.md","url":"/blog/development/python/"},{"sort":4,"permalink":"/blog/development/python/jottings/","layout":"default","title":"随笔","content":"<h1 id=\"随笔\">随笔</h1>\n\n","dir":"/blog/development/python/jottings/","name":"README.md","path":"blog/development/python/jottings/README.md","url":"/blog/development/python/jottings/"},{"sort":4,"layout":"default","title":"laydate渲染日期","content":"<h1 id=\"laydate渲染日期\">laydate渲染日期</h1>\n\n<h2 id=\"一-laydate渲染开始日期结束日期并限制选择\">一. laydate渲染开始日期结束日期并限制选择</h2>\n\n<h3 id=\"html页面日期组件\">html页面日期组件：</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;div class=\"layui-inline\"&gt;\n   &lt;label class=\"layui-form-label\"&gt;开始日期：&lt;span\n           class=\"layui-font-red\"&gt;*&lt;/span&gt;：&lt;/label&gt;\n   &lt;div class=\"layui-input-inline\" id=\"bData1\"&gt;\n       &lt;input type=\"text\" name=\"bDate\" id=\"bDate\" lay-verify=\"date|required\"\n              placeholder=\"yyyy-MM-dd\" autocomplete=\"off\" class=\"layui-input\"&gt;\n   &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"layui-inline\"&gt;\n   &lt;label class=\"layui-form-label\"&gt;结束日期：&lt;span\n           class=\"layui-font-red\"&gt;*&lt;/span&gt;：&lt;/label&gt;\n   &lt;div class=\"layui-input-inline\" id=\"eData1\"&gt;\n       &lt;input type=\"text\" name=\"eDate\" id=\"eDate\" lay-verify=\"date|required\"\n              placeholder=\"yyyy-MM-dd\" autocomplete=\"off\" class=\"layui-input\"&gt;\n   &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>  </div></div>\n\n<h3 id=\"js渲染方法一\">js渲染方法一：</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>//获取当前年份\nvar nowDateYear = new Date().getFullYear();\nvar minDate = nowDateYear + '-01-01';\nvar maxDate = nowDateYear + '-12-31';\n \nvar startDate=laydate.render({\n\telem: '#bDate'\n\t,min: minDate\n\t,max: maxDate\n\t, done: function (value, dates) {\n\t      endDate.config.min = {\n\t          year: dates.year,\n\t          month: dates.month - 1, //关键\n\t          date: dates.date,\n\t          hours: 0,\n\t          minutes: 0,\n\t          seconds: 0\n\t      }\n\t   }\n\t});\n\nvar endDate=laydate.render({\n      elem: '#eDate'\n      ,min: minDate\n      ,max: maxDate\n     ,done: function (value, dates) {\n         startDate.config.max={\n             year:dates.year,\n             month:dates.month-1,//关键\n             date: dates.date,\n             hours: 0,\n             minutes: 0,\n             seconds : 0\n         }\n     }\n  });\n</code></pre>  </div></div>\n\n<h3 id=\"js渲染方法二\">js渲染方法二：</h3>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>var beginDay = editPreBill.bDate || ''; //默认值\nvar endDay = editPreBill.eDate || '';   //默认值\n//开始\nwriteBdate('bData', beginDay, endDay);\n//结束\nwriteEdate('eData', endDay, beginDay);\n\n//渲染开始日期\nfunction writeBdate(elem1, value1, value2) {\n    laydate.render({\n        elem: '#' + elem1\n        , value: value1//初始值\n        , max: value2 == '' ? 4073558400000 : value2\n        , done: function (value, date, endDate) {\n            beginDay = value;\n//重新结束渲染\n            $(\"#eData\").remove();\n            $(\"#eData1\").html(' &lt;input type=\"text\" name=\"eDate\" id=\"eData\" lay-verify=\"date\" placeholder=\"yyyy-MM-dd\" autocomplete=\"off\" class=\"layui-input\"&gt;');\n            writeEdate(\"eData\", value2, beginDay);\n        }\n    });\n}\n\nfunction writeEdate(elem1, value1, value2) {\n    laydate.render({\n        elem: '#' + elem1\n        , value: value1//初始值\n        , min: value2 == '' ? -4073558400000 : value2\n        , done: function (value, date, endDate) {\n            endDay = value;\n//重新渲染\n            $(\"#bData\").remove();\n            $(\"#bData1\").html(' &lt;input type=\"text\" name=\"bDate\" id=\"bData\" lay-verify=\"date\" placeholder=\"yyyy-MM-dd\" autocomplete=\"off\" class=\"layui-input\"&gt;');\n            writeBdate(\"bData\", value2, endDay);\n        }\n    });\n}\n</code></pre>  </div></div>\n\n<h2 id=\"laydaterender常见问题\">laydate.render常见问题</h2>\n\n<h3 id=\"layui的laydaterender多次渲染的问题\">layui的laydate.render()多次渲染的问题</h3>\n\n<p><strong>描述：根据“上午”、“下午”的不同选择，限制可选时间的组件显示不同内容</strong></p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&lt;div className=\"main-head\"&gt;\n    &lt;p&gt;&lt;span&gt;在线预定&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;\n&lt;div className=\"main-reserve\"&gt;\n    &lt;form action=\"#\" method=\"post\" id=\"food-reserve\" className=\"layui-form\"&gt;\n        &lt;ul&gt;\n            &lt;li&gt;\n                &lt;div className=\"layui-inline\"&gt;\n                    &lt;div className=\"layui-input-inline\"&gt;\n                        &lt;select name=\"modules\" lay-verify=\"required\" onChange=\"selectFood()\" lay-search=\"\"&gt;\n                            &lt;option value=\"0\" selected&gt;请选择时间范围&lt;/option&gt;\n                            &lt;option value=\"1\"&gt;上午&lt;/option&gt;\n                            &lt;option value=\"2\"&gt;下午&lt;/option&gt;\n                        &lt;/select&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/li&gt;\n\n            &lt;li&gt;\n                &lt;label className=\"layui-form-label\"&gt;时间&lt;/label&gt;\n                &lt;div className=\"layui-input-inline\" id=\"timeInput\"&gt;\n                    &lt;input type=\"text\" className=\"layui-input\" id=\"test-limit3\" name=\"time\" autoComplete=\"off\"&gt;\n                &lt;/div&gt;\n            &lt;/li&gt;\n        &lt;/ul&gt;\n        &lt;div className=\"layui-form-item\"&gt;\n            &lt;div className=\"layui-input-block\"&gt;\n                &lt;button className=\"layui-btn\" lay-submit=\"\" lay-filter=\"demo1\"&gt;立即提交&lt;/button&gt;\n                &lt;button type=\"reset\" className=\"layui-btn layui-btn-primary\"&gt;重置&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n    &lt;/form&gt;\n&lt;/div&gt;\n    \n</code></pre>  </div></div>\n\n<p><strong>laydate.render()只会渲染一次，若要多次渲染，可以移除元素，重新加载</strong></p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>var form;\nlayui.use(['laydate', 'form'], function () {\n    var laydate = layui.laydate;\n    form = layui.form; //只有执行了这一步，部分表单元素才会自动修饰成功\n\n    form.on('select', function (data) {\n        //获取被选中的option标签\n        var flag = data.value;\n        if (flag == 1) {\n            /* 移除元素，重新加载 */\n            $(\"#test-limit3\").remove();\n            $(\"#timeInput\").html('&lt;input type=\"text\" class=\"layui-input\" id=\"test-limit3\" name=\"time\" autocomplete=\"off\"&gt;');\n            //限定可选时间\n            laydate.render({\n                elem: '#test-limit3'\n                , type: 'time'\n                , min: '10:30:00'\n                , max: '12:00:00'\n                , btns: ['clear', 'confirm']\n            });\n        } else if (flag == 2) {\n            $(\"#test-limit3\").remove();\n            $(\"#timeInput\").html('&lt;input type=\"text\" class=\"layui-input\" id=\"test-limit3\" name=\"time\" autocomplete=\"off\"&gt;');\n            //限定可选时间\n            laydate.render({\n                elem: '#test-limit3'\n                , type: 'time'\n                , min: '14:00:00'\n                , max: '22:00:00'\n                , btns: ['clear', 'confirm']\n            });\n        } else {\n            alert(\"请选择时间范围\");\n        }\n    })；\n});\n</code></pre>  </div></div>\n","dir":"/blog/development/html/jottings/","name":"2023-05-12_2.md","path":"blog/development/html/jottings/2023-05-12_2.md","url":"/blog/development/html/jottings/2023-05-12_2.html"},{"sort":4,"permalink":"/blog/development/python/django/","layout":"default","title":"Django","content":"<h1 id=\"django\">Django</h1>\n\n<ul>\n <li><a href=\"/blog/development/python/django/2023-04-27_1.html\">Django中url与path及re_path区别</a></li>\n</ul>\n","dir":"/blog/development/python/django/","name":"README.md","path":"blog/development/python/django/README.md","url":"/blog/development/python/django/"},{"sort":8,"permalink":"/blog/development/os/","layout":"default","title":"操作系统","content":"<h1 id=\"操作系统\">操作系统</h1>\n\n<ul>\n <li><a href=\"/blog/development/os/linux/\">linux</a>\n <ul>\n <li><a href=\"/blog/development/os/linux/2023-04-23_1.html\">Linux的上传和下载功能</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/os/windows/\">windows</a>\n <ul>\n <li><a href=\"/blog/development/os/windows/2023-04-27_1.html\">Windows端口常见问题解决</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/os/","name":"README.md","path":"blog/development/os/README.md","url":"/blog/development/os/"},{"sort":9,"permalink":"/blog/development/java/tool/","layout":"default","title":"工具包","content":"<h1 id=\"工具包\">工具包</h1>\n\n<ul>\n <li><a href=\"/blog/development/java/tool/2023-05-12_1.html\">EASYEXCEL使用详解</a></li>\n</ul>\n","dir":"/blog/development/java/tool/","name":"README.md","path":"blog/development/java/tool/README.md","url":"/blog/development/java/tool/"},{"sort":9,"permalink":"/blog/development/html/seo/","layout":"default","title":"SEO优化","content":"<h1 id=\"seo优化\">SEO优化</h1>\n\n<ul>\n <li><a href=\"/blog/development/html/seo/2023-04-27_1.html\">NGINX强制使用https访问(http跳转到https)</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_2.html\">最新主流搜索引擎提交sitemap大全（网站地图）</a></li>\n <li><a href=\"/blog/development/html/seo/2023-04-27_3.html\">SEO实操小技巧关键字</a></li>\n</ul>\n","dir":"/blog/development/html/seo/","name":"README.md","path":"blog/development/html/seo/README.md","url":"/blog/development/html/seo/"},{"sort":9,"permalink":"/blog/about/","layout":"default","title":"关于","content":"<h1 id=\"关于\">关于</h1>\n<p>网站相关文章目录</p>\n\n<ul>\n <li><a href=\"/blog/about/website/\">网站</a>\n <ul>\n <li><a href=\"/blog/about/website/2023-04-23_1.html\">关于Justmyfreedom网站</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/about/","name":"README.md","path":"blog/about/README.md","url":"/blog/about/"},{"sort":9,"permalink":"/blog/development/html/webdesign/","layout":"default","title":"Jekyll网站开发","content":"<h1 id=\"jekyll网站开发\">Jekyll网站开发</h1>\n\n<ul>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_1.html\">Jekyll安装配置和使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-04-24_2.html\">七牛云对象存储(图床)免费使用</a></li>\n <li><a href=\"/blog/development/html/webdesign/2023-05-12_1.html\">免费的Jekyll静态网站发布平台</a></li>\n</ul>\n","dir":"/blog/development/html/webdesign/","name":"README.md","path":"blog/development/html/webdesign/README.md","url":"/blog/development/html/webdesign/"},{"sort":9,"permalink":"/blog/development/tool/","layout":"default","title":"工具","content":"<h1 id=\"工具\">工具</h1>\n\n<ul>\n <li><a href=\"/blog/development/tool/redis/\">Redis</a>\n <ul>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_1.html\">Windows部署redis集群模式</a></li>\n <li><a href=\"/blog/development/tool/redis/2023-04-30_2.html\">redis如何设置密码</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/git/\">Git</a>\n <ul>\n <li><a href=\"/blog/development/tool/git/2023-04-27_1.html\">最新Github创建仓库,将项目上传到GitHub</a></li>\n <li><a href=\"/blog/development/tool/git/2023-04-28_1.html\">Git一份代码同时提交两个Git仓库</a></li>\n <li><a href=\"/blog/development/tool/git/2023-05-12_1.html\">Git常用操作命令</a></li>\n </ul>\n </li>\n <li><a href=\"/blog/development/tool/maven/\">Java基础</a>\n <ul>\n <li><a href=\"/blog/development/tool/maven/2023-04-27_1.html\">Maven推送本地jar包到仓库</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/blog/development/tool/","name":"README.md","path":"blog/development/tool/README.md","url":"/blog/development/tool/"}]